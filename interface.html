<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>App Builder - AI Powered</title>
  <script src="https://unpkg.com/lucide@latest"></script>
  <style>
    /* ===== CSS VARIABLES & DESIGN TOKENS ===== */
    :root {
      --primary-blue: #0053E2;
      --spark-yellow: #FFC220;
      --bentonville-blue: #001E60;
      --surface-gray: #F4F4F6;
      --everyday-blue: #4DBDF5;
      --success-green: #10B981;
      --error-red: #EF4444;
      --warning-orange: #f59e0b;
      --sidebar-dark: #0f0f0f;
      --border-gray: #e5e7eb;
      --text-primary: #1f2937;
      --text-secondary: #6b7280;
      --bg-white: #ffffff;
      
      /* Spacing. */
      --space-1: 4px; --space-2: 8px; --space-3: 12px; 
      --space-4: 16px; --space-5: 20px; --space-6: 24px;
      
      /* Timing functions */
      --ease-out: cubic-bezier(0.4, 0, 0.2, 1);
      --ease-in: cubic-bezier(0.4, 0, 1, 1);
      --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);
      --ease-back: cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    /* ===== GLOBAL RESETS & BASE STYLES ===== */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      color: var(--text-primary);
      background: var(--surface-gray);
      overflow: hidden;
      height: 100vh;
      display: flex;
    }

    /* ===== LEFT CHAT PANEL (ALWAYS VISIBLE) ===== */
    .left-chat-panel {
      width: 420px;
      background: white;
      height: 100vh;
      display: flex;
      flex-direction: column;
      border-right: 1px solid var(--border-gray);
      position: fixed;
      left: 0;
      top: 0;
      z-index: 100;
    }

    .chat-header {
      padding: var(--space-4);
      border-bottom: 1px solid var(--border-gray);
    }

    .chat-header h2 {
      font-size: 20px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: var(--space-2);
      margin-bottom: var(--space-2);
    }

    .chat-subtitle {
      font-size: 14px;
      color: var(--text-secondary);
    }
    
    .mode-tab {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 6px 12px;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      border-radius: 6px;
      cursor: pointer;
      transition: all 150ms;
    }
    
    .mode-tab i {
      width: 14px;
      height: 14px;
    }
    
    .mode-tab.active {
      background: var(--primary-blue);
      color: white;
    }
    
    .mode-tab:not(.active):hover {
      background: rgba(0, 0, 0, 0.05);
      color: var(--text-primary);
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: var(--space-4);
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
    }

    .chat-message {
      padding: var(--space-3);
      border-radius: 12px;
      font-size: 14px;
      line-height: 1.6;
      max-width: 85%;
      position: relative;
    }

    .chat-message.user {
      background: var(--primary-blue);
      color: white;
      padding-right: 48px; /* Make room for restore button */
      margin-left: auto;
      border-bottom-right-radius: 4px;
    }

    .chat-message.assistant {
      background: var(--surface-gray);
      color: var(--text-primary);
      margin-right: auto;
      border-bottom-left-radius: 4px;
      max-width: 100%; /* Use full width for AI responses */
    }
    
    .chat-message.streaming-message {
      background: linear-gradient(135deg, var(--surface-gray) 0%, rgba(0, 116, 217, 0.03) 100%);
      color: var(--text-primary);
      margin-right: auto;
      border-bottom-left-radius: 4px;
      position: relative;
      animation: pulse-border 1.5s ease-in-out infinite;
      line-height: 1.7;
      letter-spacing: 0.01em;
    }
    
    .chat-message.streaming-message p {
      margin-bottom: 0.8em;
      line-height: 1.7;
    }
    
    .chat-message.streaming-message p:last-child {
      margin-bottom: 0;
    }
    
    @keyframes pulse-border {
      0%, 100% {
        border-left: 3px solid var(--primary-blue);
      }
      50% {
        border-left: 3px solid var(--everyday-blue);
      }
    }
    
    .chat-message.streaming-message::after {
      content: '';
      display: inline-block;
      width: 8px;
      height: 8px;
      margin-left: 4px;
      border-radius: 50%;
      background: var(--primary-blue);
      animation: blink 1s ease-in-out infinite;
    }
    
    @keyframes blink {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.3;
      }
    }
    
    .message-content {
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
    }
    
    .streaming-text-content {
      font-size: 14px;
      line-height: 1.6;
      word-wrap: break-word;
      overflow-wrap: break-word;
      min-height: 20px;
    }
    
    .chat-message.thinking-message {
      background: #1e1e1e;
      border-left: 3px solid var(--primary-blue);
      padding: 0;
      border-radius: 8px;
      overflow: hidden;
    }
    
    .thinking-header {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      user-select: none;
      padding: 10px 14px;
      background: #2d2d2d;
      font-family: 'SF Mono', 'Monaco', 'Consolas', 'Courier New', monospace;
      font-size: 12px;
      color: #6a9955;
      font-style: italic;
      border-bottom: 1px solid #333333;
    }
    
    .thinking-header:hover {
      background: #333333;
    }
    
    .thinking-label {
      font-size: 12px;
      font-weight: 400;
      color: #6a9955;
    }
    
    .thinking-badge {
      background: var(--primary-blue);
      color: white;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 10px;
      font-weight: 600;
      font-style: normal;
      margin-left: auto;
    }
    
    .thinking-chevron {
      transition: transform 0.2s ease;
      color: #6a9955;
    }
    
    .thinking-preview {
      display: none;
    }
    
    .thinking-content {
      padding: 14px;
      background: #1e1e1e;
      font-family: 'SF Mono', 'Monaco', 'Consolas', 'Courier New', monospace;
      font-size: 12px;
      line-height: 1.6;
      color: #d4d4d4;
      max-height: 300px;
      overflow-y: auto;
      overflow-x: hidden;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    
    .thinking-content::-webkit-scrollbar {
      width: 8px;
    }
    
    .thinking-content::-webkit-scrollbar-track {
      background: #2d2d2d;
      border-radius: 0;
    }
    
    .thinking-content::-webkit-scrollbar-thumb {
      background: #555555;
      border-radius: 0;
    }
    
    .thinking-content::-webkit-scrollbar-thumb:hover {
      background: #666666;
    }

    .chat-message.system {
      background: var(--surface-gray);
      color: var(--text-primary);
      font-size: 13px;
      max-width: 100%;
      margin-right: auto;
      border-bottom-left-radius: 4px;
    }

    .chat-message.system.error {
      background: var(--surface-gray);
      color: var(--error-red);
    }
    
    /* Version restore button in chat messages */
    .version-restore-btn {
      position: absolute;
      right: var(--space-2);
      top: 50%;
      transform: translateY(-50%);
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      border-radius: 6px;
      color: white;
      cursor: pointer;
      opacity: 0;
      transition: all 200ms var(--ease-out);
    }
    
    .chat-message.user:hover .version-restore-btn {
      opacity: 0.7;
    }
    
    .version-restore-btn:hover {
      opacity: 1 !important;
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-50%) scale(1.1);
    }
    
    .version-restore-btn i {
      width: 16px;
      height: 16px;
    }
    
    .chat-message.version-current {
      border: 2px solid var(--spark-yellow);
      box-shadow: 0 0 0 3px rgba(255, 194, 32, 0.1);
    }
    
    .chat-message.version-current .version-restore-btn {
      opacity: 1;
      background: var(--spark-yellow);
      color: var(--bentonville-blue);
    }

    .typing-indicator {
      display: flex;
      gap: 6px;
      padding: var(--space-2);
    }

    .typing-indicator span {
      width: 8px;
      height: 8px;
      background: var(--text-secondary);
      border-radius: 50%;
      animation: typing-dot 1.4s infinite;
    }

    .typing-indicator span:nth-child(2) {
      animation-delay: 0.2s;
    }

    .typing-indicator span:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes typing-dot {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-10px); }
    }

    .chat-input-area {
      padding: var(--space-4);
      border-top: 1px solid var(--border-gray);
    }

    .chat-input-wrapper {
      display: flex;
      gap: var(--space-2);
      margin-bottom: var(--space-3);
    }

    #chatInput {
      flex: 1;
      padding: var(--space-3);
      border: 1px solid var(--border-gray);
      border-radius: 8px;
      font-size: 14px;
      font-family: inherit;
      resize: none;
      max-height: 120px;
      transition: border-color 150ms;
    }

    #chatInput:focus {
      outline: none;
      border-color: var(--primary-blue);
    }

    .chat-library-btn {
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--surface-gray);
      border: 1px solid var(--border-gray);
      border-radius: 8px;
      color: var(--text-primary);
      cursor: pointer;
      transition: all 150ms;
      flex-shrink: 0;
    }

    .chat-library-btn:hover {
      background: #e8e8ea;
      transform: scale(1.05);
    }

    .chat-library-btn:active {
      transform: scale(0.98);
    }

    .chat-send {
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--primary-blue);
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      transition: all 150ms;
      flex-shrink: 0;
    }

    .chat-send:hover {
      background: #0046c7;
      transform: scale(1.05);
    }

    .chat-send:active {
      transform: scale(0.98);
    }

    .chat-send:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .chat-selected-framework {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      padding: var(--space-2) var(--space-3);
      background: rgba(16, 185, 129, 0.1);
      border-radius: 6px;
      font-size: 13px;
      color: var(--success-green);
      margin-top: var(--space-2);
    }

    .chat-selected-framework i {
      width: 16px;
      height: 16px;
    }

    .chat-actions {
      display: flex;
      gap: var(--space-2);
    }

    .chat-actions button {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-2);
      padding: var(--space-2) var(--space-3);
      background: var(--surface-gray);
      border: 1px solid var(--border-gray);
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
      transition: all 150ms;
    }

    .chat-actions button:hover:not(:disabled) {
      background: #e8e8ea;
    }

    .chat-actions button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Drag and Drop Zone */
    .drag-drop-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 83, 226, 0.05);
      border: 2px dashed var(--primary-blue);
      border-radius: 12px;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: all;
      z-index: 100;
      animation: dragFadeIn 0.2s ease-out;
    }

    .drag-drop-overlay.active {
      display: flex;
    }
    
    .drag-drop-overlay.drag-hover {
      background: rgba(0, 83, 226, 0.1);
      border-color: var(--bentonville-blue);
    }

    .drag-drop-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-2);
      padding: var(--space-4);
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    .drag-drop-content i {
      width: 48px;
      height: 48px;
      color: var(--primary-blue);
    }

    .drag-drop-content .drag-drop-text {
      font-size: 16px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .drag-drop-content .drag-drop-hint {
      font-size: 12px;
      color: var(--text-secondary);
    }

    @keyframes dragFadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    .chat-input-area {
      position: relative;
    }

    /* ===== RIGHT CONTENT PANEL ===== */
    .right-content-panel {
      margin-left: 420px;
      flex: 1;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    /* Top Navigation Bar */
    .top-nav-bar {
      background: var(--sidebar-dark);
      padding: var(--space-3) var(--space-4);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      gap: var(--space-3);
    }

    .project-info {
      flex: 1;
    }

    .project-name {
      color: white;
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .project-status {
      color: rgba(255, 255, 255, 0.5);
      font-size: 12px;
    }

    .publish-status-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      background: rgba(16, 185, 129, 0.15);
      border-radius: 12px;
      border: 1px solid rgba(16, 185, 129, 0.3);
    }

    .publish-status-indicator .status-dot {
      width: 8px;
      height: 8px;
      background: var(--success-green);
      border-radius: 50%;
      animation: pulse-dot 2s ease-in-out infinite;
    }

    @keyframes pulse-dot {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(0.9); }
    }

    .publish-status-indicator .status-text {
      font-size: 12px;
      color: var(--success-green);
      font-weight: 600;
    }

    .nav-tabs {
      display: flex;
      gap: var(--space-2);
      background: rgba(255, 255, 255, 0.05);
      padding: 4px;
      border-radius: 8px;
    }

    .nav-tab {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 200ms var(--ease-out);
      position: relative;
      overflow: hidden;
    }

    .nav-tab::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      transform: translate(-50%, -50%);
      transition: width 400ms, height 400ms;
    }

    .nav-tab:active::after {
      width: 200px;
      height: 200px;
    }

    .nav-tab.active {
      background: var(--primary-blue);
      color: white;
    }

    .nav-tab:not(.active):hover {
      background: rgba(255, 255, 255, 0.08);
      color: white;
    }

    .nav-tab i {
      width: 16px;
      height: 16px;
    }

    .top-nav-actions {
      display: flex;
      gap: var(--space-2);
    }

    .btn-top-action {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      color: white;
      font-size: 13px;
      cursor: pointer;
      transition: all 150ms;
    }

    .btn-top-action:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .btn-top-action.primary {
      background: var(--spark-yellow);
      border-color: var(--spark-yellow);
      color: var(--bentonville-blue);
      font-weight: 600;
    }

    .btn-top-action.primary:hover {
      background: #ffd666;
    }

    /* Secondary Navigation (Cloud view) */
    .secondary-nav {
      background: white;
      border-bottom: 1px solid var(--border-gray);
      padding: 0 var(--space-4);
      display: flex;
      gap: var(--space-1);
    }

    .secondary-nav-item {
      padding: var(--space-3) var(--space-4);
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 200ms;
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    .secondary-nav-item i {
      width: 18px;
      height: 18px;
    }

    .secondary-nav-item.active {
      color: var(--primary-blue);
      border-bottom-color: var(--primary-blue);
    }

    .secondary-nav-item:hover:not(.active) {
      color: var(--text-primary);
      background: var(--surface-gray);
    }

    /* Main Content Area */
    .main-content {
      flex: 1;
      overflow-y: auto;
      background: white;
      min-height: 0;
    }

    .content-view {
      display: none;
      padding: var(--space-4) var(--space-6);
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 250ms var(--ease-out), transform 250ms var(--ease-out);
      height: 100%;
      overflow-y: auto;
    }

    .content-view.active {
      display: flex;
      flex-direction: column;
      animation: fadeIn 300ms var(--ease-out) forwards;
    }

    @keyframes fadeIn {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-20px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    /* ===== CONTENT STYLES ===== */
    .page-header {
      margin-bottom: var(--space-4);
      flex-shrink: 0;
    }

    .page-header h1 {
      font-size: 28px;
      font-weight: 600;
      margin-bottom: var(--space-2);
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    .subtitle {
      color: var(--text-secondary);
      font-size: 14px;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: var(--space-4);
      flex-shrink: 0;
    }

    .section-header h2 {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: var(--space-1);
    }

    .section-subtitle {
      color: var(--text-secondary);
      font-size: 13px;
    }

    /* Buttons */
    .btn-primary, .btn-secondary {
      display: inline-flex;
      align-items: center;
      gap: var(--space-2);
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 150ms var(--ease-out);
      border: none;
      white-space: nowrap;
    }

    .btn-primary i, .btn-secondary i {
      width: 16px;
      height: 16px;
    }

    .btn-primary {
      background: var(--primary-blue);
      color: white;
    }

    .btn-primary:hover {
      background: #0046c7;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 83, 226, 0.25);
    }

    .btn-secondary {
      background: var(--surface-gray);
      color: var(--text-primary);
      border: 1px solid var(--border-gray);
    }

    .btn-secondary:hover {
      background: #e8e8ea;
    }

    .btn-primary:active, .btn-secondary:active {
      transform: translateY(0);
    }

    /* Database Tables Grid */
    .tables-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
      gap: var(--space-3);
      flex: 1;
      overflow-y: auto;
      align-content: start;
    }

    .table-card {
      background: white;
      border: 1px solid var(--border-gray);
      border-radius: 12px;
      padding: var(--space-4);
      cursor: pointer;
      transition: all 200ms var(--ease-out);
      opacity: 0;
      animation: scaleIn 300ms var(--ease-out) forwards;
      min-height: 140px;
      display: flex;
      flex-direction: column;
    }

    .table-card:nth-child(1) { animation-delay: 0ms; }
    .table-card:nth-child(2) { animation-delay: 75ms; }
    .table-card:nth-child(3) { animation-delay: 150ms; }
    .table-card:nth-child(4) { animation-delay: 225ms; }
    .table-card:nth-child(5) { animation-delay: 300ms; }
    .table-card:nth-child(6) { animation-delay: 375ms; }

    @keyframes scaleIn {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .table-card:hover {
      transform: translateY(-4px) scale(1.02);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.12);
    }

    .table-card:active {
      transform: translateY(-2px) scale(1.01);
    }

    .card-icon {
      width: 40px;
      height: 40px;
      background: var(--primary-blue);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      margin-bottom: var(--space-2);
      transition: transform 200ms var(--ease-out);
      flex-shrink: 0;
    }

    .table-card:hover .card-icon {
      transform: scale(1.1) rotate(5deg);
    }

    .card-icon i {
      width: 20px;
      height: 20px;
    }

    .table-card h3 {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: var(--space-1);
      flex: 1;
    }

    .row-count {
      font-size: 13px;
      color: var(--text-secondary);
      flex-shrink: 0;
    }

    /* Users Table */
    .table-container {
      border: 1px solid var(--border-gray);
      border-radius: 12px;
      overflow: hidden;
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      flex: 1;
      overflow: auto;
    }

    .table-container > table {
      display: block;
      overflow: auto;
      flex: 1;
    }

    .table-container thead {
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .data-table thead {
      background: var(--surface-gray);
    }

    .data-table th {
      text-align: left;
      padding: var(--space-4);
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .data-table td {
      padding: var(--space-4);
      border-top: 1px solid var(--border-gray);
      font-size: 14px;
    }

    .data-table tbody tr {
      transition: background-color 150ms var(--ease-out);
    }

    .data-table tbody tr:hover {
      background-color: rgba(0, 83, 226, 0.05);
    }

    .data-table tbody tr:hover .row-edit-btn {
      opacity: 1;
      visibility: visible;
    }

    .row-edit-btn {
      width: 24px;
      height: 24px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: var(--primary-blue);
      border: none;
      border-radius: 4px;
      color: white;
      cursor: pointer;
      opacity: 0;
      visibility: hidden;
      transition: all 150ms var(--ease-out);
      margin-left: var(--space-2);
      vertical-align: middle;
    }

    .row-edit-btn:hover {
      background: #0046c7;
      transform: scale(1.1);
    }

    .row-edit-btn svg {
      width: 12px;
      height: 12px;
      stroke: white;
    }

    .data-table td:first-child {
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    .user-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--primary-blue);
      color: white;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-right: var(--space-3);
      font-weight: 600;
      font-size: 13px;
      vertical-align: middle;
    }

    .status-badge {
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
    }

    .status-badge.active {
      background: rgba(16, 185, 129, 0.1);
      color: var(--success-green);
    }

    /* Database View Containers */
    #tableListView,
    #tableDetailView {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

    /* Breadcrumb Navigation */
    .breadcrumb-nav {
      margin-bottom: var(--space-3);
      flex-shrink: 0;
    }

    .breadcrumb-link {
      display: inline-flex;
      align-items: center;
      gap: var(--space-1);
      padding: var(--space-2) var(--space-3);
      background: transparent;
      border: none;
      color: var(--primary-blue);
      font-size: 14px;
      cursor: pointer;
      border-radius: 6px;
      transition: all 150ms;
    }

    .breadcrumb-link:hover {
      background: var(--surface-gray);
    }

    .breadcrumb-link i {
      width: 16px;
      height: 16px;
    }

    /* Table Actions Bar */
    .table-actions {
      display: flex;
      gap: var(--space-2);
      margin-bottom: var(--space-3);
      flex-wrap: wrap;
      flex-shrink: 0;
      padding: var(--space-3);
      background: var(--surface-gray);
      border-radius: 8px;
      border: 1px solid var(--border-gray);
    }

    /* Table Footer */
    .table-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--space-3) var(--space-4);
      background: var(--surface-gray);
      border-top: 1px solid var(--border-gray);
      flex-shrink: 0;
    }

    .rows-info {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      font-size: 14px;
      color: var(--text-secondary);
    }

    .rows-per-page {
      padding: 6px 12px;
      border: 1px solid var(--border-gray);
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
    }

    .pagination {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      font-size: 14px;
      color: var(--text-secondary);
    }

    /* Table Data Cells */
    .data-table td {
      max-width: 400px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .data-table td.id-column {
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* Override for published apps table - allow full text display */
    #publishedAppsTable td {
      max-width: none;
      overflow: visible;
      text-overflow: initial;
      white-space: normal;
      word-break: break-word;
    }

    /* Fix first column display for published apps table */
    #publishedAppsTable td:first-child {
      display: table-cell;
    }

    /* Make published apps table container adaptive to content height */
    [data-cloud-view="published"] .table-container {
      flex: 0 1 auto;
      min-height: auto;
      height: auto;
    }

    [data-cloud-view="published"] .table-container > table {
      flex: 0 1 auto;
      display: table;
      height: auto;
    }

    /* Make database table scrollable */
    [data-cloud-view="database"] .table-container {
      overflow: auto;
      max-height: calc(100vh - 400px);
    }

    /* Checkbox column */
    .data-table th:first-child,
    .data-table td:first-child {
      width: 40px;
      padding-left: var(--space-3);
    }

    .data-table input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    /* Edit Row Modal */
    .edit-row-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 250ms var(--ease-out);
    }

    .edit-row-modal.show {
      opacity: 1;
      pointer-events: auto;
    }

    .edit-modal-content {
      background: white;
      border-radius: 12px;
      padding: var(--space-6);
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      transform: scale(0.9) translateY(-20px);
      transition: transform 300ms var(--ease-back);
    }

    .edit-row-modal.show .edit-modal-content {
      transform: scale(1) translateY(0);
    }

    .share-option-card {
      padding: var(--space-4);
      border: 1px solid var(--border-gray);
      border-radius: 12px;
      background: white;
      transition: all 0.2s ease;
    }

    .share-option-card:hover {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      transform: translateY(-2px);
    }

    .edit-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-5);
    }

    .edit-modal-header h3 {
      font-size: 20px;
      font-weight: 600;
    }

    .modal-close {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-secondary);
      transition: all 150ms;
    }

    .modal-close:hover {
      background: var(--surface-gray);
    }

    .edit-form {
      display: flex;
      flex-direction: column;
      gap: var(--space-4);
    }

    .form-field {
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
    }

    .form-field label {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .form-field input,
    .form-field textarea {
      padding: 10px 12px;
      border: 1px solid var(--border-gray);
      border-radius: 6px;
      font-size: 14px;
      font-family: inherit;
      transition: border-color 150ms;
    }

    .form-field input:focus,
    .form-field textarea:focus {
      outline: none;
      border-color: var(--primary-blue);
    }

    .form-field textarea {
      resize: vertical;
      min-height: 80px;
    }

    .form-field input.id-field {
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 12px;
      background: var(--surface-gray);
      color: var(--text-secondary);
    }

    .modal-actions {
      display: flex;
      gap: var(--space-2);
      justify-content: flex-end;
      margin-top: var(--space-5);
    }

    .modal-actions .btn-secondary {
      color: var(--text-secondary);
    }

    /* Cloud View */
    .cloud-view {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

    /* Code View */
    .code-view {
      display: grid;
      grid-template-columns: 280px 1fr;
      height: 100%;
    }

    .file-tree {
      background: var(--sidebar-dark);
      color: white;
      overflow-y: auto;
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      padding: var(--space-4);
    }

    .file-tree h3 {
      font-size: 12px;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.5);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: var(--space-3);
    }

    .file-item {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      padding: var(--space-2) var(--space-3);
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
      margin-bottom: 2px;
      transition: background 150ms;
    }

    .file-item:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    .file-item.active {
      background: var(--primary-blue);
    }

    .file-item i {
      width: 16px;
      height: 16px;
    }

    .code-editor {
      background: white;
      display: flex;
      flex-direction: column;
    }

    .editor-toolbar {
      padding: var(--space-3);
      border-bottom: 1px solid var(--border-gray);
      display: flex;
      gap: var(--space-2);
      background: var(--surface-gray);
    }

    .btn-icon {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: white;
      border: 1px solid var(--border-gray);
      border-radius: 6px;
      cursor: pointer;
      transition: all 150ms;
      flex-shrink: 0;
    }

    .btn-icon:hover:not(:disabled) {
      background: var(--surface-gray);
      transform: translateY(-1px);
    }

    .btn-icon:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-icon i {
      width: 16px;
      height: 16px;
    }

    .code-content {
      flex: 1;
      overflow: auto;
      padding: var(--space-4);
      font-family: 'Monaco', 'Menlo', 'Consolas', 'Courier New', monospace;
      font-size: 13px;
      white-space: pre;
      word-wrap: normal;
    }
    
    .code-content[contenteditable="true"] {
      outline: 2px solid var(--primary-blue);
      outline-offset: -2px;
      background: #fafafa;
      line-height: 1.6;
      color: var(--text-primary);
      cursor: text;
    }
    
    .btn-icon {
      transition: all 0.2s ease;
    }
    
    .btn-icon:hover {
      background: var(--surface-gray);
      transform: scale(1.05);
    }
    
    .btn-icon:active {
      transform: scale(0.95);
    }
    
    #saveCodeBtn {
      color: var(--success-green);
    }
    
    #revertCodeBtn {
      color: var(--error-red);
    }
    
    #editCodeBtn {
      color: var(--primary-blue);
    }

    /* Element Selector Styles */
    .btn-icon.element-selector-active {
      background: var(--primary-blue);
      border-color: var(--primary-blue);
      color: white;
    }
    
    .btn-icon.element-selector-active:hover:not(:disabled) {
      background: var(--bentonville-blue);
      border-color: var(--bentonville-blue);
    }
    
    .btn-icon.element-selector-active i {
      color: white;
    }
    
    .selected-element-chip {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      padding: var(--space-2) var(--space-3);
      background: linear-gradient(135deg, rgba(0, 83, 226, 0.1), rgba(77, 189, 245, 0.1));
      border: 1px solid var(--primary-blue);
      border-radius: 8px;
      font-size: 12px;
      color: var(--primary-blue);
      max-width: 100%;
      animation: chip-appear 0.2s ease-out;
    }
    
    @keyframes chip-appear {
      from {
        opacity: 0;
        transform: translateY(-4px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .selected-element-chip i {
      width: 14px;
      height: 14px;
      flex-shrink: 0;
    }
    
    .selected-element-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
      flex: 1;
    }
    
    .selected-element-tag {
      font-weight: 600;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 11px;
    }
    
    .selected-element-details {
      font-size: 11px;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .selected-element-remove {
      background: transparent;
      border: none;
      cursor: pointer;
      color: var(--primary-blue);
      padding: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 150ms;
      flex-shrink: 0;
    }
    
    .selected-element-remove:hover {
      background: rgba(0, 83, 226, 0.2);
    }
    
    .selected-element-remove i {
      width: 12px;
      height: 12px;
    }
    
    .element-selector-hint {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      padding: var(--space-2) var(--space-3);
      background: rgba(255, 194, 32, 0.15);
      border: 1px dashed var(--spark-yellow);
      border-radius: 8px;
      font-size: 12px;
      color: var(--text-primary);
      animation: pulse-hint 2s ease-in-out infinite;
    }
    
    @keyframes pulse-hint {
      0%, 100% {
        border-color: var(--spark-yellow);
      }
      50% {
        border-color: var(--primary-blue);
      }
    }
    
    .element-selector-hint i {
      width: 14px;
      height: 14px;
      color: var(--spark-yellow);
    }

    /* Preview View */
    .preview-view {
      display: flex;
      flex-direction: column;
      height: 100%;
      background: #f0f0f0;
    }

    .preview-toolbar {
      background: white;
      padding: var(--space-3) var(--space-4);
      border-bottom: 1px solid var(--border-gray);
      display: flex;
      align-items: center;
      gap: var(--space-3);
    }

    .preview-url {
      flex: 1;
      max-width: 600px;
      display: flex;
      align-items: center;
      gap: var(--space-2);
      background: var(--surface-gray);
      padding: var(--space-2) var(--space-3);
      border-radius: 6px;
    }

    .preview-url i {
      width: 16px;
      height: 16px;
      color: var(--text-secondary);
    }

    .preview-url span {
      font-size: 14px;
      color: var(--text-primary);
    }

    .preview-controls {
      display: flex;
      gap: var(--space-2);
    }

    .preview-container {
      flex: 1;
      position: relative;
      padding: var(--space-4);
      overflow: auto;
    }

    .preview-frame {
      width: 100%;
      height: 100%;
      min-height: 600px;
      border: 1px solid var(--border-gray);
      border-radius: 8px;
      background: white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      opacity: 0;
      transition: opacity 300ms ease-in;
    }

    .preview-frame.loaded {
      opacity: 1;
    }

    .preview-loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 10;
      opacity: 1;
      transition: opacity 200ms;
    }

    .preview-loading.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .preview-loading i {
      width: 48px;
      height: 48px;
      color: var(--primary-blue);
      margin-bottom: var(--space-3);
    }

    .preview-loading p {
      color: var(--text-secondary);
      font-size: 14px;
    }

    /* Empty States */
    .empty-state {
      text-align: center;
      padding: var(--space-6) var(--space-4);
      color: var(--text-secondary);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 200px;
    }

    .empty-state i {
      width: 48px;
      height: 48px;
      margin-bottom: var(--space-3);
      opacity: 0.3;
    }

    .empty-state h3 {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: var(--space-2);
      color: var(--text-primary);
    }

    .empty-state p {
      font-size: 13px;
      margin-bottom: 0;
    }

    /* Animations */
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    @keyframes spinner-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    [data-lucide="loader-2"] {
      animation: spin 1s linear infinite;
    }

    /* Lucide Icons */
    svg[data-lucide] {
      width: 1em;
      height: 1em;
      display: inline-block;
      vertical-align: middle;
      stroke-width: 2;
    }

    /* Focus States */
    button:focus-visible, input:focus-visible, select:focus-visible, textarea:focus-visible {
      outline: 3px solid var(--spark-yellow);
      outline-offset: 2px;
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .left-chat-panel {
        width: 360px;
      }
      
      .right-content-panel {
        margin-left: 360px;
      }
    }

    @media (max-width: 768px) {
      .left-chat-panel {
        width: 100%;
        transform: translateX(-100%);
        transition: transform 300ms var(--ease-out);
        z-index: 200;
      }
      
      .left-chat-panel.mobile-open {
        transform: translateX(0);
      }
      
      .right-content-panel {
        margin-left: 0;
      }
      
      .code-view {
        grid-template-columns: 1fr;
      }
      
      .file-tree {
        display: none;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    /* ===== INLINE DIFF VIEWER (CURSOR-STYLE) ===== */
    .diff-message {
      background: white !important;
      border: 1px solid var(--border-gray);
      border-radius: 12px;
      padding: 0 !important;
      max-width: 100% !important; /* Full width for diff viewer */
    }

    .diff-inline-container {
      width: 100%;
    }

    .diff-inline-header {
      padding: 12px 16px;
      background: var(--surface-gray);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid var(--border-gray);
      user-select: none;
      transition: background 0.15s;
    }

    .diff-inline-header:hover {
      background: #e8eaed;
    }

    .diff-inline-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      color: var(--text-primary);
    }

    .diff-inline-title i {
      color: var(--primary-blue);
    }

    .diff-failed-badge {
      background: var(--warning-orange);
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      margin-left: 8px;
    }

    .diff-inline-preview {
      padding: 12px 16px;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 13px;
      line-height: 1.8;
      color: var(--text-secondary);
      white-space: pre-wrap;
      background: #fafafa;
      border-bottom: 1px solid var(--border-gray);
    }

    .diff-inline-details {
      padding: 16px;
      background: white;
    }

    .diff-change-item {
      margin-bottom: 16px;
      border: 1px solid var(--border-gray);
      border-radius: 8px;
      overflow: hidden;
    }

    .diff-change-item:last-child {
      margin-bottom: 0;
    }

    .diff-change-header {
      background: var(--surface-gray);
      padding: 8px 12px;
      font-size: 13px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
      color: var(--text-primary);
    }

    .diff-code-block {
      padding: 12px;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 12px;
      line-height: 1.6;
      overflow-x: auto;
    }

    .diff-code-block.diff-removed {
      background: #fff5f5;
      border-left: 3px solid var(--error-red);
    }

    .diff-code-block.diff-added {
      background: #f0fdf4;
      border-left: 3px solid var(--success-green);
    }

    .diff-code-label {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .diff-code-block.diff-removed .diff-code-label {
      color: var(--error-red);
    }

    .diff-code-block.diff-added .diff-code-label {
      color: var(--success-green);
    }

    .diff-code-block pre {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      color: var(--text-primary);
    }

    .diff-failed-inline {
      background: #fffbeb;
      border: 1px solid var(--warning-orange);
      border-radius: 8px;
      padding: 12px;
      margin-top: 12px;
    }

    .diff-failed-inline-header {
      font-weight: 600;
      color: var(--warning-orange);
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
    }

    .diff-failed-inline-item {
      background: white;
      padding: 10px;
      border-radius: 6px;
      margin-top: 6px;
      font-size: 13px;
      border: 1px solid rgba(245, 158, 11, 0.2);
    }

    .diff-chevron {
      transition: transform 0.2s ease;
      color: var(--text-secondary);
    }
    
    /* ===== MINIMAL MODE ===== */
    .minimal-mode-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000000;
      z-index: 10000;
      display: none;
      animation: fadeIn 0.3s ease;
    }
    
    .minimal-mode-overlay.active {
      display: block;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .minimal-preview-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    
    .minimal-preview-frame {
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 0;
      background: white;
      box-shadow: none;
    }
    
    .minimal-chat-bar {
      position: absolute;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 800px;
      min-width: 400px;
      background: rgba(255, 255, 255, 0.98);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      padding: 12px 16px 12px 60px;
      display: flex;
      align-items: center;
      gap: 12px;
      transition: box-shadow 0.3s ease;
      overflow: visible;
      z-index: 1000;
    }
    
    .minimal-chat-bar:hover {
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 2px rgba(0, 83, 226, 0.3);
    }
    
    .minimal-chat-bar.dragging {
      transition: none;
      cursor: grabbing;
    }
    
    .minimal-chat-bar-handle {
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: grab;
      opacity: 0.4;
      transition: opacity 0.2s ease;
    }
    
    .minimal-chat-bar-handle:hover {
      opacity: 0.8;
    }
    
    .minimal-chat-bar-handle:active {
      cursor: grabbing;
    }
    
    .minimal-chat-bar-handle i {
      width: 16px;
      height: 16px;
      color: var(--gray-text);
    }
    
    .minimal-chat-bar-reset-btn {
      position: absolute;
      left: 32px;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0.6;
      transition: opacity 0.2s ease;
      background: transparent;
      border: none;
      padding: 0;
      color: var(--primary-blue);
    }
    
    .minimal-chat-bar:hover .minimal-chat-bar-reset-btn {
      opacity: 0.8;
    }
    
    .minimal-chat-bar-reset-btn:hover {
      opacity: 1 !important;
    }
    
    .minimal-chat-bar-reset-btn i {
      width: 14px;
      height: 14px;
    }
    
    /* Minimal Element Selector Button */
    .minimal-element-selector-btn {
      background: rgba(255, 255, 255, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.95);
      color: rgba(26, 26, 26, 0.9);
      padding: 8px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      margin-left: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .minimal-element-selector-btn:hover {
      background: rgba(255, 255, 255, 0.95) !important;
      color: #1a1a1a !important;
      border-color: white !important;
      box-shadow: 0 4px 16px rgba(255, 255, 255, 0.5) !important;
      transform: translateY(-2px) scale(1.1);
    }
    
    .minimal-element-selector-btn.active {
      background: var(--primary-blue);
      color: white;
      border-color: var(--primary-blue);
      box-shadow: 0 0 0 3px rgba(0, 83, 226, 0.2), 0 4px 12px rgba(0, 83, 226, 0.3);
    }
    
    .minimal-element-selector-btn i {
      width: 16px;
      height: 16px;
      stroke: currentColor;
      stroke-width: 2;
      fill: none;
      display: block;
      transition: all 0.2s ease;
    }
    
    .minimal-element-selector-btn:hover i {
      stroke-width: 2.5 !important;
      transform: scale(1.2);
    }
    
    .minimal-element-selector-btn svg {
      width: 16px !important;
      height: 16px !important;
      stroke: currentColor !important;
      stroke-width: 2 !important;
      fill: none !important;
      display: block !important;
      transition: all 0.2s ease !important;
    }
    
    .minimal-element-selector-btn:hover svg {
      stroke-width: 2.5 !important;
      transform: scale(1.2);
      stroke: #1a1a1a !important;
    }
    
    .minimal-element-selector-btn.element-selected::after {
      content: '';
      position: absolute;
      top: -4px;
      right: -4px;
      width: 12px;
      height: 12px;
      background: #10b981;
      border: 2px solid rgba(255, 255, 255, 0.95);
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .minimal-chat-bar-resize-handle {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 12px;
      cursor: ew-resize;
      background: transparent;
      transition: background 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .minimal-chat-bar-resize-handle::after {
      content: '';
      width: 3px;
      height: 24px;
      background: var(--border-gray);
      border-radius: 2px;
      opacity: 0.3;
      transition: all 0.2s ease;
    }
    
    .minimal-chat-bar-resize-handle:hover::after {
      opacity: 0.8;
      background: var(--primary-blue);
    }
    
    .minimal-chat-bar.processing {
      background: rgba(0, 83, 226, 0.15);
      border: 2px solid var(--primary-blue);
    }
    
    .minimal-chat-input {
      flex: 1;
      border: none;
      background: transparent;
      font-size: 15px;
      color: var(--text-primary);
      outline: none;
      padding: 8px 12px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      resize: none;
      max-height: 120px;
      line-height: 1.5;
    }
    
    .minimal-chat-input::placeholder {
      color: var(--text-secondary);
    }
    
    .minimal-chat-input:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .minimal-framework-display {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      border-radius: 9999px;
      background: rgba(15, 23, 42, 0.04);
      color: var(--text-secondary);
      font-size: 12px;
      line-height: 1.4;
      flex-shrink: 0;
    }

    .minimal-framework-label {
      white-space: nowrap;
      max-width: 160px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .minimal-framework-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      border-radius: 9999px;
      border: 1px solid var(--border-gray);
      background: white;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .minimal-framework-button:hover {
      border-color: var(--primary-blue);
      color: var(--primary-blue);
      background: #f3f4ff;
    }

    .minimal-framework-button:focus-visible {
      outline: 3px solid var(--spark-yellow);
      outline-offset: 2px;
    }

    .minimal-framework-button i {
      width: 16px;
      height: 16px;
    }
    
    .minimal-send-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: none;
      background: var(--primary-blue);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }
    
    .minimal-send-btn:hover:not(:disabled) {
      background: var(--bentonville-blue);
      transform: scale(1.05);
    }
    
    .minimal-send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .minimal-send-btn i {
      width: 20px;
      height: 20px;
    }
    
    .minimal-exit-btn {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: none;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      z-index: 10001;
      opacity: 0.7;
    }
    
    .minimal-exit-btn:hover {
      background: rgba(0, 0, 0, 0.8);
      opacity: 1;
      transform: scale(1.05);
    }
    
    .minimal-exit-btn i {
      width: 24px;
      height: 24px;
    }
    
    .minimal-status-indicator {
      display: none;
      align-items: center;
      gap: 8px;
      color: var(--primary-blue);
      font-size: 13px;
      font-weight: 500;
      padding: 0 8px;
    }
    
    .minimal-status-indicator.active {
      display: flex;
    }
    
    .minimal-spinner {
      width: 16px;
      height: 16px;
      border: 2px solid rgba(0, 83, 226, 0.2);
      border-top-color: var(--primary-blue);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .minimal-mode-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: transparent;
      border: 1px solid var(--border-gray);
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .minimal-mode-toggle:hover {
      background: var(--surface-gray);
      border-color: var(--primary-blue);
      color: var(--primary-blue);
    }
    
    .minimal-mode-toggle i {
      width: 14px;
      height: 14px;
    }
    
    /* Version Picker Styles */
    .version-nav-btn {
      width: 28px !important;
      height: 28px !important;
      min-width: 28px;
      padding: 0;
      background: white;
      border: 1px solid var(--border-gray);
    }
    
    .version-nav-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    
    .version-nav-btn:not(:disabled):hover {
      background: var(--primary-blue);
      border-color: var(--primary-blue);
      color: white;
    }
    
    .version-nav-btn i {
      width: 16px;
      height: 16px;
    }
    
    .version-dropdown {
      background: white;
      border: 1px solid var(--border-gray);
      color: var(--text-primary);
      padding: 5px 8px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      min-width: 160px;
      max-width: 200px;
      transition: all 0.2s ease;
      outline: none;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M3 5L6 8L9 5' stroke='%236B7280' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 6px center;
      padding-right: 24px;
    }
    
    .version-dropdown:hover {
      border-color: var(--primary-blue);
    }
    
    .version-dropdown:focus {
      border-color: var(--primary-blue);
      box-shadow: 0 0 0 3px rgba(0, 83, 226, 0.1);
    }
    
    .version-dropdown option {
      padding: 8px;
    }
    
    .minimal-processing-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      backdrop-filter: blur(10px);
      padding: 24px 32px;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      z-index: 10002;
    }
    
    .minimal-processing-overlay.active {
      display: flex;
      animation: slideUp 0.3s ease;
    }
    
    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translate(-50%, -40%);
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%);
      }
    }
    
    .minimal-processing-spinner {
      width: 48px;
      height: 48px;
      border: 4px solid rgba(0, 83, 226, 0.2);
      border-top-color: var(--primary-blue);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    .minimal-processing-text {
      font-size: 15px;
      font-weight: 500;
      color: var(--text-primary);
    }
    
    .minimal-update-nudge {
      position: absolute;
      top: 16px;
      right: 70px;
      background: #1e1e1e;
      border-radius: 8px;
      padding: 0;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.1);
      max-width: 380px;
      max-height: 400px;
      z-index: 10003;
      opacity: 0;
      transform: translateX(20px);
      transition: all 0.3s ease;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      border-left: 3px solid var(--primary-blue);
    }
    
    .minimal-update-nudge.active {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
    }
    
    .minimal-update-nudge-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      font-family: 'SF Mono', 'Monaco', 'Consolas', 'Courier New', monospace;
      font-size: 12px;
      font-weight: 400;
      color: #6a9955;
      font-style: italic;
      background: #2d2d2d;
      border-bottom: 1px solid #333333;
      flex-shrink: 0;
    }
    
    .minimal-update-nudge-header i {
      width: 14px;
      height: 14px;
      color: #6a9955;
    }
    
    .minimal-update-nudge-header i.spinning {
      animation: spin 2s linear infinite;
    }
    
    .minimal-update-nudge.minimized {
      opacity: 0;
      transform: translateX(20px);
      pointer-events: none;
    }
    
    .minimal-nudge-restore-btn {
      position: absolute;
      top: 16px;
      right: 70px;
      width: 40px;
      height: 40px;
      background: #1e1e1e;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10002;
      opacity: 0;
      transform: translateX(20px);
      transition: all 0.3s ease;
      pointer-events: none;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
    }
    
    .minimal-nudge-restore-btn.active {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
    }
    
    .minimal-nudge-restore-btn:hover {
      background: #2d2d2d;
      border-color: var(--primary-blue);
    }
    
    .minimal-nudge-restore-btn i {
      width: 18px;
      height: 18px;
      color: var(--primary-blue);
    }
    
    .minimal-update-nudge-controls {
      display: flex;
      gap: 4px;
      margin-left: auto;
    }
    
    .minimal-nudge-control-btn {
      width: 20px;
      height: 20px;
      background: transparent;
      border: none;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.15s ease;
      padding: 0;
    }
    
    .minimal-nudge-control-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    .minimal-nudge-control-btn i {
      width: 12px;
      height: 12px;
      color: #888;
    }
    
    .minimal-nudge-control-btn:hover i {
      color: #fff;
    }
    
    .minimal-update-nudge-header {
      cursor: move;
      user-select: none;
    }
    
    .minimal-update-nudge.dragging {
      transition: none;
    }
    
    .minimal-update-list {
      list-style: none;
      padding: 14px;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 6px;
      overflow-y: auto;
      overflow-x: hidden;
      flex: 1;
      min-height: 0;
      background: #1e1e1e;
    }
    
    .minimal-update-list::-webkit-scrollbar {
      width: 8px;
    }
    
    .minimal-update-list::-webkit-scrollbar-track {
      background: #2d2d2d;
    }
    
    .minimal-update-list::-webkit-scrollbar-thumb {
      background: #555555;
      border-radius: 0;
    }
    
    .minimal-update-list::-webkit-scrollbar-thumb:hover {
      background: #666666;
    }
    
    .minimal-update-item {
      font-family: 'SF Mono', 'Monaco', 'Consolas', 'Courier New', monospace;
      font-size: 12px;
      color: #d4d4d4;
      display: flex;
      align-items: flex-start;
      gap: 8px;
      line-height: 1.6;
      padding: 4px 0;
    }
    
    .minimal-update-item::before {
      content: '';
      color: #4EC9B0;
      font-weight: bold;
      flex-shrink: 0;
      opacity: 0.8;
    }
    
    .minimal-update-complete {
      padding: 10px 14px;
      border-top: 1px solid #333333;
      font-family: 'SF Mono', 'Monaco', 'Consolas', 'Courier New', monospace;
      font-size: 12px;
      font-weight: 400;
      color: #4EC9B0;
      display: flex;
      align-items: center;
      gap: 6px;
      background: #2d2d2d;
      flex-shrink: 0;
    }
    
    .minimal-update-complete i {
      width: 14px;
      height: 14px;
      color: #4EC9B0;
    }
    
    /* ===== TOAST NOTIFICATIONS ===== */
    .toast-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      padding: 16px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 10000;
      min-width: 300px;
      max-width: 500px;
      opacity: 0;
      transform: translateY(-20px);
      animation: toastSlideIn 0.3s var(--ease-out) forwards;
    }
    
    .toast-notification.toast-success {
      border-left: 4px solid var(--success-green);
    }
    
    .toast-notification.toast-info {
      border-left: 4px solid var(--primary-blue);
    }
    
    .toast-notification.toast-warning {
      border-left: 4px solid var(--warning-orange);
    }
    
    .toast-notification.toast-error {
      border-left: 4px solid var(--error-red);
    }
    
    .toast-notification.toast-hiding {
      animation: toastSlideOut 0.3s var(--ease-in) forwards;
    }
    
    .toast-icon {
      flex-shrink: 0;
      width: 20px;
      height: 20px;
    }
    
    .toast-success .toast-icon {
      color: var(--success-green);
    }
    
    .toast-info .toast-icon {
      color: var(--primary-blue);
    }
    
    .toast-warning .toast-icon {
      color: var(--warning-orange);
    }
    
    .toast-error .toast-icon {
      color: var(--error-red);
    }
    
    .toast-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .toast-title {
      font-weight: 600;
      font-size: 14px;
      color: var(--text-primary);
    }
    
    .toast-message {
      font-size: 13px;
      color: var(--text-secondary);
      line-height: 1.4;
    }
    
    .toast-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }
    
    .toast-close:hover {
      background: rgba(0, 0, 0, 0.05);
    }
    
    .toast-close i {
      width: 16px;
      height: 16px;
    }
    
    @keyframes toastSlideIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes toastSlideOut {
      from {
        opacity: 1;
        transform: translateY(0);
      }
      to {
        opacity: 0;
        transform: translateY(-20px);
      }
    }

    /* ===== STOP BUTTON ENHANCEMENTS ===== */
    #stopGenerationBtn {
      display: none;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: #EF4444;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 150ms;
      margin-left: 8px;
      box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
      animation: pulse-stop 2s ease-in-out infinite;
      position: relative;
    }
    
    #stopGenerationBtn:hover {
      background: #DC2626;
      box-shadow: 0 4px 8px rgba(239, 68, 68, 0.4);
      transform: translateY(-1px);
    }
    
    #stopGenerationBtn:active {
      transform: translateY(0);
    }
    
    @keyframes pulse-stop {
      0%, 100% {
        box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
      }
      50% {
        box-shadow: 0 4px 12px rgba(239, 68, 68, 0.6);
      }
    }
    
    #stopGenerationBtn i {
      width: 16px;
      height: 16px;
    }
  </style>
</head>
<body>
  <!-- LEFT: AI CHAT PANEL (Always Visible) -->
  <aside class="left-chat-panel">
    <div class="chat-header">
      <div style="margin-bottom: var(--space-3);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <h2 style="margin: 0;"><i data-lucide="bot"></i> AI Assistant</h2>
          <button class="minimal-mode-toggle" onclick="toggleMinimalMode()" title="Enter minimal mode - Focus on your app">
            <i data-lucide="maximize-2"></i>
            <span>Minimal</span>
          </button>
        </div>
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <p class="chat-subtitle" style="margin: 0;">Ask me to build anything!</p>
          <div id="versionInfo" style="display: none; align-items: center; gap: 6px; padding: 4px; background: var(--surface-gray); border-radius: 8px; font-size: 13px;">
            <button onclick="loadPreviousDBVersion()" class="btn-icon version-nav-btn" title="Previous version">
              <i data-lucide="chevron-left"></i>
            </button>
            <select id="versionSelector" onchange="loadSelectedVersion(this.value)" class="version-dropdown">
              <option value="">Select version...</option>
            </select>
            <button onclick="loadNextDBVersion()" class="btn-icon version-nav-btn" title="Next version">
              <i data-lucide="chevron-right"></i>
            </button>
            <button onclick="deleteCurrentVersion()" class="btn-icon version-nav-btn" id="btnDeleteVersion" title="Delete this version" style="color: #dc3545;">
              <i data-lucide="trash-2"></i>
            </button>
          </div>
        </div>
      </div>
      
      <div style="margin-top: var(--space-3); display: flex; gap: var(--space-1); background: var(--surface-gray); padding: 4px; border-radius: 8px;">
        <button class="mode-tab active" data-mode="agent" onclick="switchMode('agent')" title="Agent mode - Auto includes current HTML">
          <i data-lucide="zap"></i>
          <span>Agent</span>
        </button>
        <button class="mode-tab" data-mode="plan" onclick="switchMode('plan')" title="Plan mode - Multi-step planning">
          <i data-lucide="list-checks"></i>
          <span>Plan</span>
        </button>
        <button class="mode-tab" data-mode="chat" onclick="switchMode('chat')" title="Chat mode - Simple conversation">
          <i data-lucide="message-circle"></i>
          <span>Chat</span>
        </button>
      </div>
    </div>
    
    <div class="chat-messages" id="chatMessages">
      <div class="chat-message assistant">
        <span>Ready to build. Ask me to create any web application.</span>
      </div>
    </div>
    
    <div class="chat-input-area" id="chatInputArea">
      <!-- Drag and Drop Overlay -->
      <div class="drag-drop-overlay" id="dragDropOverlay">
        <div class="drag-drop-content">
          <i data-lucide="images"></i>
          <div class="drag-drop-text">Drop images here</div>
          <div class="drag-drop-hint">PNG, JPG, GIF, WebP, SVG  Multiple files supported  Max 5MB each</div>
        </div>
      </div>
      
      <div class="chat-input-wrapper">
        <button class="chat-library-btn" onclick="openDesignFrameworkModal()" title="Select Design Framework">
          <i data-lucide="library"></i>
        </button>
        <button class="chat-library-btn" onclick="triggerImageUpload()" title="Upload Reference Images">
          <i data-lucide="image-plus"></i>
        </button>
        <button class="chat-library-btn" onclick="triggerCSVUpload()" title="Upload CSV for Schema">
          <i data-lucide="table"></i>
        </button>
        <input type="file" id="imageUploadInput" accept="image/png,image/jpeg,image/jpg,image/gif,image/webp,image/svg+xml" multiple style="display: none;" onchange="handleImageUpload(event)">
        <input type="file" id="csvUploadInput" accept=".csv,text/csv" style="display: none;" onchange="handleCSVUpload(event)">
        <textarea id="chatInput" placeholder="Ask me to build something..." rows="1"></textarea>
        <button class="chat-send" onclick="sendMessage()" id="chatSendBtn">
          <i data-lucide="send"></i>
        </button>
        <button id="stopGenerationBtn" onclick="stopGeneration('User clicked stop')" style="display: none;">
          <i data-lucide="square"></i>
          <span>Stop</span>
        </button>
      </div>
      
      <div class="chat-actions">
        <button id="btnUndo" disabled onclick="undoLastAction()">
          <i data-lucide="undo-2"></i>
          <span>Undo</span>
        </button>
        <button id="btnStop" disabled onclick="stopExecution()">
          <i data-lucide="square"></i>
          <span>Stop</span>
        </button>
      </div>
      
      <div style="display: flex; gap: var(--space-2); flex-wrap: wrap;">
        <div class="chat-selected-framework" id="selectedFrameworkDisplay" style="display: none;">
          <i data-lucide="check-circle"></i>
          <span id="selectedFrameworkLabel">None</span>
        </div>
        
        <div class="chat-selected-framework" id="referenceImageDisplay" style="display: none; background: rgba(0, 83, 226, 0.1); color: var(--primary-blue);">
          <i data-lucide="image"></i>
          <span id="referenceImageLabel">Reference image attached</span>
          <button onclick="removeReferenceImage()" style="background: transparent; border: none; cursor: pointer; color: var(--primary-blue); padding: 0; margin-left: var(--space-1);" title="Remove image">
            <i data-lucide="x" style="width: 14px; height: 14px;"></i>
          </button>
        </div>
        
        <!-- Element Selector Hint -->
        <div class="element-selector-hint" id="elementSelectorHint" style="display: none;">
          <i data-lucide="mouse-pointer-click"></i>
          <span>Click on any element in the preview to select it</span>
        </div>
        
        <!-- Selected Element Display -->
        <div class="selected-element-chip" id="selectedElementDisplay" style="display: none;">
          <i data-lucide="box-select"></i>
          <div class="selected-element-info">
            <span class="selected-element-tag" id="selectedElementTag">&lt;div&gt;</span>
            <span class="selected-element-details" id="selectedElementDetails">No element selected</span>
          </div>
          <button class="selected-element-remove" onclick="clearSelectedElement()" title="Remove selected element">
            <i data-lucide="x"></i>
          </button>
        </div>
      </div>
    </div>
  </aside>

  <!-- RIGHT: CONTENT PANEL -->
  <div class="right-content-panel">
    <!-- Top Navigation Bar -->
    <nav class="top-nav-bar">
      <div class="project-info">
        <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 4px;">
          <select id="projectSelector" onchange="selectProject(this.value)" style="background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); color: white; padding: 6px 12px; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; flex: 1; min-width: 200px;">
            <option value="">No Project Selected</option>
          </select>
          <button onclick="deleteCurrentProject()" id="btnDeleteProject" style="display: flex; align-items: center; gap: 6px; padding: 6px 12px; background: rgba(220, 53, 69, 0.2); border: 1px solid #dc3545; color: #ff6b7a; font-size: 13px; font-weight: 600; border-radius: 6px; cursor: pointer; white-space: nowrap;" title="Delete Current Project">
            <i data-lucide="trash-2" style="width: 16px; height: 16px;"></i>
            <span>Delete</span>
          </button>
          <button onclick="startNewProject()" style="display: flex; align-items: center; gap: 6px; padding: 6px 12px; background: var(--spark-yellow); border: 1px solid var(--spark-yellow); color: var(--bentonville-blue); font-size: 13px; font-weight: 600; border-radius: 6px; cursor: pointer; white-space: nowrap;" title="Create New Project">
            <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
            <span>New Project</span>
          </button>
        </div>
        <div style="display: flex; align-items: center; gap: var(--space-3);">
          <div id="publishStatusIndicator" class="publish-status-indicator" style="display: none;">
            <div class="status-dot"></div>
            <span class="status-text">Published</span>
          </div>
          <div class="project-status">Last saved: Never</div>
        </div>
      </div>
      
      <div class="nav-tabs">
        <button class="nav-tab" data-tab="cloud" onclick="switchMainTab('cloud')">
          <i data-lucide="cloud"></i>
          <span>Cloud</span>
        </button>
        <button class="nav-tab" data-tab="code" onclick="switchMainTab('code')">
          <i data-lucide="code"></i>
          <span>Code</span>
        </button>
        <button class="nav-tab active" data-tab="preview" onclick="switchMainTab('preview')">
          <i data-lucide="eye"></i>
          <span>Preview</span>
        </button>
      </div>
      
      <div class="top-nav-actions">
        <button class="btn-top-action" onclick="showShareModal()">
          <i data-lucide="download"></i>
          <span>Export</span>
        </button>
        <button class="btn-top-action primary" onclick="publishProject()">
          <i data-lucide="share-2"></i>
          <span>Get Link</span>
        </button>
      </div>
    </nav>

    <!-- CLOUD VIEW -->
    <div class="cloud-view" id="cloudView" style="display: none;">
      <!-- Secondary Navigation for Cloud -->
      <nav class="secondary-nav">
        <button class="secondary-nav-item" data-cloud-nav="overview" onclick="switchCloudNav('overview')">
          <i data-lucide="layout-grid"></i>
          <span>Overview</span>
        </button>
        <button class="secondary-nav-item active" data-cloud-nav="database" onclick="switchCloudNav('database')">
          <i data-lucide="database"></i>
          <span>Database</span>
        </button>
        <button class="secondary-nav-item" data-cloud-nav="users" onclick="switchCloudNav('users')">
          <i data-lucide="users"></i>
          <span>Users</span>
        </button>
        <button class="secondary-nav-item" data-cloud-nav="functions" onclick="switchCloudNav('functions')">
          <i data-lucide="zap"></i>
          <span>Edge Functions</span>
        </button>
        <button class="secondary-nav-item" data-cloud-nav="published" onclick="switchCloudNav('published')" style="display: none;">
          <i data-lucide="upload-cloud"></i>
          <span>Published Apps</span>
        </button>
      </nav>
      
      <!-- Cloud Content -->
      <div class="main-content">
        <!-- Overview Content -->
        <div class="content-view" data-cloud-view="overview">
          <div class="page-header">
            <h1><i data-lucide="layout-grid"></i> Overview</h1>
            <p class="subtitle">Manage your app projects and resources</p>
          </div>
          
          <div class="section-header">
            <div>
              <h2>Recent Projects</h2>
              <p class="section-subtitle">Your saved app projects</p>
            </div>
            <button class="btn-primary" onclick="startNewProject()">
              <i data-lucide="plus"></i>
              <span>New Project</span>
            </button>
          </div>
          
          <div class="tables-grid" id="projectsGrid">
            <div class="empty-state">
              <i data-lucide="folder-open"></i>
              <h3>No projects yet</h3>
              <p>Start by asking the AI to build something</p>
            </div>
          </div>
        </div>

        <!-- Database Content -->
        <div class="content-view active" data-cloud-view="database">
          <!-- Table List View -->
          <div id="tableListView">
            <div class="page-header">
              <h1><i data-lucide="database"></i> Database</h1>
              <p class="subtitle" id="databaseSubtitle">View and manage your BigQuery tables</p>
            </div>
            
            <div class="section-header">
              <div>
                <h2>Tables</h2>
                <p class="section-subtitle" id="databaseSectionSubtitle">Dataset: digital_connection</p>
              </div>
              <div style="display: flex; gap: var(--space-2);">
                <button class="btn-primary" onclick="openCreateTableModal()" id="createTableBtn">
                  <i data-lucide="plus"></i>
                  <span>Create Table</span>
                </button>
                <button class="btn-secondary">
                  <i data-lucide="shield"></i>
                  <span>RLS Policies</span>
                </button>
              </div>
            </div>
            
            <div class="tables-grid" id="tablesGrid">
              <div class="table-card">
                <div class="card-icon"><i data-lucide="loader-2"></i></div>
                <h3>Loading...</h3>
              </div>
            </div>
          </div>
          
          <!-- Table Detail View -->
          <div id="tableDetailView" style="display: none;">
            <div class="breadcrumb-nav">
              <button class="breadcrumb-link" onclick="backToTableList()">
                <i data-lucide="chevron-left"></i> Database
              </button>
            </div>
            
            <div class="page-header" style="display: flex; justify-content: space-between; align-items: flex-start;">
              <div>
                <h1 style="margin-bottom: var(--space-1);">Table: <span id="currentTableName"></span></h1>
                <p class="subtitle" id="tableSubtitle">Double-click to edit values inline</p>
              </div>
              <div style="display: flex; gap: var(--space-2);">
                <button class="btn-secondary" onclick="refreshTableData()">
                  <i data-lucide="refresh-cw"></i>
                </button>
                <button class="btn-secondary">
                  <i data-lucide="download"></i>
                </button>
              </div>
            </div>
            
            <div class="table-actions">
              <button class="btn-secondary">
                <i data-lucide="filter"></i>
                <span>Filter</span>
              </button>
              <button class="btn-secondary" onclick="addNewRow()">
                <i data-lucide="plus"></i>
                <span>Add Row</span>
              </button>
              <button class="btn-secondary" onclick="deleteSelectedRows()" id="deleteRowsBtn" style="display: none;">
                <i data-lucide="trash-2"></i>
                <span>Delete Selected</span>
              </button>
              <button class="btn-secondary" onclick="showAddColumnModal()">
                <i data-lucide="columns"></i>
                <span>Columns</span>
              </button>
              <button class="btn-secondary" style="color: var(--error-red); border-color: var(--error-red);" onclick="deleteCurrentTable()">
                <i data-lucide="trash-2"></i>
                <span>Delete Table</span>
              </button>
            </div>
            
            <div class="table-container" id="tableDataContainer">
              <table class="data-table" id="tableDetailData">
                <thead id="tableDetailHead"></thead>
                <tbody id="tableDetailBody"></tbody>
              </table>
            </div>
            
            <div class="table-footer">
              <div class="rows-info">
                Rows per page: 
                <select class="rows-per-page">
                  <option value="25">25</option>
                  <option value="50" selected>50</option>
                  <option value="100">100</option>
                </select>
                <span id="recordsInfo">0 records found</span>
              </div>
              <div class="pagination">
                <span id="pageInfo">Page 1 of 1</span>
                <button class="btn-icon" disabled>
                  <i data-lucide="chevron-left"></i>
                </button>
                <button class="btn-icon" disabled>
                  <i data-lucide="chevron-right"></i>
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Users Content -->
        <div class="content-view" data-cloud-view="users">
          <div class="page-header">
            <h1><i data-lucide="users"></i> Users</h1>
            <p class="subtitle">Manage users and authentication</p>
          </div>
          
          <div class="section-header">
            <div>
              <h2>User Management</h2>
              <p class="section-subtitle">View and manage app users</p>
            </div>
            <button class="btn-primary">
              <i data-lucide="user-plus"></i>
              <span>Add User</span>
            </button>
          </div>
          
          <div class="table-container">
            <table class="data-table">
              <thead>
                <tr>
                  <th>User</th>
                  <th>Email</th>
                  <th>Role</th>
                  <th>Status</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td colspan="4" style="text-align: center; padding: var(--space-6); color: var(--text-secondary);">
                    No users configured
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <!-- Edge Functions Content -->
        <div class="content-view" data-cloud-view="functions">
          <div class="page-header">
            <h1><i data-lucide="zap"></i> Edge Functions</h1>
            <p class="subtitle">Serverless functions for your app</p>
          </div>
          
          <div class="section-header">
            <div>
              <h2>Functions</h2>
              <p class="section-subtitle">Deploy and manage edge functions</p>
            </div>
            <button class="btn-primary">
              <i data-lucide="plus"></i>
              <span>New Function</span>
            </button>
          </div>
          
          <div class="table-container">
            <table class="data-table">
              <thead>
                <tr>
                  <th>Name</th>
                  <th>Status</th>
                  <th>Invocations</th>
                  <th>Last Updated</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td colspan="4" style="text-align: center; padding: var(--space-6); color: var(--text-secondary);">
                    No functions deployed
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <!-- Published Apps Content -->
        <div class="content-view" data-cloud-view="published" style="max-width: 100%; width: 100%;">
          <div class="page-header">
            <h1><i data-lucide="upload-cloud"></i> Published Apps</h1>
            <p class="subtitle">Manage your published static apps</p>
          </div>
          
          <div class="section-header">
            <div>
              <h2>Published Apps</h2>
              <p class="section-subtitle">Static HTML apps served at /publish/[app-name]</p>
            </div>
            <button class="btn-secondary" onclick="loadPublishedApps()">
              <i data-lucide="refresh-cw"></i>
              <span>Refresh</span>
            </button>
          </div>
          
          <div class="table-container" style="width: 100%; overflow-x: auto;">
            <table class="data-table" id="publishedAppsTable" style="width: 100%; min-width: 800px;">
              <thead>
                <tr>
                  <th style="width: 25%;">App Name</th>
                  <th style="width: 18%;">Published Date</th>
                  <th style="width: 32%;">URL</th>
                  <th style="width: 10%;">Assets</th>
                  <th style="width: 15%;">Actions</th>
                </tr>
              </thead>
              <tbody id="publishedAppsTableBody">
                <tr>
                  <td colspan="5" style="text-align: center; padding: var(--space-6); color: var(--text-secondary);">
                    <i data-lucide="loader-2" style="animation: spin 1s linear infinite;"></i> Loading...
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          
          <!-- Pagination Controls -->
          <div id="publishedAppsPagination" style="display: none; margin-top: var(--space-4); display: flex; justify-content: space-between; align-items: center; padding: var(--space-3); background: var(--surface-gray); border-radius: 8px;">
            <div style="color: var(--text-secondary); font-size: 14px;">
              Showing <span id="paginationStart">1</span>-<span id="paginationEnd">5</span> of <span id="paginationTotal">0</span> apps
            </div>
            <div style="display: flex; gap: var(--space-2);">
              <button class="btn-secondary" id="prevPageBtn" onclick="changePage(-1)" disabled style="padding: 8px 16px; font-size: 13px;">
                <i data-lucide="chevron-left"></i>
                <span>Previous</span>
              </button>
              <button class="btn-secondary" id="nextPageBtn" onclick="changePage(1)" style="padding: 8px 16px; font-size: 13px;">
                <span>Next</span>
                <i data-lucide="chevron-right"></i>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- CODE VIEW -->
    <div class="code-view" id="codeView" style="display: none;">
      <div class="file-tree">
        <h3>Files</h3>
        <div class="file-item active">
          <i data-lucide="file-code"></i>
          <span>index.html</span>
        </div>
      </div>
      
      <div class="code-editor">
        <div class="editor-toolbar">
          <button class="btn-icon" id="editCodeBtn" title="Edit code" onclick="toggleCodeEdit()">
            <i data-lucide="edit"></i>
          </button>
          <button class="btn-icon" id="saveCodeBtn" title="Save changes" onclick="saveCodeChanges()" style="display: none;">
            <i data-lucide="save"></i>
          </button>
          <button class="btn-icon" id="revertCodeBtn" title="Revert changes" onclick="revertCodeChanges()" style="display: none;">
            <i data-lucide="x"></i>
          </button>
          <button class="btn-icon" title="Copy code" onclick="copyCode()">
            <i data-lucide="copy"></i>
          </button>
          <button class="btn-icon" title="Download" onclick="downloadCode()">
            <i data-lucide="download"></i>
          </button>
          <button class="btn-icon" title="Publish" onclick="showPublishModal()">
            <i data-lucide="upload-cloud"></i>
          </button>
          <button class="btn-icon" title="Expand" onclick="expandCode()">
            <i data-lucide="maximize"></i>
          </button>
        </div>
        
        <pre class="code-content" id="codeContent"><code>&lt;!-- Your generated HTML will appear here --&gt;
&lt;!-- Ask the AI to build something! --&gt;</code></pre>
      </div>
    </div>

    <!-- PREVIEW VIEW -->
    <div class="preview-view" id="previewView" style="display: flex; flex-direction: column; flex: 1;">
      <div class="preview-toolbar">
        <div class="preview-url">
          <i data-lucide="globe"></i>
          <span>/</span>
        </div>
        
        <div class="preview-controls">
          <button class="btn-icon" id="elementSelectorBtn" title="Select Element - Click to select elements on the page and send context to chat" onclick="toggleElementSelector()">
            <i data-lucide="mouse-pointer-click"></i>
          </button>
          <button class="btn-icon" title="Refresh preview" onclick="refreshPreview()">
            <i data-lucide="refresh-cw"></i>
          </button>
          <button class="btn-icon" title="Open in new tab" onclick="openInNewTab()">
            <i data-lucide="external-link"></i>
          </button>
          <button class="btn-icon" title="Fullscreen" onclick="toggleFullscreen()">
            <i data-lucide="maximize"></i>
          </button>
        </div>
      </div>
      
      <div class="preview-container">
        <div class="preview-loading" id="previewLoading">
          <i data-lucide="loader-2"></i>
          <p>Loading preview...</p>
        </div>
        <iframe class="preview-frame" id="previewFrame" sandbox="allow-scripts allow-same-origin"></iframe>
      </div>
    </div>
  </div>

  <!-- Edit Row Modal -->
  <div class="edit-row-modal" id="editRowModal">
    <div class="edit-modal-content">
      <div class="edit-modal-header">
        <h3>Edit row</h3>
        <button class="modal-close" onclick="closeEditModal()">
          <i data-lucide="x"></i>
        </button>
      </div>
      
      <form class="edit-form" id="editForm" onsubmit="saveRowEdit(event)">
        <!-- Form fields will be dynamically generated -->
      </form>
      
      <div class="modal-actions">
        <button type="button" class="btn-secondary" onclick="closeEditModal()">Cancel</button>
        <button type="submit" class="btn-primary" form="editForm">Save changes</button>
      </div>
    </div>
  </div>

  <!-- Design Framework Modal -->
  <div class="edit-row-modal" id="designFrameworkModal">
    <div class="edit-modal-content">
      <div class="edit-modal-header">
        <h3>Select Design Framework</h3>
        <button class="modal-close" onclick="closeDesignFrameworkModal()">
          <i data-lucide="x"></i>
        </button>
      </div>
      
      <div style="padding: var(--space-4) 0;">
        <p style="margin-bottom: var(--space-4); color: var(--text-secondary); font-size: 14px;">
          Choose a design framework for the AI to use when generating and editing pages.
        </p>
        
        <div style="display: flex; flex-direction: column; gap: var(--space-3);">
          <!-- None -->
          <label class="framework-option" style="display: flex; align-items: flex-start; gap: var(--space-3); padding: var(--space-4); border: 2px solid var(--border-gray); border-radius: 12px; cursor: pointer; transition: all 150ms;">
            <input type="radio" name="designFramework" value="none" onchange="selectFramework('none')" style="margin-top: 2px; width: 20px; height: 20px; cursor: pointer;">
            <div style="flex: 1;">
              <div style="font-weight: 600; font-size: 16px; margin-bottom: var(--space-2);">None</div>
              <div style="color: var(--text-secondary); font-size: 14px; line-height: 1.5;">
                No specific framework. Use general modern design patterns.
              </div>
            </div>
          </label>
          
          <!-- Living Design (Walmart) -->
          <label class="framework-option" style="display: flex; align-items: flex-start; gap: var(--space-3); padding: var(--space-4); border: 2px solid var(--border-gray); border-radius: 12px; cursor: pointer; transition: all 150ms;">
            <input type="radio" name="designFramework" value="living-design" checked onchange="selectFramework('living-design')" style="margin-top: 2px; width: 20px; height: 20px; cursor: pointer;">
            <div style="flex: 1;">
              <div style="font-weight: 600; font-size: 16px; margin-bottom: var(--space-2);">Living Design 3.5</div>
              <div style="color: var(--text-secondary); font-size: 14px; line-height: 1.5;">
                Walmart's official design system with Spark Yellow, Bentonville Blue, accessible components, and associate-friendly patterns.
              </div>
            </div>
          </label>
          
          <!-- Material Design -->
          <label class="framework-option" style="display: flex; align-items: flex-start; gap: var(--space-3); padding: var(--space-4); border: 2px solid var(--border-gray); border-radius: 12px; cursor: pointer; transition: all 150ms;">
            <input type="radio" name="designFramework" value="material-design" onchange="selectFramework('material-design')" style="margin-top: 2px; width: 20px; height: 20px; cursor: pointer;">
            <div style="flex: 1;">
              <div style="font-weight: 600; font-size: 16px; margin-bottom: var(--space-2);">Material Design</div>
              <div style="color: var(--text-secondary); font-size: 14px; line-height: 1.5;">
                Google's design system with elevation, motion, and bold colors.
              </div>
            </div>
          </label>
          
          <!-- Tailwind/Modern -->
          <label class="framework-option" style="display: flex; align-items: flex-start; gap: var(--space-3); padding: var(--space-4); border: 2px solid var(--border-gray); border-radius: 12px; cursor: pointer; transition: all 150ms;">
            <input type="radio" name="designFramework" value="modern-minimal" onchange="selectFramework('modern-minimal')" style="margin-top: 2px; width: 20px; height: 20px; cursor: pointer;">
            <div style="flex: 1;">
              <div style="font-weight: 600; font-size: 16px; margin-bottom: var(--space-2);">Modern Minimal</div>
              <div style="color: var(--text-secondary); font-size: 14px; line-height: 1.5;">
                Clean, modern design with utility-first approach and subtle styling.
              </div>
            </div>
          </label>
          
          <!-- Bootstrap Style -->
          <label class="framework-option" style="display: flex; align-items: flex-start; gap: var(--space-3); padding: var(--space-4); border: 2px solid var(--border-gray); border-radius: 12px; cursor: pointer; transition: all 150ms;">
            <input type="radio" name="designFramework" value="bootstrap" onchange="selectFramework('bootstrap')" style="margin-top: 2px; width: 20px; height: 20px; cursor: pointer;">
            <div style="flex: 1;">
              <div style="font-weight: 600; font-size: 16px; margin-bottom: var(--space-2);">Bootstrap Style</div>
              <div style="color: var(--text-secondary); font-size: 14px; line-height: 1.5;">
                Classic Bootstrap patterns with cards, badges, and familiar components.
              </div>
            </div>
          </label>
        </div>
      </div>
      
      <div class="modal-actions">
        <button type="button" class="btn-secondary" onclick="closeDesignFrameworkModal()">Close</button>
      </div>
    </div>
  </div>

  <!-- Add Column Modal -->
  <div class="edit-row-modal" id="addColumnModal">
    <div class="edit-modal-content">
      <div class="edit-modal-header">
        <h3>Add Column</h3>
        <button class="modal-close" onclick="closeAddColumnModal()">
          <i data-lucide="x"></i>
        </button>
      </div>
      
      <form class="edit-form" id="addColumnForm" onsubmit="addNewColumn(event)">
        <div class="form-field">
          <label for="newColumnName">Column Name *</label>
          <input 
            type="text"
            id="newColumnName"
            name="column_name"
            placeholder="e.g., priority, status, notes"
            required
            pattern="[a-zA-Z0-9_]+"
            title="Only letters, numbers, and underscores allowed"
          />
          <small style="color: var(--text-secondary); font-size: 12px; margin-top: 4px; display: block;">
            Use lowercase with underscores (e.g., due_date, priority_level)
          </small>
        </div>
        
        <div class="form-field">
          <label for="newColumnType">Data Type *</label>
          <select id="newColumnType" name="column_type" required>
            <option value="">Select a type...</option>
            <option value="STRING">String (text)</option>
            <option value="INT64">Integer (whole numbers)</option>
            <option value="FLOAT64">Float (decimal numbers)</option>
            <option value="BOOL">Boolean (true/false)</option>
            <option value="TIMESTAMP">Timestamp (auto-generated)</option>
            <option value="DATE">Date (YYYY-MM-DD)</option>
            <option value="DATETIME">DateTime</option>
            <option value="JSON">JSON</option>
          </select>
        </div>
        
        <div class="form-field">
          <label for="newColumnDefault">Default Value (optional)</label>
          <input 
            type="text"
            id="newColumnDefault"
            name="default_value"
            placeholder="Leave empty for no default"
          />
          <small style="color: var(--text-secondary); font-size: 12px; margin-top: 4px; display: block;">
            Examples: 0 for numbers, "" for strings, false for boolean
          </small>
        </div>
      </form>
      
      <div class="modal-actions">
        <button type="button" class="btn-secondary" onclick="closeAddColumnModal()">Cancel</button>
        <button type="submit" class="btn-primary" form="addColumnForm">Add Column</button>
      </div>
    </div>
  </div>

  <!-- New Project Modal -->
  <div class="edit-row-modal" id="newProjectModal">
    <div class="edit-modal-content">
      <div class="edit-modal-header">
        <h3>Create New Project</h3>
        <button class="modal-close" onclick="closeNewProjectModal()">
          <i data-lucide="x"></i>
        </button>
      </div>
      
      <form class="edit-form" id="newProjectForm" onsubmit="createNewProject(event)">
        <div class="form-field">
          <label for="newProjectName">Project Name *</label>
          <input 
            type="text" 
            id="newProjectName" 
            name="project_name" 
            placeholder="e.g., Customer Dashboard"
            required
            autofocus
          >
        </div>
        
        <div class="form-field">
          <label for="newProjectDescription">Description (optional)</label>
          <textarea 
            id="newProjectDescription" 
            name="description" 
            placeholder="Brief description of the project..."
            rows="3"
          ></textarea>
        </div>
        
        <div style="padding: var(--space-3); background: var(--surface-gray); border-radius: 8px; margin-top: var(--space-3);">
          <p style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
            <strong>What will be created:</strong><br>
             Unique project ID (e.g., prj_1731532800_a3f2)<br>
             HTML cache table: prj_[id]_html_cache<br>
             Chat history table: prj_[id]_chat_history<br>
             All tables stored in digital_connection dataset<br>
             Tables use project ID prefix for organization
          </p>
        </div>
      </form>
      
      <div class="modal-actions">
        <button type="button" class="btn-secondary" onclick="closeNewProjectModal()">Cancel</button>
        <button type="submit" class="btn-primary" form="newProjectForm">Create Project</button>
      </div>
    </div>
  </div>

  <!-- Create Table Modal -->
  <div class="edit-row-modal" id="createTableModal">
    <div class="edit-modal-content" style="max-width: 700px;">
      <div class="edit-modal-header">
        <h3>Create New Table</h3>
        <button class="modal-close" onclick="closeCreateTableModal()">
          <i data-lucide="x"></i>
        </button>
      </div>
      
      <form class="edit-form" id="createTableForm" onsubmit="createNewTable(event)">
        <div style="padding: var(--space-3); background: rgba(0, 83, 226, 0.05); border-radius: 8px; margin-bottom: var(--space-4); border-left: 3px solid var(--primary-blue);">
          <p style="font-size: 13px; color: var(--text-primary); line-height: 1.5; margin: 0;">
            <strong id="createTableProjectInfo">Project: None selected</strong>
          </p>
        </div>
        
        <div class="form-field">
          <label for="newTableName">Table Name *</label>
          <input 
            type="text" 
            id="newTableName" 
            name="table_name" 
            placeholder="e.g., users, customers, products"
            pattern="[a-zA-Z][a-zA-Z0-9_]*"
            title="Must start with letter, can contain letters, numbers, and underscores"
            oninput="updateTableNamePreview()"
            required
            autofocus
          >
          <small style="color: var(--text-secondary); font-size: 12px; margin-top: 4px; display: block;">
            Letters, numbers, and underscores only. Must start with a letter.
          </small>
        </div>
        
        <div class="form-field">
          <label>Table Schema</label>
          <div id="schemaBuilder" style="display: flex; flex-direction: column; gap: var(--space-2);">
            <!-- Schema rows will be added here -->
          </div>
          <button type="button" class="btn-secondary" onclick="addSchemaColumn()" style="margin-top: var(--space-2);">
            <i data-lucide="plus"></i>
            <span>Add Column</span>
          </button>
        </div>
        
        <div style="padding: var(--space-3); background: var(--surface-gray); border-radius: 8px; margin-top: var(--space-3);">
          <p style="font-size: 13px; color: var(--text-secondary); line-height: 1.5; margin: 0;">
            <strong>Table will be created as:</strong><br>
            <code id="fullTableNamePreview" style="background: white; padding: 4px 8px; border-radius: 4px; font-size: 12px;">digital_connection.[table_name]</code>
          </p>
        </div>
      </form>
      
      <div class="modal-actions">
        <button type="button" class="btn-secondary" onclick="closeCreateTableModal()">Cancel</button>
        <button type="submit" class="btn-primary" form="createTableForm">Create Table</button>
      </div>
    </div>
  </div>

  <!-- Minimal Mode Overlay -->
  <div class="minimal-mode-overlay" id="minimalModeOverlay">
    <!-- Exit Button -->
    <button class="minimal-exit-btn" onclick="exitMinimalMode()" title="Exit minimal mode (Esc)">
      <i data-lucide="x"></i>
    </button>
    
    <!-- Restore Nudge Button (shows when nudge is minimized) -->
    <button class="minimal-nudge-restore-btn" id="minimalNudgeRestoreBtn" onclick="restoreMinimalNudge()" title="Show updates">
      <i data-lucide="bell"></i>
    </button>
    
    <!-- Update Nudge -->
    <div class="minimal-update-nudge" id="minimalUpdateNudge">
      <div class="minimal-update-nudge-header" id="minimalNudgeHeader">
        <i data-lucide="refresh-cw" id="minimalNudgeSpinner"></i>
        <span>// Updating application...</span>
        <div class="minimal-update-nudge-controls">
          <button class="minimal-nudge-control-btn" onclick="minimizeMinimalNudge()" title="Minimize">
            <i data-lucide="minus"></i>
          </button>
        </div>
      </div>
      <ul class="minimal-update-list" id="minimalUpdateList">
        <!-- Updates will be added here dynamically -->
      </ul>
      <div class="minimal-update-complete" id="minimalUpdateComplete" style="display: none;">
        <i data-lucide="check-circle"></i>
        <span>// Build complete</span>
      </div>
    </div>
    
    <!-- Preview Container -->
    <div class="minimal-preview-container">
      <iframe class="minimal-preview-frame" id="minimalPreviewFrame"></iframe>
    </div>
    
    <!-- Processing Indicator removed - updates now stream to nudge container -->
    
    <!-- Chat Bar (bottom) -->
    <div class="minimal-chat-bar" id="minimalChatBar">
      <div class="minimal-chat-bar-handle" id="minimalChatBarHandle">
        <i data-lucide="grip-vertical"></i>
      </div>
      
      <button class="minimal-chat-bar-reset-btn" id="minimalChatBarResetBtn" onclick="resetMinimalChatBarPosition()" title="Reset position">
        <i data-lucide="rotate-ccw"></i>
      </button>
      
      <!-- Element Selector Button for Minimal Mode -->
      <button class="minimal-element-selector-btn" id="minimalElementSelectorBtn" onclick="toggleMinimalElementSelector()" title="Select Element - Click to select elements in the preview">
        <i data-lucide="mouse-pointer-click"></i>
      </button>
      
      <div class="minimal-chat-bar-resize-handle" id="minimalChatBarResizeHandle"></div>
      
      <div class="minimal-status-indicator" id="minimalStatusIndicator">
        <div class="minimal-spinner"></div>
        <span>Thinking...</span>
      </div>

      <div class="minimal-framework-display" id="minimalFrameworkDisplay" aria-label="Current design framework" aria-live="polite">
        <button
          type="button"
          class="minimal-framework-button"
          onclick="openDesignFrameworkModal()"
          title="Select design framework"
        >
          <i data-lucide="library"></i>
        </button>
        <span class="minimal-framework-label" id="minimalFrameworkLabel">None</span>
      </div>

      <textarea 
        class="minimal-chat-input" 
        id="minimalChatInput" 
        placeholder="Ask me anything..."
        rows="1"
      ></textarea>
      <button class="minimal-send-btn" id="minimalSendBtn" onclick="sendMinimalMessage()">
        <i data-lucide="send"></i>
      </button>
    </div>
  </div>

  <!-- Publish Modal -->
  <div class="edit-row-modal" id="publishModal">
    <div class="edit-modal-content" style="width: 500px;">
      <div class="edit-modal-header">
        <h3>Share App</h3>
        <button class="modal-close" onclick="closePublishModal()">
          <i data-lucide="x"></i>
        </button>
      </div>
      
      <div id="publishModalForm">
        <div id="publishStatusMessage" style="padding: var(--space-3); background: rgba(0, 83, 226, 0.05); border-radius: 8px; margin-bottom: var(--space-3); border-left: 3px solid var(--primary-blue);">
          <div style="display: flex; gap: var(--space-3); align-items: center;">
            <div class="status-icon" style="width: 32px; height: 32px; background: var(--primary-blue); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white;">
              <i data-lucide="share-2"></i>
            </div>
            <div class="status-details">
              <strong id="publishModalActionText">Get Shareable Link</strong><br>
              <span id="publishModalDescriptionText">Get a shareable link that always shows the latest version of your app.</span>
            </div>
          </div>
        </div>
        
        <div class="form-field">
          <label for="publishAppName">Name (for database)</label>
          <input 
            type="text" 
            id="publishAppName" 
            name="app_name" 
            placeholder="e.g., My Dashboard" 
            required
          >
          <p style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
            This name helps you identify this version in the database.
          </p>
        </div>
        
        <div id="publishErrorMessage" style="display: none; margin-top: var(--space-3); padding: var(--space-3); background: #FEE; border: 1px solid var(--error-red); border-radius: 8px; color: var(--error-red);"></div>
      </div>

      <div id="publishSuccessContent" style="display: none;">
        <div style="text-align: center; margin-bottom: var(--space-4);">
          <div style="width: 48px; height: 48px; background: #E6F4EA; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: #1E8E3E; margin: 0 auto var(--space-3);">
            <i data-lucide="check" style="width: 24px; height: 24px;"></i>
          </div>
          <h3>Link Generated!</h3>
          <p style="color: var(--text-secondary);">Anyone with this link can view this version of your app.</p>
        </div>
        
        <div class="form-field">
          <label>Shareable URL</label>
          <div style="display: flex; gap: var(--space-2);">
            <input type="text" id="publishedURL" readonly onclick="this.select()" style="flex: 1;">
            <button class="btn-secondary" onclick="copyPublishedURL()">
              <i data-lucide="copy"></i>
            </button>
            <button class="btn-secondary" onclick="openPublishedApp()">
              <i data-lucide="external-link"></i>
            </button>
          </div>
        </div>
      </div>
      
      <div class="modal-footer">
        <button type="button" class="btn-secondary" onclick="closePublishModal()">Close</button>
        <button type="button" class="btn-primary" id="publishBtn" onclick="publishCurrentApp()">
          <span id="publishBtnText">Generate Link</span>
          <span id="publishBtnSpinner" style="display: none;">Generating...</span>
        </button>
      </div>
    </div>
  </div>

  <!-- VERSION HISTORY MODAL -->
  <div class="edit-row-modal" id="versionHistoryModal">
    <div class="edit-modal-content" style="max-width: 800px;">
      <div class="edit-modal-header">
        <h3>Version History</h3>
        <button class="modal-close" onclick="closeVersionHistoryModal()">
          <i data-lucide="x"></i>
        </button>
      </div>
      
      <div id="versionHistoryContent" style="max-height: 500px; overflow-y: auto;">
        <div style="text-align: center; padding: var(--space-6); color: var(--text-secondary);">
          <i data-lucide="loader-2" style="animation: spin 1s linear infinite;"></i>
          <p style="margin-top: var(--space-2);">Loading versions...</p>
        </div>
      </div>
    </div>
  </div>

  <!-- SHARE MODAL -->
  <div class="edit-row-modal" id="shareModal">
    <div class="edit-modal-content">
      <div class="edit-modal-header">
        <h3>Share App</h3>
        <button class="modal-close" onclick="closeShareModal()">
          <i data-lucide="x"></i>
        </button>
      </div>
      
      <div id="shareModalContent">
        <!-- Published URL Status (shown if already published) -->
        <div id="sharePublishedURLSection" style="display: none; margin-bottom: var(--space-4); padding: var(--space-4); background: linear-gradient(135deg, #E8F5E9 0%, #C6F6D5 100%); border-radius: 12px; border: 2px solid var(--success-green);">
          <div style="display: flex; align-items: center; gap: var(--space-2); margin-bottom: var(--space-2);">
            <i data-lucide="check-circle" style="width: 24px; height: 24px; color: var(--success-green);"></i>
            <h4 style="font-size: 16px; font-weight: 600; color: var(--success-green); margin: 0;">App is Published!</h4>
          </div>
          <p style="font-size: 13px; color: #2d5f3c; margin-bottom: var(--space-3);">Your app is live and accessible at:</p>
          <div style="display: flex; align-items: center; gap: var(--space-2);">
            <input type="text" id="sharePublishedURLInput" readonly 
              style="flex: 1; padding: 10px 12px; border: 1px solid var(--success-green); border-radius: 8px; font-size: 13px; font-family: monospace; background: white; font-weight: 500;">
            <button class="btn-icon" onclick="copyShareURL()" title="Copy URL">
              <i data-lucide="copy"></i>
            </button>
            <button class="btn-icon" onclick="openShareURL()" title="Open in new tab">
              <i data-lucide="external-link"></i>
            </button>
          </div>
        </div>

        <div style="margin-bottom: var(--space-4);">
          <p style="font-size: 14px; color: var(--text-secondary); line-height: 1.6;">
            Share your app with others by copying the HTML code or publishing it to get a live URL.
          </p>
        </div>

        <!-- Share Options -->
        <div style="display: flex; flex-direction: column; gap: var(--space-3);">
          <!-- Copy HTML Code -->
          <div class="share-option-card">
            <div style="display: flex; align-items: flex-start; gap: var(--space-3);">
              <div style="flex-shrink: 0; width: 40px; height: 40px; background: var(--surface-gray); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                <i data-lucide="code" style="width: 20px; height: 20px; color: var(--primary-blue);"></i>
              </div>
              <div style="flex: 1;">
                <h4 style="margin-bottom: 4px; font-size: 14px; font-weight: 600;">Copy HTML Code</h4>
                <p style="font-size: 13px; color: var(--text-secondary); margin-bottom: var(--space-2);">
                  Copy the complete HTML file to share or host anywhere
                </p>
                <button class="btn-secondary" onclick="copyHTMLCode()" style="font-size: 13px; padding: 6px 16px;">
                  <i data-lucide="copy"></i>
                  <span>Copy HTML</span>
                </button>
              </div>
            </div>
          </div>

          <!-- Download HTML -->
          <div class="share-option-card">
            <div style="display: flex; align-items: flex-start; gap: var(--space-3);">
              <div style="flex-shrink: 0; width: 40px; height: 40px; background: var(--surface-gray); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                <i data-lucide="download" style="width: 20px; height: 20px; color: var(--primary-blue);"></i>
              </div>
              <div style="flex: 1;">
                <h4 style="margin-bottom: 4px; font-size: 14px; font-weight: 600;">Download HTML File</h4>
                <p style="font-size: 13px; color: var(--text-secondary); margin-bottom: var(--space-2);">
                  Download as a .html file to share or deploy
                </p>
                <button class="btn-secondary" onclick="downloadCode()" style="font-size: 13px; padding: 6px 16px;">
                  <i data-lucide="download"></i>
                  <span>Download</span>
                </button>
              </div>
            </div>
          </div>

          <!-- Publish to Live URL -->
          <div class="share-option-card" style="border: 2px solid var(--primary-blue); background: rgba(0, 83, 226, 0.02);">
            <div style="display: flex; align-items: flex-start; gap: var(--space-3);">
              <div style="flex-shrink: 0; width: 40px; height: 40px; background: var(--primary-blue); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                <i data-lucide="upload-cloud" style="width: 20px; height: 20px; color: white;"></i>
              </div>
              <div style="flex: 1;">
                <h4 style="margin-bottom: 4px; font-size: 14px; font-weight: 600; color: var(--primary-blue);">Publish to Live URL</h4>
                <p style="font-size: 13px; color: var(--text-secondary); margin-bottom: var(--space-2);">
                  Get a shareable URL that anyone can access
                </p>
                <div id="sharePublishStatus"></div>
                <button class="btn-primary" onclick="publishFromShare()" style="font-size: 13px; padding: 6px 16px;">
                  <i data-lucide="upload-cloud"></i>
                  <span>Publish App</span>
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="modal-actions" style="margin-top: var(--space-4);">
        <button type="button" class="btn-secondary" onclick="closeShareModal()">Close</button>
      </div>
    </div>
  </div>

  <script>
    // ===== CONFIGURATION =====
    // Dynamic API Base URL - Auto-detects environment (dev/stage/prod) or uses localhost for local development
    const API_BASE = (function() {
      const hostname = window.location.hostname;
      const port = window.location.port;
      
      // Local development
      if (hostname === 'localhost' || hostname === '127.0.0.1') {
        return `http://localhost:${port || 8080}`;
      }
      
      // Deployed environments - use exact hostname matching to prevent false positives
      // Stage environment
      if (hostname === 'stage') {
        return 'stage url';
      }
      
      // Production environment (when it exists)
      if (hostname === 'prod') {
        return 'prod url';
      }
      
      // Dev environment (default for scus-dev-a3 and any unknown environments)
      return 'dev url';
    })();
    
    console.log(` Environment detected: ${API_BASE}`);
    
    // TODO: Move to environment variable injection (see SECURITY.md)
    const CODE_PUPPY_API_KEY = 'API'
    // ===== STATE MANAGEMENT =====
    let currentMainTab = 'preview';
    let currentCloudNav = 'database';
    let generatedHTML = '';
    let chatConversationHistory = [];
    let chatUIMessages = []; // UI chat messages for display
    let loadedChatHistory = []; // Stores conversation history loaded from DB on app init
    let loadedChatHistorySummary = ''; // Summarized version of loaded chat history for first API call
    let needsHistorySummaryInjection = false; // Flag to inject summary on next API call
    let currentTypingIndicatorId = null;
    let lastSaveTime = null;
    // Default design framework: Living Design 3.5 for all sessions/projects unless changed
    let currentDesignFramework = 'living-design';
    // Track if conversation history contains a full HTML copy (for optimization)
    let conversationHasFullHTML = false;
    let previousWorkingHTML = ''; // Backup of last known working version
    let errorRetryCount = 0;
    let maxRetryAttempts = 3;
    let isRetrying = false;
    let autoFixAttempts = 0; // Track auto-fix attempts to prevent infinite loops
    const MAX_AUTO_FIX_ATTEMPTS = 2; // Only try auto-fix twice max
    window.userIntentIsQuestion = false; // Track if user is asking a question vs requesting action
    let referenceImageData = null; // Stores base64 image data (for backward compatibility)
    let referenceImageName = null; // Stores image filename (for backward compatibility)
    let referenceImages = []; // Stores multiple uploaded images [{data, name, isSVGText}]
    let currentMode = 'agent'; // agent, plan, or chat
    let currentAbortController = null; // Abort controller for stopping AI streaming
    
    // ===== PROJECT MANAGEMENT =====
    let currentProjectId = null; // Currently active project ID
    let allProjects = []; // List of all projects
    let isProjectSwitching = false; // Prevent race conditions during project switch
    let projectSwitchAbortController = null; // Abort controller for cancelling in-progress project switch
    
    // ===== VERSION HISTORY SYSTEM =====
    let versionHistory = []; // Array of {id, timestamp, html, userMessage, assistantMessage, cacheId, versionNumber}
    let currentVersionIndex = -1; // Index of currently active version (-1 = latest)
    let currentProjectName = 'My App Project'; // Current project name for versions
    let currentVersionNumber = 0; // Current version number (increments with each save)
    
    /**
     * Save a new version to history
     * @param {string} html - The HTML content to save
     * @param {string} userMessage - The user's message that triggered this version
     * @param {string} assistantMessage - The assistant's response (optional)
     * @param {boolean} saveToDB - Whether to save to BigQuery (default: false, only localStorage)
     */
    async function saveVersion(html, userMessage, assistantMessage = '', saveToDB = false) {
      const versionId = `v${Date.now()}`;
      const cacheId = `${currentProjectName.toLowerCase().replace(/\s+/g, '-')}-${versionId}`;
      
      // Version number will be incremented right before saveToBigQuery() call
      // This prevents duplicate increments when called from multiple places
      
      const version = {
        id: versionId,
        timestamp: new Date().toISOString(),
        html: html,
        userMessage: userMessage,
        assistantMessage: assistantMessage,
        htmlSize: (html.length / 1024).toFixed(1) + ' KB',
        cacheId: cacheId,
        versionNumber: currentVersionNumber
      };
      
      // If we're viewing an old version and make a new change, remove future versions
      if (currentVersionIndex >= 0 && currentVersionIndex < versionHistory.length - 1) {
        versionHistory = versionHistory.slice(0, currentVersionIndex + 1);
      }
      
      versionHistory.push(version);
      currentVersionIndex = versionHistory.length - 1;
      
      // Only save to BigQuery if explicitly requested (e.g., final version after generation)
      if (saveToDB) {
        try {
          await saveToBigQuery(currentProjectName, html, cacheId, version.versionNumber);
        } catch (e) {
          // Silent fail - version still saved locally
        }
      }
      
      // Keep only last 50 versions to prevent memory issues
      if (versionHistory.length > 50) {
        versionHistory = versionHistory.slice(-50);
        currentVersionIndex = versionHistory.length - 1;
      }
      
      // Persist to localStorage
      try {
        localStorage.setItem('versionHistory', JSON.stringify(versionHistory));
        localStorage.setItem('currentVersionIndex', currentVersionIndex.toString());
        localStorage.setItem('currentVersionNumber', currentVersionNumber.toString());
      } catch (e) {
        // Silent fail - localStorage quota may be exceeded
      }
      
      updateVersionIndicators();
    }
    
    /**
     * Load version history from localStorage
     */
    function loadVersionHistory() {
      try {
        const saved = localStorage.getItem('versionHistory');
        const savedIndex = localStorage.getItem('currentVersionIndex');
        const savedHTML = localStorage.getItem('currentHTML');
        const savedVersionNumber = localStorage.getItem('currentVersionNumber');
        
        if (saved) {
          versionHistory = JSON.parse(saved);
          currentVersionIndex = savedIndex ? parseInt(savedIndex) : versionHistory.length - 1;
          
          // Restore the current version number
          if (savedVersionNumber) {
            currentVersionNumber = parseInt(savedVersionNumber);
          } else if (versionHistory.length > 0) {
            // If no saved version number, find the highest version number from history
            const maxVersion = Math.max(...versionHistory.map(v => v.versionNumber || 0));
            currentVersionNumber = maxVersion;
          }
          
          // Restore the current HTML if available
          if (savedHTML && savedHTML.trim() !== '') {
            generatedHTML = ensureUTF8Meta(savedHTML);
            
            // Update preview with restored HTML
            const preview = document.getElementById('previewFrame');
            if (preview) {
              preview.srcdoc = wrapHTMLWithConsoleCapture(generatedHTML);
            }
            updateCodeView(generatedHTML);
          }
          
          updateVersionIndicators();
          return true;
        }
      } catch (e) {
        // Silent fail - localStorage may not be available
      }
      return false;
    }
    
    /**
     * Restore a specific version by ID or index
     * @param {string|number} versionIdOrIndex - Version ID or index to restore
     */
    async function restoreVersion(versionIdOrIndex) {
      // Show loading animation in main panel
      const preview = document.getElementById('previewFrame');
      const loading = document.getElementById('previewLoading');
      
      if (loading) {
        loading.classList.remove('hidden');
        loading.querySelector('p').textContent = 'Loading previous version...';
      }
      if (preview) preview.classList.remove('loaded');
      
      let index = -1;
      
      if (typeof versionIdOrIndex === 'number') {
        index = versionIdOrIndex;
      } else {
        index = versionHistory.findIndex(v => v.id === versionIdOrIndex);
      }
      
      
      if (index < 0 || index >= versionHistory.length) {
        // Hide loading on error
        if (loading) loading.classList.add('hidden');
        if (preview) preview.classList.add('loaded');
        
        addMessageToChat('system error', 'Invalid version');
        return false;
      }
      
      const version = versionHistory[index];
      
      // Load HTML directly from BigQuery database cache
      let restoredHTML = null;
      try {
        const loadResponse = await fetch(`${API_BASE}/api/html/load`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ cache_id: version.cacheId })
        });
        
        if (!loadResponse.ok) {
          throw new Error(`Failed to load from DB: ${loadResponse.status}`);
        }
        
        const loadData = await loadResponse.json();
        // Normalize and ensure UTF-8 charset for restored HTML
        restoredHTML = ensureUTF8Meta(loadData.data.html_content);
        
        // Update the version object with DB data to ensure sync
        version.html = restoredHTML;
        
      } catch (e) {
        restoredHTML = version.html; // Fallback to locally stored HTML
        
        if (!restoredHTML) {
          // Hide loading on error
          if (loading) loading.classList.add('hidden');
          if (preview) preview.classList.add('loaded');
          
          addMessageToChat('system error', 'Failed to restore version: no HTML content available');
          return false;
        }
      }
      
      // IMPORTANT: When restoring to an old version, truncate future versions
      // This makes the restored version the new "latest" version
      const isRestoringOldVersion = index < versionHistory.length - 1;
      
      if (isRestoringOldVersion) {
        versionHistory = versionHistory.slice(0, index + 1);
      }
      
      // Update state - this is now the latest version
      currentVersionIndex = versionHistory.length - 1;
      generatedHTML = restoredHTML;
      
      // Version will be incremented inside saveToBigQuery flow
      // Save the restored version as a NEW version to BigQuery with unique cache_id
      try {
        const newCacheId = `${currentProjectName.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}`;
        currentVersionNumber++; // Increment once before save
        await saveToBigQuery(currentProjectName, generatedHTML, newCacheId, currentVersionNumber);
      } catch (e) {
        // Silent fail - version still available locally
      }
      
      // Persist to localStorage - this is critical for page reload persistence
      try {
        localStorage.setItem('versionHistory', JSON.stringify(versionHistory));
        localStorage.setItem('currentVersionIndex', currentVersionIndex.toString());
        localStorage.setItem('currentVersionNumber', currentVersionNumber.toString());
        localStorage.setItem('currentHTML', generatedHTML);
      } catch (e) {
        // Silent fail - localStorage quota may be exceeded
      }
      
      // Update preview iframe
      setTimeout(() => {
        if (preview) {
          preview.srcdoc = wrapHTMLWithConsoleCapture(generatedHTML);
          preview.onload = () => {
            if (loading) {
              loading.classList.add('hidden');
              loading.querySelector('p').textContent = 'Loading preview...'; // Reset text
            }
            if (preview) preview.classList.add('loaded');
          };
          preview.onerror = () => {
            if (loading) loading.classList.add('hidden');
          };
        }
      }, 100);
      
      // Update code view
      updateCodeView(generatedHTML);
      
      // Add system message to chat (with hidden version number as data attribute)
      const versionNum = index + 1;
      const totalVersions = versionHistory.length;
      const timestamp = new Date(version.timestamp).toLocaleTimeString();
      
      // After truncation, this is always the latest version
      const messageContent = `Restored to version ${versionNum}/${totalVersions} (Now Latest)<br>Created: ${timestamp}<br>Message: "${version.userMessage.substring(0, 60)}${version.userMessage.length > 60 ? '...' : ''}"`;
      addMessageToChat('system', messageContent);
      
      // Add version number as hidden data attribute to the latest chat message
      setTimeout(() => {
        const messages = document.querySelectorAll('.chat-message');
        if (messages.length > 0) {
          const lastMessage = messages[messages.length - 1];
          lastMessage.setAttribute('data-version-number', version.versionNumber);
        }
      }, 50);
      
      // Update UI indicators
      updateVersionIndicators();
      
      return true;
    }
    
    /**
     * Go to previous version
     */
    // Database-driven version navigation
    let dbVersions = []; // Array of versions from database
    let currentDBVersionIndex = -1; // Current version index in dbVersions array
    let versionsToShow = 10; // Initial number of versions to show in dropdown
    
    /**
     * Load all versions for the current project from database
     */
    async function loadDBVersions(signal = null) {
      if (!currentProjectId) {
        return;
      }
      
      try {
        const tableName = `${currentProjectId}_html_cache`;
        
        const fetchOptions = {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            table_name: tableName,
            where_clause: 'is_active = true',
            order_by: 'version DESC',
            limit: 100
          })
        };
        
        // Add abort signal if provided
        if (signal) {
          fetchOptions.signal = signal;
        }
        
        const response = await fetch(`${API_BASE}/api/table/query`, fetchOptions);
        
        if (!response.ok) {
          return;
        }
        
        const result = await response.json();
        
        if (result.success && result.data && result.data.length > 0) {
          // Normalize, decode, and sanitize HTML content from base64 (if needed)
          const normalized = result.data.map(row => {
            if (row && typeof row.html_content === 'string' && row.html_content.length > 0) {
              // If it doesn't already look like HTML, try base64 decode
              const trimmed = row.html_content.trim();
              const looksLikeHTML = trimmed.startsWith('<!DOCTYPE') || trimmed.startsWith('<html') || trimmed.startsWith('<');
              
              if (!looksLikeHTML) {
                try {
                  const decoded = atob(row.html_content);
                  const decodedTrimmed = decoded.trim();
                  
                  if (
                    decodedTrimmed.startsWith('<!DOCTYPE') ||
                    decodedTrimmed.startsWith('<html') ||
                    decodedTrimmed.startsWith('<')
                  ) {
                    row.html_content = decoded;
                  }
                } catch (e) {
                  // If decoding fails, keep original content for backward compatibility
                  console.warn('Failed to decode html_content from base64 for version row:', e);
                }
              }
              
              // Ensure UTF-8 meta so special characters render correctly
              row.html_content = ensureUTF8Meta(row.html_content);
            }
            return row;
          });
          
          // Sort ascending - handle null versions by using 0 as fallback, then by timestamp
          dbVersions = normalized.sort((a, b) => {
            const vA = a.version !== null && a.version !== undefined ? parseInt(a.version) : 0;
            const vB = b.version !== null && b.version !== undefined ? parseInt(b.version) : 0;
            // If both have the same version (including both null/0), sort by timestamp
            if (vA === vB || (isNaN(vA) && isNaN(vB))) {
              return new Date(a.last_updated) - new Date(b.last_updated);
            }
            return (vA || 0) - (vB || 0);
          });
          
          // Set current to latest version
          currentDBVersionIndex = dbVersions.length - 1;
          
          // Synchronize currentVersionNumber with the highest version in database
          // This ensures the next save will increment from the correct number
          if (dbVersions.length > 0) {
            const maxVersion = Math.max(...dbVersions.map(v => {
              const versionNum = parseInt(v.version);
              return !isNaN(versionNum) ? versionNum : 0;
            }));
            currentVersionNumber = maxVersion;
            console.log(` Synchronized currentVersionNumber with DB max: ${currentVersionNumber}`);
          }
          
          // Update UI
          updateDBVersionDisplay();
        } else {
          dbVersions = [];
          currentDBVersionIndex = -1;
        }
      } catch (err) {
        dbVersions = [];
        currentDBVersionIndex = -1;
      }
    }
    
    /**
     * Delete a version (soft delete by setting is_active = false)
     */
    async function deleteVersion(versionIndex) {
      if (!currentProjectId) {
        addMessageToChat('system error', ' No project selected');
        return;
      }
      
      if (versionIndex < 0 || versionIndex >= dbVersions.length) {
        addMessageToChat('system error', ' Invalid version');
        return;
      }
      
      const version = dbVersions[versionIndex];
      
      // Prevent deleting the currently active version
      if (versionIndex === currentDBVersionIndex) {
        addMessageToChat('system error', ' Cannot delete the currently active version');
        return;
      }
      
      // Prevent deleting the only version
      if (dbVersions.length === 1) {
        addMessageToChat('system error', ' Cannot delete the only version');
        return;
      }
      
      // Confirm deletion
      const versionNum = version.version || (versionIndex + 1);
      const timestamp = new Date(version.last_updated).toLocaleString();
      const confirmMsg = `Delete version ${versionNum} from ${timestamp}?\n\nThis cannot be undone.`;
      
      if (!confirm(confirmMsg)) {
        return;
      }
      
      console.log(' Deleting version:', version.cache_id);
      
      try {
        const tableName = `${currentProjectId}_html_cache`;
        
        // Soft delete - set is_active = false
        const response = await fetch(`${API_BASE}/api/table/update`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            table_name: tableName,
            data: { is_active: false },
            where_clause: `cache_id = '${version.cache_id.replace(/'/g, "\\'")}'`
          })
        });
        
        if (!response.ok) {
          throw new Error(`API returned ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
          console.log(' Version deleted successfully');
          addMessageToChat('system', ` Version ${versionNum} deleted`);
          
          // Remove from local array
          dbVersions.splice(versionIndex, 1);
          
          // Adjust current index if needed
          if (currentDBVersionIndex > versionIndex) {
            currentDBVersionIndex--;
          } else if (currentDBVersionIndex === dbVersions.length) {
            currentDBVersionIndex = dbVersions.length - 1;
          }
          
          // Refresh UI
          updateDBVersionDisplay();
        } else {
          throw new Error(result.error || 'Delete failed');
        }
      } catch (error) {
        console.error(' Failed to delete version:', error);
        addMessageToChat('system error', ` Failed to delete version: ${error.message}`);
      }
    }
    
    /**
     * Update version display based on database versions
     */
    function updateDBVersionDisplay() {
      const versionInfo = document.getElementById('versionInfo');
      const versionSelector = document.getElementById('versionSelector');
      
      if (!versionSelector) return;
      
      // Hide if no versions
      if (dbVersions.length === 0) {
        if (versionInfo) {
          versionInfo.style.display = 'none';
        }
        return;
      }
      
      // Show version info
      if (versionInfo) {
        versionInfo.style.display = 'flex';
      }
      
      // Populate version selector dropdown
      versionSelector.innerHTML = '';
      
      // Determine how many versions to show
      const showCount = Math.min(versionsToShow, dbVersions.length);
      
      // Add versions in reverse order (newest first), limited to showCount
      for (let i = dbVersions.length - 1; i >= Math.max(0, dbVersions.length - showCount); i--) {
        const version = dbVersions[i];
        const option = document.createElement('option');
        option.value = i;
        
        // Format: "v100 - Nov 14, 3:45 PM"
        const date = new Date(version.last_updated);
        const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
        
        const isLatest = i === dbVersions.length - 1;
        // Handle null/undefined version numbers - use index + 1 as fallback
        const versionNum = version.version !== null && version.version !== undefined ? version.version : (i + 1);
        option.textContent = `v${versionNum} - ${dateStr}, ${timeStr}${isLatest ? ' (Latest)' : ''}`;
        
        versionSelector.appendChild(option);
      }
      
      // Add "Load more..." option if there are more versions
      if (showCount < dbVersions.length) {
        const loadMoreOption = document.createElement('option');
        loadMoreOption.value = 'load-more';
        loadMoreOption.textContent = ` Load more... (${dbVersions.length - showCount} older versions)`;
        loadMoreOption.style.fontStyle = 'italic';
        loadMoreOption.style.color = '#0074d9';
        versionSelector.appendChild(loadMoreOption);
      }
      
      // Set current selection
      versionSelector.value = currentDBVersionIndex;
      
      // Disable prev/next/delete buttons appropriately
      const prevBtn = versionInfo.querySelector('button:nth-child(1)');
      const nextBtn = versionInfo.querySelector('button:nth-child(3)');
      const deleteBtn = document.getElementById('btnDeleteVersion');
      
      if (prevBtn) {
        prevBtn.disabled = currentDBVersionIndex <= 0;
        prevBtn.style.opacity = currentDBVersionIndex <= 0 ? '0.3' : '1';
        prevBtn.style.cursor = currentDBVersionIndex <= 0 ? 'not-allowed' : 'pointer';
      }
      
      if (nextBtn) {
        nextBtn.disabled = currentDBVersionIndex >= dbVersions.length - 1;
        nextBtn.style.opacity = currentDBVersionIndex >= dbVersions.length - 1 ? '0.3' : '1';
        nextBtn.style.cursor = currentDBVersionIndex >= dbVersions.length - 1 ? 'not-allowed' : 'pointer';
      }
      
      // Disable delete button if only one version exists or no version selected
      if (deleteBtn) {
        const canDelete = dbVersions.length > 1 && currentDBVersionIndex >= 0;
        deleteBtn.disabled = !canDelete;
        deleteBtn.style.opacity = canDelete ? '1' : '0.3';
        deleteBtn.style.cursor = canDelete ? 'pointer' : 'not-allowed';
        deleteBtn.title = !canDelete 
          ? (dbVersions.length <= 1 ? 'Cannot delete the only version' : 'No version selected')
          : 'Delete this version';
      }
    }
    
    /**
     * Delete the currently selected version
     */
    function deleteCurrentVersion() {
      if (currentDBVersionIndex >= 0 && currentDBVersionIndex < dbVersions.length) {
        deleteVersion(currentDBVersionIndex);
      } else {
        addMessageToChat('system error', ' No version selected');
      }
    }
    
    /**
     * Load a specific version from the dropdown selector
     */
    async function loadSelectedVersion(indexStr) {
      // Handle "Load more..." option
      if (indexStr === 'load-more') {
        versionsToShow += 20; // Load 20 more versions
        updateDBVersionDisplay();
        return;
      }
      
      const index = parseInt(indexStr);
      
      if (isNaN(index) || index < 0 || index >= dbVersions.length) {
        return;
      }
      
      if (index === currentDBVersionIndex) {
        return; // Already viewing this version
      }
      
      currentDBVersionIndex = index;
      const version = dbVersions[index];
      
      // Handle null/undefined version numbers - use index + 1 as fallback
      const versionNum = version.version !== null && version.version !== undefined ? version.version : (index + 1);
      
      // Load the HTML
      generatedHTML = version.html_content;
      currentVersionNumber = parseInt(versionNum) || (index + 1);
      
      // Update preview
      const preview = document.getElementById('previewFrame');
      if (preview) {
        preview.srcdoc = wrapHTMLWithConsoleCapture(generatedHTML);
      }
      
      // Update code view
      updateCodeView(generatedHTML);
      
      // Update display (will update button states and selector)
      updateDBVersionDisplay();
      
      const isLatest = index === dbVersions.length - 1;
      const dateStr = new Date(version.last_updated).toLocaleString();
      addMessageToChat('system', ` Loaded version ${versionNum} (${dateStr})${isLatest ? ' - Latest' : ''}`);
    }
    
    /**
     * Load previous version from database
     */
    async function loadPreviousDBVersion() {
      if (dbVersions.length === 0) {
        addMessageToChat('system', 'No versions available');
        return;
      }
      
      if (currentDBVersionIndex <= 0) {
        addMessageToChat('system', 'Already at the oldest version');
        return;
      }
      
      currentDBVersionIndex--;
      const version = dbVersions[currentDBVersionIndex];
      
      // Handle null/undefined version numbers - use index + 1 as fallback
      const versionNum = version.version !== null && version.version !== undefined ? version.version : (currentDBVersionIndex + 1);
      
      // Load the HTML
      generatedHTML = version.html_content;
      currentVersionNumber = parseInt(versionNum) || (currentDBVersionIndex + 1);
      
      // Update preview
      const preview = document.getElementById('previewFrame');
      if (preview) {
        preview.srcdoc = wrapHTMLWithConsoleCapture(generatedHTML);
      }
      
      // Update code view
      updateCodeView(generatedHTML);
      
      // Update display
      updateDBVersionDisplay();
      
      addMessageToChat('system', ` Loaded version ${versionNum} (${new Date(version.last_updated).toLocaleString()})`);
    }
    
    /**
     * Load next version from database
     */
    async function loadNextDBVersion() {
      if (dbVersions.length === 0) {
        addMessageToChat('system', 'No versions available');
        return;
      }
      
      if (currentDBVersionIndex >= dbVersions.length - 1) {
        addMessageToChat('system', 'Already at the latest version');
        return;
      }
      
      currentDBVersionIndex++;
      const version = dbVersions[currentDBVersionIndex];
      
      // Handle null/undefined version numbers - use index + 1 as fallback
      const versionNum = version.version !== null && version.version !== undefined ? version.version : (currentDBVersionIndex + 1);
      
      // Load the HTML
      generatedHTML = version.html_content;
      currentVersionNumber = parseInt(versionNum) || (currentDBVersionIndex + 1);
      
      // Update preview
      const preview = document.getElementById('previewFrame');
      if (preview) {
        preview.srcdoc = wrapHTMLWithConsoleCapture(generatedHTML);
      }
      
      // Update code view
      updateCodeView(generatedHTML);
      
      // Update display
      updateDBVersionDisplay();
      
      addMessageToChat('system', ` Loaded version ${versionNum} (${new Date(version.last_updated).toLocaleString()})`);
    }
    
    // Legacy functions kept for compatibility (now redirect to DB versions)
    function gotoPreviousVersion() {
      loadPreviousDBVersion();
    }
    
    function gotoNextVersion() {
      loadNextDBVersion();
    }
    
    /**
     * Update version indicators in the UI (now uses database-driven display)
     */
    function updateVersionIndicators() {
      // Use the new database-driven version display
      updateDBVersionDisplay();
      
      // Update message indicators
      updateChatVersionButtons();
    }
    
    /**
     * Add version restore buttons to chat messages
     */
    function updateChatVersionButtons() {
      const messages = document.querySelectorAll('.chat-message.user');
      let needsIconInit = false;
      
      messages.forEach((msgEl, idx) => {
        // Remove version-current class from all first
        msgEl.classList.remove('version-current');
        
        // Only add button if there's a corresponding version
        if (idx < versionHistory.length) {
          const version = versionHistory[idx];
          let btn = msgEl.querySelector('.version-restore-btn');
          
          if (!btn) {
            btn = document.createElement('button');
            btn.className = 'version-restore-btn';
            btn.innerHTML = `<i data-lucide="rotate-ccw"></i>`;
            const versionLabel = version.versionNumber ? `v${version.versionNumber}` : `#${idx + 1}`;
            btn.title = `Restore to ${versionLabel} (${new Date(version.timestamp).toLocaleTimeString()})`;
            btn.setAttribute('data-version-index', idx.toString());
            btn.onclick = (e) => {
              e.stopPropagation();
              const vIdx = parseInt(e.currentTarget.getAttribute('data-version-index'));
              restoreVersion(vIdx);
            };
            msgEl.appendChild(btn);
            needsIconInit = true;
          }
          
          // Highlight current version
          const isCurrent = idx === currentVersionIndex;
          if (isCurrent) {
            msgEl.classList.add('version-current');
          }
        }
      });
      
      if (needsIconInit) {
        initLucideIcons();
      }
    }
    
    // ===== HELPER FUNCTIONS =====
    function initLucideIcons() {
      try {
        if (typeof lucide !== 'undefined' && lucide.createIcons) {
          lucide.createIcons();
        }
      } catch (error) {
        // Silent fail - icons will render as fallback text
      }
    }
    
    // ===== INLINE DIFF VIEWER (CURSOR-STYLE) =====
    function showDiffViewer(editDetails) {
      // Instead of modal, add inline diff message to chat
      addDiffMessageToChat(editDetails);
    }
    
    function addDiffMessageToChat(editDetails) {
      const messagesContainer = document.getElementById('chatMessages');
      const diffId = 'diff-' + Date.now();
      
      // Only show successful edits, ignore failed ones
      if (editDetails.appliedEdits.length === 0) {
        return; // Don't show diff if no successful changes
      }
      
      // Create the diff message div
      const diffMessage = document.createElement('div');
      diffMessage.className = 'chat-message assistant diff-message';
      diffMessage.id = diffId;
      
      // Create collapsed preview (shows ~3 lines, very concise)
      const previewLines = [];
      editDetails.appliedEdits.slice(0, 2).forEach((edit, index) => {
        const desc = edit.description || `Edit #${index + 1}`;
        // Truncate long descriptions
        const shortDesc = desc.length > 50 ? desc.substring(0, 50) + '...' : desc;
        previewLines.push(`${index + 1}. ${shortDesc}`);
      });
      
      if (editDetails.appliedEdits.length > 2) {
        previewLines.push(`+${editDetails.appliedEdits.length - 2} more`);
      }
      
      const previewText = previewLines.join('\n');
      
      // Build the HTML - concise version, no failed edits shown
      diffMessage.innerHTML = `
        <div class="diff-inline-container">
          <div class="diff-inline-header" onclick="toggleDiffDetails('${diffId}')">
            <div class="diff-inline-title">
              <i data-lucide="check-circle" style="width: 16px; height: 16px; color: var(--success-green);"></i>
              <strong>${editDetails.appliedEdits.length} change${editDetails.appliedEdits.length !== 1 ? 's' : ''}</strong>
            </div>
            <i data-lucide="chevron-down" class="diff-chevron" id="${diffId}-chevron" style="width: 16px; height: 16px; transition: transform 0.2s;"></i>
          </div>
          
          <div class="diff-inline-preview">${escapeHtml(previewText)}</div>
          
          <div class="diff-inline-details" id="${diffId}-details" style="display: none;">
            ${editDetails.appliedEdits.map((edit, index) => {
              const maxLength = 300;
              const oldStr = edit.old_string.length > maxLength 
                ? edit.old_string.substring(0, maxLength) + '...' 
                : edit.old_string;
              const newStr = edit.new_string.length > maxLength 
                ? edit.new_string.substring(0, maxLength) + '...' 
                : edit.new_string;
              
              return `
                <div class="diff-change-item">
                  <div class="diff-change-header">
                    <i data-lucide="git-commit" style="width: 14px; height: 14px;"></i>
                    ${edit.description || `Change #${index + 1}`}
                  </div>
                  <div class="diff-code-block diff-removed">
                    <div class="diff-code-label">
                      <i data-lucide="minus" style="width: 12px; height: 12px;"></i> Removed
                    </div>
                    <pre>${escapeHtml(oldStr)}</pre>
                  </div>
                  <div class="diff-code-block diff-added">
                    <div class="diff-code-label">
                      <i data-lucide="plus" style="width: 12px; height: 12px;"></i> Added
                    </div>
                    <pre>${escapeHtml(newStr)}</pre>
                  </div>
                </div>
              `;
            }).join('')}
          </div>
        </div>
      `;
      
      messagesContainer.appendChild(diffMessage);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      // Initialize icons
      setTimeout(() => initLucideIcons(), 50);
    }
    
    function toggleDiffDetails(diffId) {
      const details = document.getElementById(diffId + '-details');
      const chevron = document.getElementById(diffId + '-chevron');
      const preview = document.getElementById(diffId).querySelector('.diff-inline-preview');
      
      if (details.style.display === 'none') {
        details.style.display = 'block';
        preview.style.display = 'none';
        chevron.style.transform = 'rotate(180deg)';
      } else {
        details.style.display = 'none';
        preview.style.display = 'block';
        chevron.style.transform = 'rotate(0deg)';
      }
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    // ===== TOAST NOTIFICATIONS =====
    function showToast(title, message, type = 'info', duration = 4000) {
      const toast = document.createElement('div');
      toast.className = `toast-notification toast-${type}`;
      
      const iconMap = {
        success: 'check-circle',
        info: 'info',
        warning: 'alert-triangle',
        error: 'x-circle'
      };
      
      toast.innerHTML = `
        <i data-lucide="${iconMap[type] || 'info'}" class="toast-icon"></i>
        <div class="toast-content">
          <div class="toast-title">${escapeHtml(title)}</div>
          ${message ? `<div class="toast-message">${escapeHtml(message)}</div>` : ''}
        </div>
        <button class="toast-close" onclick="this.parentElement.remove()">
          <i data-lucide="x"></i>
        </button>
      `;
      
      document.body.appendChild(toast);
      
      // Initialize Lucide icons for the toast
      if (typeof lucide !== 'undefined' && lucide.createIcons) {
        lucide.createIcons();
      }
      
      // Auto-remove after duration
      if (duration > 0) {
        setTimeout(() => {
          toast.classList.add('toast-hiding');
          setTimeout(() => toast.remove(), 300);
        }, duration);
      }
      
      return toast;
    }
    
    // ===== ERROR HANDLING & VALIDATION =====
    /**
     * CSS Validation - Check for common CSS syntax issues
     * Called automatically after update_html to catch CSS problems
     */
    function validateCSS(html) {
      const errors = [];
      const warnings = [];
      
      if (!html || typeof html !== 'string') {
        return { valid: true, errors: [], warnings: [] };
      }
      
      // Extract all CSS from <style> tags
      const styleMatches = html.match(/<style[^>]*>([\s\S]*?)<\/style>/gi) || [];
      const allCSS = styleMatches.map(match => {
        const content = match.replace(/<style[^>]*>/i, '').replace(/<\/style>/i, '');
        return content;
      }).join('\n');
      
      // Also check inline styles
      const inlineStyles = html.match(/style\s*=\s*"([^"]*)"/gi) || [];
      
      if (!allCSS && inlineStyles.length === 0) {
        return { valid: true, errors: [], warnings: ['No CSS found in document'] };
      }
      
      // Check for unclosed braces in CSS
      const openBraces = (allCSS.match(/{/g) || []).length;
      const closeBraces = (allCSS.match(/}/g) || []).length;
      if (openBraces !== closeBraces) {
        const diff = openBraces - closeBraces;
        const fixHint = diff > 0 
          ? `Missing ${diff} closing '}' brace(s) - find the CSS rule you just edited and add the missing '}'`
          : `Extra ${Math.abs(diff)} closing '}' brace(s) - you may have accidentally added extra '}' or deleted an opening '{'`;
        errors.push(`CSS brace mismatch: ${openBraces} opening '{' vs ${closeBraces} closing '}'. FIX: ${fixHint}`);
      }
      
      // Check for unclosed comments
      const commentOpens = (allCSS.match(/\/\*/g) || []).length;
      const commentCloses = (allCSS.match(/\*\//g) || []).length;
      if (commentOpens !== commentCloses) {
        errors.push(`CSS comment mismatch: ${commentOpens} opening '/*' vs ${commentCloses} closing '*/' - unclosed comment`);
      }
      
      // Check for common syntax errors
      // Property without value (e.g., "color;" or "margin;")
      const emptyProperties = allCSS.match(/[a-z-]+\s*:\s*;/gi);
      if (emptyProperties && emptyProperties.length > 0) {
        errors.push(`Found ${emptyProperties.length} CSS property/properties with empty values: ${emptyProperties.slice(0, 3).join(', ')}${emptyProperties.length > 3 ? '...' : ''}`);
      }
      
      // Check for missing semicolons before closing braces (common AI error)
      const missingSemicolons = allCSS.match(/[a-z0-9)%"']+\s*\n\s*}/gi);
      if (missingSemicolons && missingSemicolons.length > 0) {
        warnings.push(`Possible missing semicolons before ${missingSemicolons.length} closing brace(s) - may cause style issues`);
      }
      
      // Check for duplicate selectors that might conflict
      const selectorPattern = /([.#]?[a-z][a-z0-9_-]*(?:\s*,\s*[.#]?[a-z][a-z0-9_-]*)*)\s*{/gi;
      const selectors = [];
      let selectorMatch;
      while ((selectorMatch = selectorPattern.exec(allCSS)) !== null) {
        selectors.push(selectorMatch[1].trim().toLowerCase());
      }
      const duplicates = selectors.filter((item, index) => selectors.indexOf(item) !== index);
      if (duplicates.length > 5) {
        warnings.push(`Found ${duplicates.length} duplicate CSS selectors - may cause style conflicts or overrides`);
      }
      
      // Check for broken url() references
      const brokenUrls = allCSS.match(/url\(\s*\)/gi);
      if (brokenUrls && brokenUrls.length > 0) {
        errors.push(`Found ${brokenUrls.length} empty url() reference(s) - missing image/font paths`);
      }
      
      // Check for invalid color values
      const invalidColors = allCSS.match(/#[g-z][a-z0-9]*/gi);
      if (invalidColors && invalidColors.length > 0) {
        warnings.push(`Possibly invalid hex color(s): ${invalidColors.slice(0, 3).join(', ')}`);
      }
      
      // Check for invalid units (common mistakes like 10pixels instead of 10px)
      const invalidUnits = allCSS.match(/\d+\s*(pixels|points|percent|rems|ems)\b/gi);
      if (invalidUnits && invalidUnits.length > 0) {
        errors.push(`Invalid CSS units found: ${invalidUnits.slice(0, 3).join(', ')} - use px, pt, %, rem, em instead`);
      }
      
      // Check inline styles for issues
      for (const inlineStyle of inlineStyles) {
        const styleValue = inlineStyle.replace(/style\s*=\s*"/i, '').replace(/"$/, '');
        
        // Check for JavaScript template literals ${...} - they don't work in HTML!
        const templateLiteralMatch = styleValue.match(/\$\{([^}]+)\}/);
        if (templateLiteralMatch) {
          errors.push(`Inline style contains JavaScript template literal - WRONG: style="${styleValue.substring(0, 50)}..."  FIX: Template literals like \${${templateLiteralMatch[1]}} do NOT work in HTML. Use JavaScript: element.style.background = ${templateLiteralMatch[1]};`);
        }
        // Check for curly braces (CSS selectors in inline styles)
        else if (styleValue.includes('{') || styleValue.includes('}')) {
          errors.push(`Inline style contains curly braces - WRONG: style="${styleValue.substring(0, 50)}..."  FIX: Remove { } and selectors, use only "property: value;" format like style="color: red; padding: 10px;"`);
        }
      }
      
      // Check for common property typos
      const typoPatterns = [
        { pattern: /backgorund|backgroud|backgound/gi, correct: 'background' },
        { pattern: /trasition|transiton/gi, correct: 'transition' },
        { pattern: /positon|postion/gi, correct: 'position' },
        { pattern: /trasform|tranform/gi, correct: 'transform' },
        { pattern: /dispaly|dislpay/gi, correct: 'display' },
        { pattern: /visibilty|visbility/gi, correct: 'visibility' },
        { pattern: /margn|marign/gi, correct: 'margin' },
        { pattern: /paddng|padidng/gi, correct: 'padding' },
        { pattern: /z-idnex|zindex\s*:/gi, correct: 'z-index' },
      ];
      
      for (const { pattern, correct } of typoPatterns) {
        const typos = allCSS.match(pattern);
        if (typos && typos.length > 0) {
          errors.push(`CSS typo found: "${typos[0]}" should be "${correct}"`);
        }
      }
      
      return {
        valid: errors.length === 0,
        errors: errors,
        warnings: warnings
      };
    }
    
    function validateHTML(html) {
      const errors = [];
      const warnings = [];
      
      // Basic HTML structure checks
      if (!html || html.trim() === '') {
        errors.push('HTML is empty - AI may have misunderstood the request. Please ensure generate_html receives a complete HTML document.');
        return { valid: false, errors, isCritical: true };
      }
      
      // Check for unclosed string literals in attributes (common AI error)
      // Look for patterns like: class="something or onclick="handler(
      const unclosedAttrPattern = /<[^>]+\s+\w+\s*=\s*"[^"]*(?:<|$)/gm;
      const unclosedAttrs = html.match(unclosedAttrPattern);
      if (unclosedAttrs && unclosedAttrs.length > 0) {
        errors.push(`Found ${unclosedAttrs.length} potentially unclosed attribute quote(s) - this will break HTML rendering`);
      }
      
      // Check for incomplete tags (opening < without closing >)
      // Look for < followed by text but no > before next <
      const brokenTagPattern = /<[a-zA-Z][^>]*<(?!\/)/g;
      const brokenTags = html.match(brokenTagPattern);
      if (brokenTags && brokenTags.length > 0) {
        errors.push(`Found ${brokenTags.length} incomplete/broken tag(s) - missing closing >`);
      }
      
      // Check for script tags that might be broken
      const scriptOpenCount = (html.match(/<script/gi) || []).length;
      const scriptCloseCount = (html.match(/<\/script>/gi) || []).length;
      if (scriptOpenCount !== scriptCloseCount) {
        errors.push(`Mismatched script tags: ${scriptOpenCount} opening, ${scriptCloseCount} closing`);
      }
      
      // Check for style tags that might be broken
      const styleOpenCount = (html.match(/<style/gi) || []).length;
      const styleCloseCount = (html.match(/<\/style>/gi) || []).length;
      if (styleOpenCount !== styleCloseCount) {
        errors.push(`Mismatched style tags: ${styleOpenCount} opening, ${styleCloseCount} closing`);
      }
      
      // Check if this looks like a full HTML document (not just a snippet)
      const looksLikeFullDocument = 
        html.includes('<!DOCTYPE') || 
        html.includes('<html') || 
        (html.includes('<head>') && html.includes('<body>'));
      
      // Only validate structure if it's supposed to be a full document
      if (looksLikeFullDocument) {
        if (!html.includes('<!DOCTYPE html>') && !html.includes('<!doctype html>')) {
          warnings.push('Missing DOCTYPE declaration');
        }
        
        if (!html.includes('<html')) {
          errors.push('Missing <html> tag');
        }
        
        if (!html.includes('<head>')) {
          errors.push('Missing <head> section');
        }
        
        if (!html.includes('<body>')) {
          errors.push('Missing <body> section');
        }
        
        // Check for common syntax errors
        const openTags = (html.match(/<(?!\/|\!)[a-zA-Z][^>]*>/g) || []).length;
        const closeTags = (html.match(/<\/[a-zA-Z][^>]*>/g) || []).length;
        
        // Allow some flexibility (self-closing tags like <br>, <img>, <input>, etc.)
        if (Math.abs(openTags - closeTags) > 30) {
          warnings.push(`Tag balance warning: ${openTags} opening tags, ${closeTags} closing tags (difference: ${Math.abs(openTags - closeTags)})`);
        }
      } else {
        // For snippets (SVG, components, etc.), just check if it's not empty
        // This is valid - AI is probably generating a component or snippet
        return {
          valid: errors.length === 0,
          errors: errors,
          warnings: ['HTML appears to be a snippet/component rather than full document - this is OK if intentional']
        };
      }
      
      return {
        valid: errors.length === 0,
        errors: errors,
        warnings: warnings
      };
    }
    
    /**
     * Ensure generated HTML declares UTF-8 to avoid garbled characters.
     * - If a <meta charset> already exists (any value), HTML is returned unchanged.
     * - Otherwise a <meta charset="UTF-8"> tag is injected into the <head>,
     *   or a minimal <head> section is created if missing.
     */
    function ensureUTF8Meta(html) {
      if (!html || typeof html !== 'string') return html;
      
      // If charset is already declared, don't touch the document
      if (/<meta[^>]+charset\s*=/i.test(html)) {
        return html;
      }
      
      const metaTag = '\n  <meta charset="UTF-8">';
      
      // Preferred: inject inside existing <head> tag
      const headMatch = html.match(/<head[^>]*>/i);
      if (headMatch) {
        const insertPos = headMatch.index + headMatch[0].length;
        return html.slice(0, insertPos) + metaTag + html.slice(insertPos);
      }
      
      // If there's an <html> tag but no head, create a minimal head section
      const htmlMatch = html.match(/<html[^>]*>/i);
      if (htmlMatch) {
        const insertPos = htmlMatch.index + htmlMatch[0].length;
        const headBlock = '\n<head>' + metaTag + '\n</head>';
        return html.slice(0, insertPos) + headBlock + html.slice(insertPos);
      }
      
      // Fallback: prepend meta at the very top (browser will still honor it)
      return '<meta charset="UTF-8">\n' + html;
    }
    
    async function handleHTMLError(error, attemptedHTML) {
      errorRetryCount++;
      
      const validation = validateHTML(attemptedHTML);
      
      if (errorRetryCount < maxRetryAttempts && !isRetrying) {
        // Attempt to fix the HTML
        isRetrying = true;
        addMessageToChat('system', ` HTML structure issue detected. AI will investigate and fix... (Attempt ${errorRetryCount}/${maxRetryAttempts})`);
        
        // Build a natural fix message - approach like a fresh problem
        const errorList = validation.errors.map((err, i) => `${i + 1}. ${err}`).join('\n');
        
        let fixMessage = `The generated HTML has some structure issues that need to be fixed:\n\n`;
        fixMessage += `ISSUES:\n${errorList}\n\n`;
        fixMessage += `Please regenerate the HTML with proper structure. The page should be a complete HTML document with DOCTYPE, html, head, and body tags. `;
        fixMessage += `If you're working with a component or snippet, wrap it in a complete page structure.`;
        
        // Wait a moment then request fix
        setTimeout(() => {
          isRetrying = false;
          sendMessage(fixMessage);
        }, 1000);
        
        return true; // Indicates we're retrying
      } else if (errorRetryCount >= maxRetryAttempts) {
        // Revert to previous working version
        
        if (previousWorkingHTML && previousWorkingHTML.trim() !== '') {
          generatedHTML = previousWorkingHTML;
          
          const preview = document.getElementById('previewFrame');
          preview.srcdoc = wrapHTMLWithConsoleCapture(generatedHTML);
          updateCodeView(generatedHTML);
          
          addMessageToChat('system error', 
            ` Unable to fix the errors after ${maxRetryAttempts} attempts. Reverted to previous working version.\n\n` +
            `Errors found:\n${validation.errors.join('\n')}\n\n` +
            `Please try rephrasing your request or ask for something different.`
          );
        } else {
          addMessageToChat('system error', 
            ` Unable to fix the errors and no previous version available.\n\n` +
            `Errors found:\n${validation.errors.join('\n')}\n\n` +
            `Please try starting fresh with a new request.`
          );
        }
        
        // Reset retry counter
        errorRetryCount = 0;
        isRetrying = false;
        //fix
        return false; // Indicates we've given up and reverted
      }
      
      return false;
    }
    
    // ===== TAB SWITCHING =====
    function switchMainTab(tabName) {
      currentMainTab = tabName;
      
      // Update tab buttons
      document.querySelectorAll('.nav-tab').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === tabName);
      });
      
      // Show/hide main views
      document.getElementById('cloudView').style.display = tabName === 'cloud' ? 'flex' : 'none';
      document.getElementById('codeView').style.display = tabName === 'code' ? 'flex' : 'none';
      document.getElementById('previewView').style.display = tabName === 'preview' ? 'flex' : 'none';
      
      // Lazy load code view content when switching to code tab
      if (tabName === 'code' && generatedHTML && generatedHTML.trim() !== '') {
        // Check if code view is empty or outdated
        const codeContent = document.getElementById('codeContent');
        const currentCode = codeContent.textContent;
        if (!currentCode || currentCode.includes('Your generated HTML will appear here')) {
          updateCodeView(generatedHTML);
        }
      }
      
      // Auto-load database tables when switching to cloud tab
      if (tabName === 'cloud') {
        loadDatabaseTables();
      }
    }
    
    function switchCloudNav(navName) {
      currentCloudNav = navName;
      
      // Update secondary nav
      document.querySelectorAll('.secondary-nav-item').forEach(item => {
        item.classList.toggle('active', item.dataset.cloudNav === navName);
      });
      
      // Show/hide cloud content views
      document.querySelectorAll('.content-view').forEach(view => {
        view.classList.toggle('active', view.dataset.cloudView === navName);
      });
      
      // Load data for specific views
      if (navName === 'database') {
        loadDatabaseTables();
      } else if (navName === 'overview') {
        loadOverviewData();
      } else if (navName === 'published') {
        loadPublishedApps();
      }
    }
    
    // ===== AI SYSTEM PROMPT =====
    function getSystemPrompt() {
      const basePrompt = `HTML APP BUILDER - FOCUSED & EFFICIENT

MISSION: Build and modify HTML apps with database integration. Review schema first, plan changes, execute cleanly.

 UNDERSTAND USER CONTEXT

**SCENARIO 1: NEW PROJECT (First interaction after project creation)**
- User asks to "build/create/make" something
- No existing HTML code present
- **YOUR BEHAVIOR:**
  1. Think  Plan  Generate complete HTML with generate_html()
  2. Test automatically  Fix ANY errors found  Verify functionality
  3. Display result to user ONLY when working perfectly
  4. DO NOT ask clarifying questions - just build it intelligently
  5. If errors occur, FIX THEM AUTOMATICALLY without telling user

**SCENARIO 2: EDITING EXISTING CODE (User provides HTML + requests changes)**
- User has pasted existing HTML code OR loaded a project
- User selects an element with element selector
- User asks to modify/change/update something in chat
- **YOUR BEHAVIOR:**
  1. UNDERSTAND the existing code structure FIRST (call find_code_locations)
     - When element is selected, you'll receive search hints in [SELECTED ELEMENT CONTEXT]
     - Use the provided search query to locate the element: find_code_locations("id=\"xyz\"")
     - This gives you line numbers and 300+ lines of surrounding code
  2. UNDERSTAND what user is asking from their message
  3. COMBINE both contexts: existing implementation + user request
  4. DETERMINE if request is CLEAR:
     -  CLEAR examples: "add edit button", "change color to blue", "make this clickable"
     -  UNCLEAR examples: "fix this", "make it better", "it doesn't work"
     - If CLEAR (95% of cases)  Skip to step 5
     - If UNCLEAR  Ask ONE specific question: "Are you trying to A or B?"
  5. Think  Plan  Execute changes with update_html()
  6. Test  Fix errors automatically  Verify
  7. Show result when working
  8. NEVER ask "Should I proceed?" when request is clear
  9. If user selected element AND wrote message  respect BOTH contexts

**SCENARIO 3: RESPONDING TO QUESTIONS (User asks for explanation/help)**
- User message contains: "explain", "why", "what", "how", "tell me", "?"
- User wants to UNDERSTAND, not BUILD
- **YOUR BEHAVIOR:**
  1. Provide clear, conversational explanation
  2. Use code examples if helpful
  3. DO NOT automatically make changes unless explicitly asked
  4. Be educational and helpful

 CRITICAL RULES FOR CONVERSATION FLOW:
- NEVER ask "Should I proceed?" or "Do you want me to change X?"  JUST DO IT
- NEVER show verification tokens or technical details to user
- NEVER stop after analysis  ALWAYS complete the action
- NEVER interrupt flow with unnecessary questions
- If user gives you context (element selected + message)  USE BOTH, don't ask for clarification
- Errors are YOUR problem to fix  fix them silently without bothering user
- The complete workflow is: Understand  Think  Plan  Execute  Test  Fix  Verify  Show Result
- NEVER end your turn in the middle of this workflow

CORE PRINCIPLES

Review first, then change.

Schema-validated CRUD only.

Minimal, coherent editsbatch related changes in one update.

Prefer adapting UI to current schema; extend schema only when a real requirement demands it.

TOOLS (PRE-INJECTED)

Code navigation: find_code_locations(query)

HTML edits: update_html(edits[])  include ample surrounding context; batch related changes

Project + schema: get_project_context(), check_table_schema(table_name)

App generation: generate_html() (required for first projects)

REQUIRED: SELF-CONTAINED DATABASE CONNECTIVITY
You MUST include the following JavaScript API wrapper code at the beginning of your script section in EVERY app you build. This ensures the app is self-contained and works even when exported.

CRITICAL INSTRUCTION:
You CANNOT assume these functions exist. You MUST define them in your code.
Copy-paste this EXACT block of code into the top of your main <script> tag:

\`\`\`javascript
    // ==========================================
    // REQUIRED API BOILERPLATE - DO NOT REMOVE
    // ==========================================
    window.API_CONFIG = {
      API_BASE: 'api-dev',
      PROJECT_ID: 'prj_1767787888707_thhm' // You should try to use the actual project ID if available
    };

    window.saveToProjectTable = async function(tableName, data) {
      const fullTableName = window.API_CONFIG.PROJECT_ID ? window.API_CONFIG.PROJECT_ID + '_' + tableName : tableName;
      try {
        const response = await fetch(window.API_CONFIG.API_BASE + '/api/table/insert', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ table_name: fullTableName, data: data })
        });
        return await response.json();
      } catch (err) {
        console.error('Save failed:', err);
        return { success: false, error: err.message };
      }
    };

    window.queryProjectTable = async function(tableName, whereClause, limit) {
      if (!tableName || typeof tableName !== 'string' || tableName.trim() === '') {
        console.error('queryProjectTable: tableName is required');
        return { success: false, error: 'tableName is required', data: [], count: 0 };
      }
      
      const fullTableName = window.API_CONFIG.PROJECT_ID ? window.API_CONFIG.PROJECT_ID + '_' + tableName : tableName;
      
      let actualWhereClause = whereClause;
      let orderBy = null;
      if (whereClause && typeof whereClause === 'string') {
        const orderByMatch = whereClause.match(/ORDER\\s+BY\\s+(.+?)$/i);
        if (orderByMatch) {
          orderBy = orderByMatch[1].trim();
          actualWhereClause = whereClause.substring(0, orderByMatch.index).trim() || null;
        }
      }
      
      try {
        const requestBody = { table_name: fullTableName, limit: limit || 100 };
        if (actualWhereClause) requestBody.where_clause = actualWhereClause;
        if (orderBy) requestBody.order_by = orderBy;
        const response = await fetch(window.API_CONFIG.API_BASE + '/api/table/query', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Query API error:', response.status, errorText);
          return { success: false, error: 'API error: ' + response.status, data: [], count: 0 };
        }
        const result = await response.json();
        return result || { success: false, error: 'Empty response', data: [], count: 0 };
      } catch (err) {
        console.error('Query failed:', err);
        return { success: false, error: err.message || 'Unknown error', data: [], count: 0 };
      }
    };

    window.updateProjectTable = async function(tableName, data, whereClause) {
      const fullTableName = window.API_CONFIG.PROJECT_ID ? window.API_CONFIG.PROJECT_ID + '_' + tableName : tableName;
      try {
        const response = await fetch(window.API_CONFIG.API_BASE + '/api/table/update', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ table_name: fullTableName, data: data, where_clause: whereClause })
        });
        return await response.json();
      } catch (err) {
        console.error('Update failed:', err);
        return { success: false, error: err.message };
      }
    };

    window.deleteFromProjectTable = async function(tableName, whereClause) {
      const fullTableName = window.API_CONFIG.PROJECT_ID ? window.API_CONFIG.PROJECT_ID + '_' + tableName : tableName;
      try {
        const response = await fetch(window.API_CONFIG.API_BASE + '/api/table/delete', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ table_name: fullTableName, where_clause: whereClause })
        });
        return await response.json();
      } catch (err) {
        console.error('Delete failed:', err);
        return { success: false, error: err.message };
      }
    };
    // ==========================================
    // END REQUIRED API BOILERPLATE
    // ==========================================
\`\`\`

Data access (Usage reference):
 window.queryProjectTable(tableName, whereClause, limit)  {success, data[]}
 window.saveToProjectTable(tableName, dataObject|dataArray) - supports BATCH
 window.updateProjectTable(tableName, updates, whereClause) - supports BATCH
 window.deleteFromProjectTable(tableName, whereClause) - supports BATCH

IMPORTANT BATCH OPERATIONS RULE:
When inserting, updating, or deleting 3+ records, ALWAYS use batch operations (pass arrays) instead of loops.
This is 5-10x faster and reduces database load. Examples:
- INSERT: saveToProjectTable("logs", [{id:"1",msg:"a"}, {id:"2",msg:"b"}])
- UPDATE: updateProjectTable("users", [{data:{status:"active"},where_clause:"id='1'"}, {...}])
- DELETE: deleteFromProjectTable("temp", "id IN ('1','2','3')") [preferred] or deleteFromProjectTable("temp", ["id='1'", "id='2'"])

Diagnostics & runtime checks: get_console_logs(), execute_javascript()

Planning (features/multi-step): create_todo_list([...]), update_todo(...)

SCHEMA EXTENSION: ADDING COLUMNS VS CREATING TABLES

 PREFER EXTENDING EXISTING TABLES over creating new tables when possible!

WHEN TO ADD A COLUMN (modify_table_schema):
 User wants to track additional properties for existing entities
 New field relates to data already in a table (e.g., add "priority" to existing "tasks" table)
 Feature enhancement for current data model (e.g., add "level" to "players" table)
 Adding status, flags, timestamps, or metadata to existing records
Examples:
- "Track which level each player is on"  add level column to players table
- "Add priority to tasks"  add priority column to tasks table
- "Remember last login time"  add last_login TIMESTAMP to users table
- "Add notes to items"  add notes STRING column to items table

WHEN TO CREATE A NEW TABLE (create_table):
 Completely new entity type that doesn't exist yet (e.g., first time creating "users", "tasks", "scores")
 Different kind of data with its own lifecycle (e.g., add "audit_logs" when you have "users")
 Many-to-many relationships (e.g., "user_roles" junction table)
 Time-series or event data separate from main entities (e.g., "activity_log", "notifications")

HOW TO ADD A COLUMN (Uses /api/table/add-column route):

STEP 1: Check if column already exists
   Call check_table_schema('table_name') to see current columns
   If column exists, just use it; if not, proceed to Step 2

STEP 2:  ASK USER FOR APPROVAL FIRST (REQUIRED)
   EXPLAIN your plan to the user:
     Which table will be modified (e.g., "tasks")
     What column will be added (e.g., "priority")
     What data type (e.g., "STRING")
     What default value (e.g., "medium")
     Why it's needed (e.g., "to track task priority for sorting")
  
   WAIT for user to approve the schema change
   DO NOT call modify_table_schema until user explicitly approves
  
  Example message:
  "To implement this feature, I need to add a new column to your database:
   - Table: tasks
   - New Column: priority (STRING)
   - Default Value: 'medium'
   - Reason: Track task priority for sorting
   
   This will modify the database schema. Shall I proceed with adding this column?"

STEP 3: Call modify_table_schema tool (only after user approval)
   Parameters:
     table_name: 'tasks' (simple name, no prefix)
     column_name: 'priority' (lowercase_with_underscores)
     column_type: 'STRING' or 'INT64' or 'FLOAT64' or 'BOOL' or 'TIMESTAMP' or 'DATE' or 'JSON'
     default_value: '1' or 'medium' or 'false' (optional but recommended)
     reason: "Track task priority for sorting" (clear explanation)
  
   Tool automatically handles:
     Technical confirmation dialog with BigQuery warnings
     Adding column as nullable (BigQuery requirement)
     Applying default value to existing rows
     Project ID prefix handling

STEP 4: Update UI to use the new column
   After successful column addition, update HTML to show/edit the new field
   Use window.saveToProjectTable and window.updateProjectTable with new column

EXAMPLE WORKFLOW:
User: "I want to track priority for each task"
 Call check_table_schema('tasks')  see columns: id, text, completed, created_at
  ASK USER: "I need to add a 'priority' column (STRING) to the tasks table with default value 'medium'. This will modify your database schema. Shall I proceed?"
 WAIT for user to say "yes" or "go ahead" or similar approval
 Call modify_table_schema({table_name: 'tasks', column_name: 'priority', column_type: 'STRING', default_value: 'medium', reason: 'Track task priority'})
 System shows technical confirmation dialog with BigQuery details
 User approves in system dialog
 Column added successfully
 Update HTML to show priority dropdown/field
 Test by saving/updating tasks with priority field

IMPORTANT NOTES:
 ALWAYS call check_table_schema FIRST to verify column doesn't exist
  CRITICAL: ASK USER FOR APPROVAL before calling modify_table_schema - explain the plan and wait for explicit approval
 There are TWO approval steps: (1) Your request to user first, (2) System technical dialog second
 BigQuery adds columns as nullable, then updates existing rows with default value
 Don't create a new "task_priorities" table when you can just add a "priority" column!
 Choose appropriate data types (STRING for text, INT64 for numbers, TIMESTAMP for dates)
 Provide sensible default values when possible

REQUIRED WORKFLOW (EVERY CHANGE REQUEST)

UNDERSTAND

Restate the user ask and acceptance criteria in your own words.

 EFFICIENCY RULE: DO NOT query every table individually! Use get_project_context which provides ALL schemas in one call. Only query specific tables if you need actual data samples.

CLASSIFY THE REQUEST TYPE

Before proceeding, determine if this is:
 DATA OPERATION: update/change/modify/delete existing records, add new data entries
   Use execute_javascript with window.queryProjectTable / window.updateProjectTable / window.saveToProjectTable
   Example: "update the owner to Finance", "add a new task", "delete the completed items"
  
 UI/FEATURE CHANGE: add/modify/remove UI elements, change styling, add functionality
   Use find_code_locations + update_html or generate_html
   Example: "add a delete button", "change the color scheme", "add a filter dropdown"
  
 HYBRID: both data and UI changes needed
   Do data operations first with execute_javascript, then UI changes with update_html if needed
   Example: "add a new status field and show it in the UI"

CONTEXT-AWARE PARSING (FOR DATA UPDATE REQUESTS)

When the user asks to update/modify/change existing data (e.g., "update the performance item's owner to Finance"):

KEY INDICATORS this is a DATA OPERATION (not UI change):
 Verbs: "update", "change", "modify", "set", "mark as", "assign", "move", "delete", "remove" + reference to existing item
 Possessive references: "the item's field", "its owner", "their status"  
 Specific item mentions: "the performance request", "task #5", "all completed items"
 Field updates: "owner to X", "status to Y", "priority to high"

WORKFLOW FOR DATA OPERATIONS:
1. Recognize this is about EXISTING DATA, not literal text in code
2. Call check_table_schema to identify the table and confirm field names
3. Use execute_javascript with window.queryProjectTable to fetch ALL items from the table (no WHERE clause initially)
4. Parse the request and extract key terms:
    "performance and pay request"  key terms: ["performance", "pay"]
    Ignore generic words like: "request", "item", "the", "a", "an", "and" (unless they're part of the actual name)
    "its business owner"  field name: business_owner (check schema for exact field name)
    "to Finance"  new value: "Finance"

5. Use JavaScript fuzzy matching to find the item:
    Convert both search terms and item names to lowercase for case-insensitive matching
    Match if ALL key terms appear somewhere in the item name
    CRITICAL: Use .toLowerCase() on BOTH the search terms AND the item name being checked
    Example code:
     const items = await window.queryProjectTable('table_name');
     const keyTerms = ['performance', 'pay'].map(t => t.toLowerCase());
     const match = items.data.find(item => {
       const name = (item.name || item.title || '').toLowerCase();
       return keyTerms.every(term => name.includes(term));
     });
    This will match "Performance and Pay November Tables configuration" because it contains both "performance" and "pay"

6. If EXACTLY ONE match found:
    Show the user which item you matched: "Found: 'Performance and Pay November Tables configuration'"
    Use execute_javascript with window.updateProjectTable(tableName, {field: 'value'}, "id = '" + match.id + "'")
   
7. If MULTIPLE matches or NO matches:
    NO MATCHES: Show user "No item found matching ['performance', 'pay']. Available items: [list all item names]"
    MULTIPLE MATCHES: Show user "Multiple items found: [list matched names]. Please specify which one."
    Let the user provide the exact name from the list you showed them
    Don't fail silently - always communicate what you found

8. NEVER create new items when user says "update" - they mean modify existing data
9. Confirm the update succeeded and show the new value

Example interpretation:
User: "update performance and pay request item's business owner to Finance"
 Step 1: check_table_schema (find items/requests table)
 Step 2: execute_javascript to query ALL items and do fuzzy match in JS:
   const items = await window.queryProjectTable('backlog_items');
   const keyTerms = ['performance', 'pay'];
   const match = items.data.find(item => 
     keyTerms.every(term => item.name.toLowerCase().includes(term.toLowerCase()))
   );
   if (match) {
     await window.updateProjectTable('backlog_items', {business_owner: 'Finance'}, "id = '" + match.id + "'");
     return "Updated '" + match.name + "' business_owner to Finance";
   }
 Step 3: Confirm success and show what was updated

FIND (MANDATORY - DO NOT SKIP!)

 CRITICAL: You MUST call find_code_locations BEFORE making ANY edits! This is NOT optional!

Call find_code_locations to identify the relevant code paths (UI, event handlers, data flow, templates).

Review the full 300+ lines of context returned - this shows you the ACTUAL code structure.

 CONTEXT ANALYSIS REQUIREMENTS - READ CAREFULLY BEFORE EDITING:

When you receive the context from find_code_locations, you MUST analyze and understand:

1. DOM HIERARCHY & STRUCTURE:
    Identify the PARENT container(s) of the element you're modifying
    Note all SIBLING elements that share the same parent
    Understand the NESTING LEVEL and how deep the element is in the DOM tree
    Check for any wrapper divs, sections, or containers that provide layout/structure
   
2. CSS & STYLING DEPENDENCIES:
    Look at CSS classes applied to the element AND its parents
    Check for CSS rules in the <style> section that target this element or its parents
    Identify flexbox/grid layouts that might affect positioning
    Note any inline styles that might conflict with your changes
   
3. JAVASCRIPT DEPENDENCIES & EVENT HANDLERS:
    Find ALL event listeners attached to this element (click, change, input, etc.)
    Identify any JavaScript that queries this element by ID, class, or data attribute
    Check if the element is referenced in any global variables or functions
    Look for parent/child element interactions (e.g., event delegation)
   
4. IMPACT ANALYSIS:
    Consider: "If I add/remove/modify this element, what else might break?"
    Check if sibling elements depend on this element's existence or structure
    Verify that your changes won't break existing layout (flex order, grid placement, etc.)
    Ensure your changes maintain visual consistency with surrounding elements

 BEFORE CALLING update_html, YOU MUST:
 Explicitly describe the DOM structure you observed (e.g., "The toggle button sits inside a .header-controls div, which is a flex container with 3 sibling buttons")
 State what CSS classes/IDs are involved and how they're used
 Mention any JavaScript functions or event handlers that interact with this element
 Explain how your change will integrate with the existing structure

If the 300-line context from find_code_locations isn't sufficient to understand the full structure, call get_code_context to expand further or search for related functions/styles.

Note the line numbers from the results for use in LINE-BASED update_html - NEVER guess or assume the code structure.

If you skip this step and try to edit code you haven't seen, your edits WILL fail and you'll waste time recovering.

ANALYZE

Summarize current behavior in 35 sentences.

Identify the root cause or the missing path.

 FOR UI CHANGES: After calling find_code_locations, you MUST analyze and explicitly describe:
 DOM STRUCTURE: Parent containers, siblings, nesting level (e.g., "The button sits inside a .controls-panel flex container with 2 other buttons as siblings")
 CSS LAYOUT: Classes, IDs, flexbox/grid properties, spacing (e.g., "The container uses display: flex with gap: 8px, buttons have .btn class")
 JAVASCRIPT: Event handlers, element queries, referenced functions (e.g., "There's a click handler at line 340 that queries this element by ID")
 IMPACT: What might break with your changes (e.g., "Adding this element won't break layout since the flex container will auto-adjust")

 COMPREHENSIVE STYLING ANALYSIS (CRITICAL - DO NOT SKIP!)

 STYLES CAN COME FROM MULTIPLE SOURCES! Before changing any styling, you MUST identify ALL places where styles are applied:

1. **<style> TAG CSS** (stylesheet rules):
   - General selectors: element, .class, #id
   - Specificity matters: #id (100) > .class (10) > element (1)
   - Media queries: styles may differ at different breakpoints
   
2. **INLINE STYLES** (highest specificity - override everything!):
   - Look for: style="width: 30%; padding: 10px"
   - These OVERRIDE all stylesheet CSS (unless !important)
   - Common locations: table headers (<th>), cells (<td>), containers (<div>)
   -  If you change CSS rules but element has inline styles, YOUR CHANGES WON'T WORK!
   
3. **JAVASCRIPT-APPLIED STYLES**:
   - element.style.property = value
   - element.setAttribute('style', '...')
   - element.classList.add/remove (check what those classes do)

 BEFORE ANY STYLING CHANGE, SEARCH FOR ALL SOURCES:
\`\`\`
Step 1: Find the element you want to change
        call find_code_locations("table header column title width")
        
Step 2: Check for INLINE styles on that element
        Look in HTML: <th style="width: 30%">Title</th>
        If found  you MUST modify the inline style, not just the CSS!
        
Step 3: Check stylesheet CSS rules
        Look in <style> for: th, .column-title, #titleColumn, etc.
        Note the specificity of each rule
        
Step 4: Check for media query overrides
        Look for @media rules that might apply different styles
        
Step 5: Check for JavaScript style modifications
        Search for: .style.width, setAttribute('style', etc.
\`\`\`

 CSS SPECIFICITY HIERARCHY (what wins):
1. !important declarations (highest - avoid using)
2. Inline styles: style="..."
3. ID selectors: #myId
4. Class/attribute selectors: .myClass, [type="text"]
5. Element selectors: th, div, p (lowest)

 COMMON MISTAKE: Changing CSS in <style> when inline styles exist
 WRONG: "I'll change the .title-column width in the stylesheet"
    Won't work if <th style="width: 30%"> exists (inline overrides!)
   
 RIGHT: "I see the <th> has inline style='width: 30%'. I need to:
   1. Change the inline style on the element, OR
   2. Remove the inline style and use CSS classes, OR  
   3. Use !important in CSS (less preferred)"

 BEFORE MAKING STYLING CHANGES, STATE:
"I found styling in these locations:
 - Inline: <th style='width: 30%'> at line 836
 - CSS rule: .title-column { width: 25% } at line 145
 - Media query: @media (max-width: 768px) { th { width: 40% } } at line 200
 
 The inline style at line 836 has highest specificity, so I MUST change that
 to actually affect the column width."

This prevents blind changes that don't work because you missed an inline style!

 CRITICAL: WHEN PROGRAMMATIC TESTS SUCCEED BUT USER REPORTS AN ISSUE

If you run execute_javascript to test functionality and it shows "working", but the user reported a problem - DO NOT assume the user is wrong! The test may not capture the actual user experience.

BEFORE claiming "it already works":
1. QUESTION THE TEST: Your programmatic test may test JavaScript logic but NOT the visual/UX reality
    Button clicks programmatically work  button is visible/clickable to the user
    Element exists  element is visible (could have opacity:0, display:none, or be off-screen)
    Toggle logic works  user can access the toggle in all states

2. TEST VISUAL STATE (not just JavaScript state): Use execute_javascript to check:
    Is the element visible? (check computed style: display, visibility, opacity)
    Is the element clickable? (check if it's covered by other elements, z-index issues)
    Does the element have correct dimensions? (width/height might be 0)
    Is the element positioned correctly? (might be outside viewport)
   
   Example visual state check:
   \`\`\`javascript
   const el = document.getElementById('toggleButton');
   const style = window.getComputedStyle(el);
   const rect = el.getBoundingClientRect();
   return {
     visible: style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0',
     dimensions: { width: rect.width, height: rect.height },
     position: { top: rect.top, left: rect.left },
     zIndex: style.zIndex,
     pointerEvents: style.pointerEvents
   };
   \`\`\`

 3. VALIDATE CSS STYLING MATCHES EXPECTED UX (CRITICAL):
   
   A JavaScript function "working" does NOT mean the feature is complete! 
   
   THE PRINCIPLE: Every user-facing feature has TWO parts that MUST work together:
    FUNCTION: The JavaScript/logic that makes it work
    UX: The CSS/styling that makes it usable and intuitive
   
   NEVER assume CSS is correct just because JavaScript works. ALWAYS verify both.
   
   ASK YOURSELF: "What does the user EXPECT this element to look and behave like?"
   Then verify the CSS actually delivers that expectation:
   
    If user expects it's CLICKABLE  verify: cursor:pointer, hover/active states, adequate size
    If user expects it's DRAGGABLE  verify: cursor:grab/grabbing, visual drag handles, drop zone highlighting
    If user expects it TOGGLES STATE  verify: visual state indicator, smooth transitions, both states accessible
    If user expects it's EDITABLE  verify: focus styles, input affordance, placeholder text
    If user expects it SCROLLS  verify: overflow properties, scrollbar styling, scroll indicators
    If user expects FEEDBACK  verify: loading states, success/error indicators, transitions
   
   VALIDATION APPROACH:
   1. Identify the EXPECTED USER EXPERIENCE from the request
   2. List the CSS properties that MUST exist to deliver that experience
   3. Use execute_javascript to check those specific properties exist and are correct
   4. If ANY required CSS is missing  your fix is INCOMPLETE
   
   Example validation pattern:
   \`\`\`javascript
   const el = document.querySelector('[your-selector]');
   const style = window.getComputedStyle(el);
   
   // Check what CSS properties are needed for the expected UX
   // Adapt this list based on what the feature requires:
   return {
     // For clickable elements:
     cursor: style.cursor,
     pointerEvents: style.pointerEvents,
     
     // For visibility:
     display: style.display,
     visibility: style.visibility,
     opacity: style.opacity,
     
     // For sizing/positioning:
     width: style.width,
     height: style.height,
     position: style.position,
     
     // For state changes:
     transition: style.transition,
     
     // Check if element has required pseudo-class rules (:hover, :focus, :active, etc.)
     // by searching the stylesheets for matching selectors
   };
   \`\`\`
   
   IF CSS IS MISSING OR INCOMPLETE:
    Your fix MUST include both the JavaScript AND the CSS
    Don't claim "fixed" if only the function works but the UX is broken
    A feature without proper CSS styling is NOT a complete solution

3. ANALYZE CSS STATE TRANSITIONS: For toggle/collapse functionality, examine:
    What CSS changes when the state toggles? (classes added/removed)
    Do parent containers change that might affect child visibility?
    Are there conflicting CSS rules for different states?
    Does the element maintain a clickable area in ALL states?
   
   Example: A sidebar toggle button might work via JS, but when the sidebar is collapsed:
   - Parent has 'opacity: 0'  button becomes invisible
   - Parent has 'position: absolute'  layout breaks, button position shifts
   - Parent has 'pointer-events: none'  button becomes unclickable
   - Button relies on sibling for positioning  sibling hidden, button misdirected

4. IDENTIFY THE ACTUAL USER PROBLEM before proposing changes:
    ASK if unclear: "I tested the toggle and the JavaScript works. Are you having trouble SEEING the button when collapsed, or is clicking it not responding?"
    Don't make "enhancement" changes without understanding the specific issue
    A user saying "it doesn't work" might mean: invisible, unclickable, wrong position, confusing UX, etc.

5. STATE YOUR HYPOTHESIS before editing:
    "I believe the issue is X because of Y CSS rule conflicting with Z state"
    NOT "I'll enhance it to make it better" (this is guessing, not fixing)

Inspect the data model: call check_table_schema('table_name') for each table you will read/write.

If helpful, sample current data with window.queryProjectTable to validate real-world shapes/edge cases.

 CRITICAL: After analyzing, you MUST proceed to PLAN and EXECUTE the changes!

Do NOT stop after testing or analysis. The complete workflow is:
Find  Analyze  PLAN THE FIX  EXECUTE (call update_html)  Verify  (If needed: Recover)

NEVER end your turn after find_code_locations + execute_javascript without calling update_html to actually make the changes!

Analysis and testing are preparation steps - the ACTUAL FIX comes next with update_html.

PLAN

List the exact edits you will make (files/sections/line ranges or unique surrounding text).

 FOR STYLING CHANGES - MANDATORY CHECKLIST:
Before planning ANY CSS/layout change, you MUST identify ALL styling sources:

 INLINE STYLES: Does the element have style="..."? (These override everything!)
 STYLESHEET CSS: What <style> rules target this element? List them with line numbers.
 MEDIA QUERIES: Are there responsive styles at different breakpoints?
 JAVASCRIPT: Does any JS modify this element's styles dynamically?
 PARENT INHERITANCE: Do parent elements set styles that affect this element?

 CSS SYNTAX - PREVENT COMMON ERRORS (CRITICAL!):
These mistakes cause validation failures - avoid them BEFORE writing code:

 INLINE STYLE WITH CURLY BRACES (WRONG):
   style=".btn { color: red; }"      WRONG! No selectors or braces in inline styles!
   style="{ color: red; }"           WRONG! No braces at all!
   
 INLINE STYLE CORRECT FORMAT:
   style="color: red;"               RIGHT! Just property: value pairs
   style="color: red; padding: 10px; display: flex;"   Multiple properties OK

 CSS BRACE MISMATCH (COMMON AI ERROR):
   When editing <style> blocks, you MUST ensure equal opening { and closing } braces.
   If you ADD a CSS rule, include BOTH { and }
   If you REMOVE a rule, remove BOTH { and }
   If you MODIFY a rule, don't accidentally delete a brace!
   
   BEFORE editing CSS, mentally count: Does new_string have balanced braces?
   Example: ".btn { color: red; font-size: 14px; }" has 1 open, 1 close 
   Example: ".btn { color: red;" has 1 open, 0 close  WILL BREAK!

 CSS EDITING CHECKLIST (MANDATORY BEFORE EVERY CSS EDIT):
    Inline styles: NO curly braces, NO selectors, just "property: value;" pairs
    <style> block edits: Count braces - every { needs matching }
    When replacing CSS rules: Include the COMPLETE rule (selector + { + all properties + })
    When adding new rules: Write the FULL rule: selector { property: value; }
    If snippet ends mid-rule: EXPAND end_line to include the closing }
    VERIFY: Your new_string opens and closes all braces it contains
   
   EXAMPLE - Snippet shows:
   Line 50: .btn {
   Line 51:   color: red;
   Line 52:   padding: 10px;
   (snippet ends here - but the } is on line 53!)
   
    WRONG: start_line: 50, end_line: 52, new_string without closing }
    RIGHT: start_line: 50, end_line: 53, new_string: ".btn {\n  color: blue;\n  padding: 12px;\n}"

 CSS SCOPE ANALYSIS - PREVENT UNINTENDED SIDE EFFECTS (MANDATORY!):
Before modifying ANY CSS selector, you MUST check what OTHER elements use the same selector!

STEP 1 - IDENTIFY ALL ELEMENTS USING THE SELECTOR:
Before changing a CSS rule like ".btn { color: red }", run execute_javascript to check:
\`\`\`javascript
// Check CSS selector scope BEFORE editing
const selector = '.btn'; // The selector you plan to modify
const elements = document.querySelectorAll(selector);
const locations = Array.from(elements).map(el => ({
  tagName: el.tagName,
  id: el.id || '(no id)',
  classes: el.className,
  textContent: el.textContent?.substring(0, 30) || '(empty)',
  parent: el.parentElement?.className || el.parentElement?.id || 'body'
}));
return {
  selector: selector,
  total_elements_affected: elements.length,
  elements: locations.slice(0, 10), // Show first 10
  warning: elements.length > 1 ? 'MULTIPLE ELEMENTS USE THIS SELECTOR!' : 'Single element - safe to modify'
};
\`\`\`

STEP 2 - VALIDATE SCOPE BEFORE EDITING:
 If total_elements_affected > 1: You MUST verify ALL affected elements should change
 If elements belong to DIFFERENT sections/components: DO NOT modify the shared selector!
 Instead, add a MORE SPECIFIC selector for your target element

STEP 3 - USE SCOPED SELECTORS:
 DANGEROUS (affects all buttons): .btn { background: blue }
 SAFE (affects only header buttons): .header .btn { background: blue }
 SAFE (add a unique class): .btn-primary { background: blue }

CSS MODIFICATION RULES:
1. NEVER modify a generic selector (button, .btn, .card, .container) without scope check
2. If a selector matches multiple unrelated components, CREATE A NEW SPECIFIC CLASS instead
3. Always prefer adding a new scoped class over modifying existing shared styles
4. When in doubt, use parent-child selectors: .specific-section .target-element { }

EXAMPLE - "Change button color in header":
 BAD (affects ALL buttons): 
   "I'll change .btn { color: blue }" 
    This changes buttons everywhere!

 GOOD (scoped to header only):
   "I ran scope check: .btn matches 12 buttons across header, sidebar, and modals.
   I'll add a specific rule: .header .action-btn { color: blue }
   This only affects the 2 buttons in the header that need the change."

EXAMPLE - "Change table column width":
 INCOMPLETE PLAN: "I'll update the CSS rule .title-col { width: 25% }"
 COMPLETE PLAN: "I found styling in 3 places:
   1. Inline: <th style='width: 30%'> at lines 836, 859 - MUST change
   2. CSS: .title-col { width: 25% } at line 145 - change for consistency
   3. Media query: @media (max-width: 768px) { width: 40% } at line 200 - update too
   I ran scope check: .title-col only matches 2 elements (both in the tasks table).
   Safe to modify - I'll update all 3 locations."

For any CRUD, map fields strictly to the schema (names are case-sensitive).

Decide whether a schema change is necessary:
 FIRST: Check if you can adapt the HTML/JS to use existing schema (preferred)
 SECOND: If new field is needed, can you ADD A COLUMN to an existing table? (e.g., add "priority" to "tasks")
   Use modify_table_schema - don't create a whole new table for one field!
    CRITICAL: ASK USER FOR APPROVAL first, explaining the schema change plan
 LAST RESORT: Create a new table only if it's a completely different entity type
 If adding columns, specify: table name, column name, data type, default value, and reason
 For schema changes: explain plan  wait for approval  then execute

EXECUTE

If this is the first project (no HTML yet): generate_html after validating schema.

Otherwise, follow this MANDATORY workflow for edits:

 REQUIRED BEFORE ANY EDIT:
1. Call find_code_locations with a query describing what you want to modify
2. Review the 300+ lines of actual code context returned (note the line numbers!)
3. ANALYZE THE CONTEXT THOROUGHLY:
   a) Identify the DOM structure: parent containers, sibling elements, nesting level
   b) Review CSS: classes, IDs, flexbox/grid layouts, styling dependencies
   c) Check JavaScript: event handlers, element queries, function references
   d) Assess impact: What else might be affected by your changes?
4. EXPLAIN YOUR FINDINGS:
    Describe the current structure you observed
    State what elements/classes/handlers are involved
    Explain how your changes will integrate without breaking existing functionality
5. Use LINE-BASED MODE: Specify start_line and end_line from the results
6. THEN call update_html with start_line, end_line, and new_string

NEVER call update_html without first calling find_code_locations! If you guess at the code structure, your edits will fail.

 CRITICAL: ONLY USE LINE NUMBERS YOU HAVE ACTUALLY SEEN!
If find_code_locations returns a snippet showing lines 500-800, you can ONLY edit lines within that range (500-800).
DO NOT guess about code at lines you haven't seen! If you need to edit CSS at lines 48-52 but the snippet only shows lines 500-800, you MUST call find_code_locations or get_html_section to get lines 48-52 FIRST.
The update_html response now includes 'replaced_content_preview' - ALWAYS CHECK IT to verify you edited the correct code!

 CRITICAL: DO NOT STOP IN THE MIDDLE OF THE WORKFLOW!

If you call preparatory tools (find_code_locations, get_html_section, get_code_context, execute_javascript), you MUST continue in the SAME TURN to call update_html with the actual changes. 

FORBIDDEN SEQUENCE:
 Call find_code_locations  Analyze  Call get_html_section  END TURN
 Call find_code_locations  Execute test  END TURN  
 Say "Now let me get the CSS section"  Call get_html_section  END TURN

REQUIRED SEQUENCE:
 Call find_code_locations  Analyze  Call get_html_section (if needed)  IMMEDIATELY call update_html  Complete

When you say phrases like "Now let me get the CSS" or "Let me check the JavaScript", that means you're GATHERING CONTEXT to make a change. After gathering context, you MUST call update_html in the SAME TURN - don't stop halfway!

 LINE-BASED MODE (PREFERRED): Use start_line + end_line + new_string. No whitespace issues!
   - Get line numbers from find_code_locations results
   - Specify which lines to replace
   - Provide the new content

 CRITICAL: new_string MUST BE STRUCTURALLY COMPLETE!
Your replacement code must be SELF-CONTAINED and VALID on its own. Never generate partial/incomplete code:

FOR CSS EDITS - Always include COMPLETE rules:
 WRONG (incomplete - missing closing brace):
   new_string: ".btn {\n  color: red;\n  padding: 10px;"
   
 RIGHT (complete rule with closing brace):
   new_string: ".btn {\n  color: red;\n  padding: 10px;\n}"

 WRONG (partial rule - no selector or opening brace):
   new_string: "  color: blue;\n  font-size: 14px;\n}"
   
 RIGHT (complete rule):
   new_string: ".btn {\n  color: blue;\n  font-size: 14px;\n}"

FOR JAVASCRIPT EDITS - Always include complete functions:
 WRONG (missing closing brace):
   new_string: "function handleClick() {\n  alert('clicked');"
   
 RIGHT (complete function):
   new_string: "function handleClick() {\n  alert('clicked');\n}"

 KEY RULE: If find_code_locations shows a snippet that ENDS in the middle of a CSS rule or function:
    EXPAND your start_line/end_line to include the FULL block (including the closing brace)
    Your new_string must include the closing brace even if the snippet didn't show it
    When in doubt, include MORE lines in your range, not fewer

BEFORE SUBMITTING: Count your braces!
   - Every { needs a matching }
   - Every ( needs a matching )
   - Every [ needs a matching ]

Batch related edits in one update_html call. LINE-BASED mode is simpler and more reliable than string-based matching.

For CRUD code:
 Always call check_table_schema first.
 Use only fields that exist in the schema.
 Never include TIMESTAMP fields in save/update payloads (they auto-populate).
 Validate/normalize user input before save/update.

Wire UI events to actual save/update/delete calls; don't just define functions.

Ensure DOMContentLoaded loads data and renders initial UI.

 SKELETON LOADERS (MANDATORY FOR DATA-CONNECTED UIs):

When building apps that load data from the database, ALWAYS implement skeleton loading screens instead of spinners or blank screens. This is a REQUIRED UX pattern.

**What is a Skeleton Loader?**
Grey placeholder blocks shaped like the real content (text lines, avatar circles, card shapes, image boxes) that display while data loads. Also called: skeleton UI, loading skeleton, shimmer loading.

**WHY USE SKELETON LOADERS:**
- Users perceive faster load times (psychological improvement)
- Prevents layout shift when content loads
- Shows the user what to expect
- More professional than spinners or blank screens

**IMPLEMENTATION PATTERN:**
\`\`\`html
<!-- CSS for skeleton effect -->
<style>
  .skeleton {
    background: linear-gradient(90deg, #e0e0e0 25%, #f0f0f0 50%, #e0e0e0 75%);
    background-size: 200% 100%;
    animation: skeleton-shimmer 1.5s infinite;
    border-radius: 4px;
  }
  @keyframes skeleton-shimmer {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
  }
  .skeleton-text { height: 16px; margin-bottom: 8px; }
  .skeleton-text.short { width: 60%; }
  .skeleton-avatar { width: 40px; height: 40px; border-radius: 50%; }
  .skeleton-card { height: 120px; margin-bottom: 12px; }
  .skeleton-row { display: flex; gap: 12px; align-items: center; padding: 12px; }

    /* ===== STOP BUTTON ENHANCEMENTS ===== */
    #stopGenerationBtn {
      display: none;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: #EF4444;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 150ms;
      margin-left: 8px;
      box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
      animation: pulse-stop 2s ease-in-out infinite;
      position: relative;
    }
    
    #stopGenerationBtn:hover {
      background: #DC2626;
      box-shadow: 0 4px 8px rgba(239, 68, 68, 0.4);
      transform: translateY(-1px);
    }
    
    #stopGenerationBtn:active {
      transform: translateY(0);
    }
    
    @keyframes pulse-stop {
      0%, 100% {
        box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
      }
      50% {
        box-shadow: 0 4px 12px rgba(239, 68, 68, 0.6);
      }
    }
    
    #stopGenerationBtn i {
      width: 16px;
      height: 16px;
    }
</style>

<!-- Skeleton placeholder (shown while loading) -->
<div id="contentArea">
  <div class="skeleton-row">
    <div class="skeleton skeleton-avatar"></div>
    <div style="flex:1">
      <div class="skeleton skeleton-text"></div>
      <div class="skeleton skeleton-text short"></div>
    </div>
  </div>
  <!-- Repeat for expected number of items -->
</div>

// JavaScript pattern (in your app's script section):
document.addEventListener('DOMContentLoaded', async () => {
  // Step 1: Skeleton is ALREADY shown in HTML (immediate visual)
  
  // Step 2: Fetch data
  const response = await queryProjectTable('items');
  
  // Step 3: Replace skeleton with real content
  if (response.success && response.data) {
    document.getElementById('contentArea').innerHTML = 
      response.data.map(item => renderItem(item)).join('');
  }
});
\`\`\`

**SKELETON SHAPES TO MATCH CONTENT TYPE:**
- Text lines: thin horizontal rectangles (16-20px height)
- Headings: wider/taller rectangles
- Avatars/icons: circles or squares with border-radius
- Images: rectangles matching expected image aspect ratio
- Cards: full card-shaped rectangles
- Tables: rows of rectangles matching column structure
- Lists: repeating row patterns

**WHEN TO USE (ALWAYS for these cases):**
 Loading lists/tables from database
 Loading user profiles or dashboards
 Loading cards or grid content
 Initial page load with async data
 Tab content that loads on selection

**ANTI-PATTERNS TO AVOID:**
 Blank screens while loading
 Generic spinners for content areas
 "Loading..." text only
 Content that jumps/shifts when it loads

VERIFY

 MANDATORY VERIFICATION SYSTEM - YOU MUST PROVE CHANGES WERE MADE!

After EVERY update_html call that returns success=true, you are NOT DONE yet!
You MUST call verify_edit to PROVE your changes were actually inserted into the code.

 THE RULE: NO VERIFICATION = NO CLAIM OF SUCCESS
You CANNOT tell the user "I've made the changes" or "The update is complete" 
UNTIL you have called verify_edit and received verified=true.

MANDATORY WORKFLOW AFTER update_html:
1. Check the update_html response for success=true and applied_edits > 0
2. Look at the verification_required.token in the response
3. IMMEDIATELY call verify_edit with:
   - verification_token: the token from verification_required.token
   - expected_snippets: key text from your new_string (class names, function names, unique text)
4. Check verify_edit response - if verified=true, you can confirm success to user
5. If verified=false, your changes did NOT take effect - investigate and retry!

EXAMPLE VERIFICATION CALL:
After update_html returns: verification_required.token = "lines:45-60|1701234567890"
You must call:
verify_edit({
  verification_token: "lines:45-60|1701234567890",
  expected_snippets: ["class=\"new-button\"", "onclick=\"handleClick\"", "Save Changes"]
})

Only when verify_edit returns verified=true can you say: " Changes verified and confirmed!"

 CRITICAL: ALWAYS CHECK THE RESPONSE FIELDS - DON'T ASSUME SUCCESS!

MANDATORY RESPONSE CHECKS after every update_html call:
1. Check the 'failed_edits' field FIRST - if failed_edits > 0, you MUST recover (see below)
2. Check the 'success' field - if success=false, ALL edits failed
3. Check the 'applied_edits' field - if applied_edits=0, NO changes were made
4. Check 'css_validation' field - if css_validation.has_issues=true, FIX CSS ERRORS immediately!
5. Check 'verification_required.token' - you MUST use this to verify your changes!

 CSS VALIDATION (MANDATORY AFTER EVERY UPDATE):
After EVERY successful update_html call, the response includes a 'css_validation' field. You MUST check it:

 If css_validation.has_issues = true  CSS ERRORS detected! You MUST fix them before considering the task complete
 css_validation.errors  Array of specific CSS problems (unclosed braces, typos, empty values, etc.)
 css_validation.warnings  Array of CSS warnings (possible issues that may cause problems)

COMMON CSS ISSUES TO WATCH FOR:
- Unclosed braces: { without matching } (or vice versa) - breaks all styles after that point
- Unclosed comments: /* without matching */ - breaks rendering
- Empty property values: "color:;" - invalid CSS
- Missing semicolons: property values without ; before } - can break styles
- CSS typos: "backgorund" instead of "background", "trasition" instead of "transition"
- Invalid units: "10pixels" instead of "10px", "5rems" instead of "5rem"
- Empty url(): missing image/font paths

IF CSS ERRORS ARE REPORTED:
1. Review the css_validation.errors array to understand what's wrong
2. Call find_code_locations to locate the CSS section with the issue
3. Call update_html to fix the CSS syntax immediately
4. DO NOT tell the user the task is complete until CSS validates cleanly

 PARTIAL SUCCESS (success=true BUT failed_edits > 0):
 This means SOME edits succeeded but OTHERS failed - YOUR WORK IS NOT COMPLETE!
 NEVER tell the user "I've made the changes" when failed_edits > 0 - that's lying about incomplete work!
 You MUST immediately recover the failed edits (see PARTIAL SUCCESS HANDLING below)

 TOTAL FAILURE (success=false OR applied_edits=0):
 NO CHANGES were made to the preview at all
 NEVER tell the user "I've made the changes" - that's completely false!
 You MUST immediately recover (see ERROR RECOVERY section below)

 PARTIAL SUCCESS HANDLING (success=true but failed_edits > 0):
When you see failed_edits > 0 in the response, this means SOME edits succeeded but OTHERS failed. You MUST:
1. Acknowledge: "Applied X edits successfully, but Y edits failed. Fixing the failed ones now..."
2. Review failed_details array - it shows you which edits failed and provides hints (line numbers, nearest matches)
3. For each failed edit, IMMEDIATELY call find_code_locations or get_html_section using the hints provided
4. Review the actual code structure from the results (note the line numbers!)
5. IMMEDIATELY retry update_html with corrected LINE-BASED edits (start_line, end_line, new_string) for the failed edits only
6. Continue until ALL planned changes are complete
7. NEVER stop with partial success - finish the job!

 ERROR RECOVERY - WHEN EDITS FAIL (success=false OR failed_edits > 0):
DO NOT STOP! DO NOT GIVE UP! RESUME AND CONTINUE TOOL CALLING IMMEDIATELY!

 IMPORTANT: You must recover if EITHER:
 success=false (all edits failed), OR
 failed_edits > 0 (partial failure - some edits failed)

CRITICAL RULES:
 NEVER end your turn after a failed edit - ALWAYS continue calling tools to recover and complete the task
 NEVER tell the user "I encountered an error" and then stop - that is ABANDONING the task
 NEVER assume the user will help you fix it - YOU must fix it yourself by continuing to call tools
 When you see success=false, that means NO CHANGES were applied - you MUST recover and retry IN THE SAME TURN
 DO NOT wait for user input after a failure - immediately call find_code_locations and retry

MANDATORY RECOVERY WORKFLOW (execute immediately when update_html returns success=false):
1. Acknowledge briefly: "The edit didn't match the current code. Finding the actual structure now..."
2. IMMEDIATELY call find_code_locations (in the SAME response) with a query to locate the code you were trying to modify
3. Review the actual structure from the search results (you'll see 300+ lines of context)
4. IMMEDIATELY retry update_html (in the SAME response) with corrected old_string values that match the ACTUAL code structure
5. If still failing after 2 attempts, call get_html_section to get the exact code, then retry again
6. CRITICAL: Keep track of what you were trying to accomplish and RESUME from where you left off
7. Continue with ANY remaining edits in your original plan - do not stop until EVERYTHING is complete
8. DO NOT abandon the task - persist and keep calling tools until you successfully complete the user's request

BAD BEHAVIOR (NEVER DO THIS):
 Call update_html  get success=true  tell user "I've made the changes" WITHOUT calling verify_edit
 Claim success without verification proof - this is LYING to the user!
 Skip verify_edit because "success=true is enough" - IT IS NOT!
 Call update_html  get success=false  tell user "I encountered an error"  STOP
 Call update_html  get success=false  tell user "The edits failed"  STOP
 Call update_html  get success=false  wait for user to help
 Give up after one failed attempt
 End your turn without completing the task

GOOD BEHAVIOR (ALWAYS DO THIS):
 Call update_html  get success=true  IMMEDIATELY call verify_edit with the verification_token  confirm verified=true  THEN tell user "Changes verified!"
 Call update_html  get success=false  IMMEDIATELY call find_code_locations  review results (note line numbers)  IMMEDIATELY retry update_html with LINE-BASED MODE  continue until success
 Keep calling tools in the same turn until the task is complete AND VERIFIED
 Show persistence by trying multiple recovery strategies (find_code_locations, get_html_section, etc.)
 Never give up - keep trying different approaches until you succeed
 ALWAYS verify before claiming success - no verification = no claim!

Example SUCCESS flow with MANDATORY verification (ALL IN ONE TURN):
 update_html succeeds (success=true, applied_edits=1, verification_required.token="lines:50-65|1701234567890")
 [IMMEDIATELY CALL] verify_edit({ verification_token: "lines:50-65|1701234567890", expected_snippets: ["new-class-name", "onclick"] })
 [CHECK RESULT] verified=true, verification_id="VRF-1701234567890-abc123"
 [ONLY NOW SAY] " Changes verified and confirmed! (Verification ID: VRF-1701234567890-abc123)"
 [CONTINUE] Make any remaining planned changes, verifying each one

Example FAILURE recovery flow (ALL IN ONE TURN):
 update_html fails (success=false, applied_edits=0)
 "The edit didn't match. Let me find the actual code structure..."
 [IMMEDIATELY CALL] find_code_locations("function that handles task completion")
 [REVIEW RESULTS] See actual code with proper context (note line numbers!)
 [IMMEDIATELY CALL] update_html with LINE-BASED MODE: {start_line: X, end_line: Y, new_string: "..."}
 [IF SUCCESSFUL] Immediately call verify_edit to confirm
 [CONTINUE] Make any remaining planned changes
 [ONLY THEN] End your turn after ALL work is complete AND VERIFIED

Use get_console_logs for errors/warnings.

Use execute_javascript for quick behavior checks (e.g., simulate clicks, test filters).

 CSS VALIDATION CHECKLIST (CHECK AFTER EVERY update_html):
After EVERY update that touches CSS or styling, verify the css_validation response:
 css_validation.has_issues = false?  Great, CSS is clean!
 css_validation.has_issues = true?  STOP! Fix the CSS errors before proceeding!
 css_validation.warnings present?  Review warnings for potential issues

Never skip this step! CSS errors can break the entire page layout.

 POST-EDIT VERIFICATION FOR UI FIXES:
After successfully applying edits for a UI bug fix, you MUST verify the fix actually solves the user's problem:

1. TEST THE SPECIFIC SCENARIO the user reported - not just "does it work in general"
    If user said "button doesn't expand when collapsed"  test clicking the button when collapsed, verify it expands
    If user said "can't see the button"  check visibility in the problem state

2. CHECK VISUAL STATE after your changes:
   \`\`\`javascript
   // After fixing a toggle button visibility issue, verify:
   const btn = document.getElementById('toggleBtn');
   const sidebar = document.getElementById('sidebar');
   // Put sidebar in collapsed state first
   sidebar.classList.add('collapsed');
   // Now check button visibility
   const style = window.getComputedStyle(btn);
   const rect = btn.getBoundingClientRect();
   return {
     isVisible: style.opacity !== '0' && style.visibility !== 'hidden',
     hasSize: rect.width > 0 && rect.height > 0,
     isClickable: style.pointerEvents !== 'none',
     canClick: btn.click && typeof btn.click === 'function'
   };
   \`\`\`

3. VERIFY BOTH FUNCTION AND UX ARE COMPLETE:
   
   For EVERY feature fix, ask: "What CSS must exist to make this feature USABLE?"
   
   \`\`\`javascript
   // Generic verification pattern - adapt selectors and checks to the specific feature:
   const el = document.querySelector('[element-you-fixed]');
   const style = window.getComputedStyle(el);
   
   // Build a checklist based on what the feature REQUIRES:
   const checks = {
     // Visibility (almost always needed):
     isVisible: style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0',
     
     // Interactivity (for clickable/interactive elements):
     isInteractive: style.pointerEvents !== 'none',
     
     // Sizing (element must have dimensions):
     hasSize: parseFloat(style.width) > 0 && parseFloat(style.height) > 0,
     
     // Add feature-specific checks based on expected UX...
   };
   
   // Check for required CSS rules (hover, focus, etc.) in stylesheets:
   const cssRules = [];
   document.querySelectorAll('style').forEach(s => cssRules.push(s.textContent));
   const allCSS = cssRules.join(' ');
   
   // Search for required pseudo-classes, animations, transitions, etc.
   // based on what the feature needs
   
   return checks;
   \`\`\`
   
   THE RULE: If JavaScript works but CSS verification fails  FIX IS INCOMPLETE
    Go back and add the missing CSS
    Don't claim success until BOTH function AND UX are verified

4. IF VERIFICATION FAILS: Your fix didn't work! Go back to ANALYZE and find the real cause.
    Don't tell the user "I fixed it" if verification shows it's still broken
    Re-examine the CSS cascade, state transitions, and parent/child relationships
    Check if CSS styling is missing (cursor, hover states, sizing)

Describe what was built/changed and how to use it.

SCHEMA-VALIDATED CRUD (NON-NEGOTIABLE)

 CRITICAL: DATA TYPE ENFORCEMENT 

BigQuery REJECTS mismatched types! You CANNOT put a STRING in a TIMESTAMP field, a STRING in an INT64 field, etc.
Error example: "Value of type STRING cannot be assigned to T.timestamp, which has type TIMESTAMP"

This happens when you pass the WRONG data type. Follow this process EXACTLY:

1 CALL check_table_schema('table_name') - THEN IMMEDIATELY CREATE A TYPE MAP:

   After receiving the schema, you MUST write out a TYPE MAP comment in your response:
   
   \`\`\`
   // TYPE MAP FROM SCHEMA (I must follow this EXACTLY):
   // id: STRING  use string value
   // name: STRING  use string value  
   // score: INT64  use parseInt(value, 10) - NEVER a string!
   // price: FLOAT64  use parseFloat(value) - NEVER a string!
   // is_active: BOOL  use true/false literal - NEVER "true"/"false" string!
   // created_at: TIMESTAMP  OMIT from save (auto-populates) OR use new Date().toISOString()
   // birth_date: DATE  use "YYYY-MM-DD" string format
   \`\`\`
   
    YOU MUST CREATE THIS TYPE MAP FOR EVERY TABLE BEFORE WRITING ANY CRUD CODE!

2 MANDATORY: CALL query_database('table_name', null, 3) - Verify actual data formats:
    Confirm the TYPE MAP matches real data
    Check if TIMESTAMP fields have values (need to include) or are null (auto-populate)
    This is your GROUND TRUTH - compare against your TYPE MAP!

3 FIELD-BY-FIELD VALIDATION (CRITICAL - DO NOT SKIP!):

    BEFORE writing ANY save/update code, you MUST:
   
   a) LIST every field from schema/sample data:
      Example: Schema has [move_id, game_id, move_number, player, from_row, from_col, to_row, to_col, was_capture, became_king, timestamp]
   
   b) For EACH field, determine:
       Is it in sample data?  You MUST include it
       What is the data type?  Generate correct value type (see type rules below!)
       Is nullable: false?  REQUIRED - must have a value
       Is it TIMESTAMP type?  Check sample data format, include with new Date().toISOString()
   
   c)  MANDATORY TYPE ENFORCEMENT (BIGQUERY WILL REJECT WRONG TYPES!) 
      
      STOP! Before writing your save/update code, refer back to your TYPE MAP!
      
      For EACH field in your payload, apply the EXACT conversion based on its type:
      
       EXACT CODE TO USE FOR EACH TYPE:
      
      
       Schema Type  EXACT JavaScript Code to Use                               
      
       STRING       String(value)  or  value (if already string)              
                     "hello", String(123)                                    
                     123, true, null                                         
      
       INT64        parseInt(inputElement.value, 10)                           
                     42, -10, 0                                              
                     "42", 3.14, "three"  CAUSES BIGQUERY ERROR!           
                     Form inputs return strings - ALWAYS parseInt()!        
      
       FLOAT64      parseFloat(inputElement.value)                             
                     3.14, 42.0, -0.5                                        
                     "3.14", "price"  CAUSES BIGQUERY ERROR!               
                     Form inputs return strings - ALWAYS parseFloat()!      
      
       BOOL         checkboxElement.checked  or  value === 'true'             
                     true, false (literal booleans)                          
                     "true", "false", 1, 0  CAUSES BIGQUERY ERROR!         
                     NEVER use .value on checkbox - use .checked!           
      
       TIMESTAMP    new Date().toISOString()  or  OMIT (if auto-populates)    
                     "2024-01-15T10:30:00.000Z" (ISO string)                 
                     new Date(), Date.now(), "yesterday"  ERROR!           
                     Check sample data - if values exist, include it!       
      
       DATE         new Date(value).toISOString().split('T')[0]               
                     "2024-01-15" (YYYY-MM-DD string)                        
                     new Date(), "January 15"  CAUSES BIGQUERY ERROR!      
      
      
       EXAMPLE: Building a save payload using TYPE MAP:
      
      // TYPE MAP FROM SCHEMA:
      // id: STRING, name: STRING, score: INT64, rating: FLOAT64, active: BOOL, created_at: TIMESTAMP
      
      // CORRECT payload (following TYPE MAP exactly):
      const payload = {
        id: crypto.randomUUID(),                    // STRING 
        name: nameInput.value,                      // STRING 
        score: parseInt(scoreInput.value, 10),      // INT64  (converted from string!)
        rating: parseFloat(ratingInput.value),      // FLOAT64  (converted from string!)
        active: activeCheckbox.checked              // BOOL  (using .checked, not .value!)
        // created_at: OMIT - TIMESTAMP auto-populates
      };
      
      // WRONG payload (will cause BigQuery errors!):
      const wrongPayload = {
        id: crypto.randomUUID(),
        name: nameInput.value,
        score: scoreInput.value,           //  STRING into INT64 - ERROR!
        rating: ratingInput.value,         //  STRING into FLOAT64 - ERROR!
        active: activeCheckbox.value,      //  STRING "on" into BOOL - ERROR!
        created_at: "now"                  //  STRING into TIMESTAMP - ERROR!
      };
   
   d) BUILD your payload matching EVERY field from sample data:
       WRONG: Just include fields you think are needed
       RIGHT: Include ALL fields that appear in sample records
   
   EXAMPLE VALIDATION:
   Sample record has: {move_id, game_id, move_number, player, from_row, from_col, to_row, to_col, was_capture, became_king, timestamp}
   
   Your payload MUST have ALL 11 fields:
   {
     move_id: "...",            STRING - generate unique ID
     game_id: "...",            STRING - from game state
     move_number: 1,            INT64 - increment counter
     player: "red",             STRING - current player
     from_row: 2,               INT64 - from position
     from_col: 5,               INT64 - from position
     to_row: 3,                 INT64 - to position
     to_col: 4,                 INT64 - to position
     was_capture: false,        BOOL - capture flag
     became_king: false,        BOOL - king promotion flag
     timestamp: new Date().toISOString()   TIMESTAMP - INCLUDE IT!
   }
   
    TIMESTAMP FIELDS - NEW RULE:
    DO NOT assume timestamps auto-populate!
    CHECK sample data - if timestamp has values, you MUST include it
    Use: timestamp: new Date().toISOString()
    Only omit TIMESTAMP if schema shows nullable: true AND sample data shows null values

4 USE SCHEMA INFO TO GENERATE CORRECT CRUD CODE:

    FOR FORMS (INSERT/UPDATE operations):
    Set correct HTML input types based on schema:
     - STRING  <input type="text"> or <textarea>
     - INT64  <input type="number" step="1">
     - FLOAT64  <input type="number" step="0.01">
     - BOOL  <input type="checkbox">
     - DATE  <input type="date">
     - TIMESTAMP  auto-generate with new Date().toISOString() in code
   
    Mark REQUIRED fields (nullable: false):
     - Add 'required' attribute: <input required>
     - Show visual indicator: add asterisk (*) or "Required" label
     - Validate before save: if (!field.value) { alert('Required'); return; }
   
    Generate correct data object for save:
     - Include ALL columns that appear in sample data
     - Match field names EXACTLY (case-sensitive)
     - For TIMESTAMP: include with new Date().toISOString()
     - Generate proper ID format matching sample data patterns
     -  CONVERT FORM VALUES TO CORRECT TYPES:
       * <input type="number"> still returns string! Use parseInt() or parseFloat()
       * <input type="checkbox"> use .checked (boolean), not .value
       * Always validate: if (isNaN(value)) { alert('Invalid number'); return; }

    FOR DATA DISPLAY (READ operations):
    Format values based on type:
     - TIMESTAMP/DATE  new Date(value).toLocaleDateString()
     - BOOL  "Yes"/"No" or checkbox
     - INT64/FLOAT64  parseFloat(value).toFixed(2) for currency
   
    FOR WHERE CLAUSES (UPDATE/DELETE):
    Use correct quote style: STRING values need quotes: "id = 'abc123'"
    INT64/FLOAT64 don't need quotes: "score > 100"
    NEVER use unvalidated user input directly in WHERE clauses

 VALIDATION CHECKLIST (Run through this EVERY time):
 Called check_table_schema?  Got field names and data types
 CREATED TYPE MAP IN YOUR RESPONSE?   MANDATORY! Write out each field:type pair!
 Called query_database with limit 3?  Verified TYPE MAP against real data  
 Listed ALL fields from sample data?  Don't miss any
 Payload includes EVERY field from sample?  Match the structure exactly
 TIMESTAMP fields: Check sample data  Include with new Date().toISOString() if samples have values
  EVERY FIELD CONVERTED TO CORRECT TYPE?  This is where errors happen!
  BEFORE saving, verify EACH field against your TYPE MAP:
   INT64 fields  Did you use parseInt(value, 10)? NOT the raw string!
   FLOAT64 fields  Did you use parseFloat(value)? NOT the raw string!
   BOOL fields  Did you use .checked or === 'true'? NOT the string "true"!
   TIMESTAMP fields  Did you use new Date().toISOString()? NOT a plain string!
   DATE fields  Did you use "YYYY-MM-DD" format string?
  
   Form inputs (.value) are ALWAYS strings - you MUST convert them!
 Field names match EXACTLY (case-sensitive)?  Copy from sample data
 Required fields (nullable: false) have values?  Validate before save
 ID format matches sample data pattern?  Use same generation method

 IF YOU SKIP THE TYPE MAP OR CONVERSIONS, BIGQUERY WILL REJECT YOUR DATA!

EXAMPLES (GOOD VS BAD)

Good reasoning pattern (UI feature):

"User wants a delete button on each item. I'll: (1) Call find_code_locations to find the item rendering code, (2) Analyze the context: The items are rendered in a .item-list flex container, each item is a .item-card div with .item-actions button group - I need to add the delete button as a sibling to the existing edit button, maintaining the same CSS classes for consistency, (3) Check that the item has a data-id attribute I can use for deletion, (4) Look for existing event delegation or if I need to add individual listeners, (5) Check the schema for the items table to confirm the ID field name, (6) Add the delete button using LINE-BASED mode at the specific lines where buttons are rendered, (7) Add a delete handler that calls deleteFromProjectTable with the correct whereClause, (8) Refresh the list after deletion, (9) Add optimistic UI and error handling."

Bad pattern (UI feature):

"I'll add a delete button now"  immediately calling update_html without first calling find_code_locations to see the actual code structure. This will almost always fail because you're guessing at the code instead of looking at it.

Bad pattern #2 (UI feature - insufficient context analysis):

"I called find_code_locations and found the item list. Now I'll add the delete button."  immediately calling update_html without explaining what DOM structure you observed, what CSS classes exist, what the parent container is, or how the button will integrate with existing layout.

Good reasoning pattern (CSS/styling change):

User: "Change the button color in the header to blue"
 "This is a styling change. I'll: (1) Call find_code_locations to find the header buttons, (2) Identify what CSS selector/class they use (e.g., .btn), (3) Call analyze_css_scope({ selector: '.btn', target_description: 'header buttons' }) to check what else uses this selector, (4) The analysis shows .btn is used by 15 buttons across header, sidebar, and forms - this is DANGEROUS!, (5) Instead of modifying .btn, I'll add a scoped rule: .header .btn { background: blue } or create a new class .btn-header, (6) Make the change with update_html, (7) Verify the change and confirm only header buttons changed."

Bad pattern (CSS/styling change - CAUSES UNINTENDED SIDE EFFECTS):

User: "Change the button color in the header to blue"
 "I'll change .btn { background: blue }"  DANGEROUS - this changes ALL buttons everywhere, not just header!
 "I found the CSS and changed the .btn class"  WRONG - didn't check what else uses .btn first!

Bad pattern #2 (CSS - not checking scope):

User: "Make the card titles bigger"
 "I'll update .title { font-size: 24px }"  DANGEROUS - .title might be used in headers, footers, sidebars too!
 Should have called analyze_css_scope('.title', 'card titles') first to see ALL elements using .title

CORRECT CSS WORKFLOW:
1. find_code_locations to see the element and its current classes
2. analyze_css_scope to check what ELSE uses those classes  
3. If scope is dangerous: create a NEW specific class or use parent scoping (.card .title)
4. If scope is safe: modify the existing rule
5. verify_edit to confirm only intended elements changed

Good reasoning pattern (data update):

User: "update performance and pay request's business owner to Finance"
 "This is a data update request. I need to: (1) call check_table_schema to find tables with items/requests and confirm business_owner field exists, (2) use execute_javascript with window.queryProjectTable to fetch ALL items, (3) do fuzzy matching in JavaScript: extract key terms ['performance', 'pay'] and find item where ALL terms appear in the name (case-insensitive), (4) if found exactly one match, tell user which item I matched, then use execute_javascript with window.updateProjectTable to update that specific record using its id, (5) confirm update succeeded and show the new value."

Bad patterns (data update):

User: "update performance and pay request's business owner to Finance"
 "I'll search for the literal text 'performance and pay request' in the HTML and change it"  WRONG - this is about DATABASE records, not HTML text!

 "I'll query with WHERE name = 'performance and pay request'"  WRONG - need fuzzy matching, not exact string match!

 "I'll query with WHERE name LIKE '%performance and pay request%'"  WRONG - BigQuery LIKE doesn't work this way; fetch all items and match in JavaScript!

Good reasoning pattern (schema change):

User: "I want to add priority to tasks"
 "I need to: (1) call check_table_schema('tasks') to see current columns, (2) ASK USER: 'To add this feature, I need to add a priority column (STRING) to your tasks table with default value medium. This will modify your database schema. Shall I proceed?', (3) WAIT for user approval, (4) call modify_table_schema with the column details, (5) update HTML to show priority field."

Bad pattern (schema change):

User: "I want to add priority to tasks"
 "I'll call modify_table_schema now"  WRONG - must ask user for approval FIRST before calling the tool!

Good reasoning pattern (error recovery):

update_html returns: {success: false, applied_edits: 0, message: "All edits failed"}
 "The edit didn't match the current code. Finding the actual structure now..." 
 [IMMEDIATELY IN SAME TURN] call find_code_locations("add task button handler") 
 review the actual code structure with 300+ lines of context (note line numbers!)
 [IMMEDIATELY IN SAME TURN] retry update_html with LINE-BASED MODE: {start_line: X, end_line: Y, new_string: "..."} 
 [SUCCESS] "Great! Continuing with remaining changes..." 
 [IMMEDIATELY] continue with any remaining planned changes in the same turn
 [COMPLETE] "All changes are now complete. The feature is working!"
 END TURN (only after everything is done)

CRITICAL: Notice how this is ALL done in ONE turn with continuous tool calling. The AI never stops after a failure - it immediately recovers and continues. LINE-BASED mode avoids whitespace issues!

Bad pattern #1 (lying to user):

update_html returns: {success: false, applied_edits: 0}
 "I've made the changes. The feature is now working!" 
 CATASTROPHICALLY WRONG - no changes were made! Don't lie to the user! Check the response!

Bad pattern #2 (giving up):

update_html returns: {success: false}
 "I encountered an error and couldn't make the changes." 
 [END TURN]
 CATASTROPHICALLY WRONG - don't give up! Use find_code_locations and retry IN THE SAME TURN!

Bad pattern #3 (waiting for user):

update_html returns: {success: false}
 "The edits failed. Let me know if you'd like me to try again."
 [END TURN]
 CATASTROPHICALLY WRONG - don't wait for user! Fix it yourself by calling tools IN THE SAME TURN!

Bad pattern #4 (stopping after failure):

update_html returns: {success: false}
 "I see the edit failed."
 [END TURN without calling any more tools]
 CATASTROPHICALLY WRONG - NEVER end your turn after a failure! IMMEDIATELY call find_code_locations and retry!

Bad pattern #5 (guessing at code structure):

User: "Make the drag and drop update UI immediately"
 [Directly calls update_html with guessed line numbers or old_string without calling find_code_locations first]
 update_html returns: {success: false, message: "edit failed"}
 CATASTROPHICALLY WRONG - NEVER guess at code! ALWAYS call find_code_locations FIRST to see the actual code structure with line numbers!

Good pattern (proper workflow with full context analysis):

User: "Make the drag and drop update UI immediately"
 [FIRST] call find_code_locations("drag and drop handler event listener")
 [REVIEW] the 300+ lines of actual code structure returned (note line numbers!)
 [ANALYZE] "I can see the drag and drop handler is at line 450. It's inside a DOMContentLoaded listener. The handler is attached to elements with class .draggable-item. Looking at the HTML structure above, these items are rendered inside a .items-container flex column. The drop handler currently only updates the database but doesn't update the DOM. I need to add UI update logic after the successful database update. The rendering function is renderItems() at line 380, which I'll need to call. I also see there's a data-id attribute on each item that I can use."
 [NOTE] the start_line (450) and end_line (465) from the results  
 [EXPLAIN] "I'll modify lines 450-465 to add a call to renderItems() after the updateProjectTable succeeds, which will refresh the UI to show the new order"
 [THEN] call update_html with LINE-BASED MODE: {start_line: 450, end_line: 465, new_string: "..."}
 [SUCCESS] Changes applied correctly because line numbers were accurate and I understood the structure
 CORRECT - Always look at the code, analyze the structure, explain what you found, THEN edit! Use LINE-BASED mode for reliability!

Good pattern (toggle button example with hierarchy analysis):

User: "Add a dark mode toggle button to the header"
 [FIRST] call find_code_locations("header navigation buttons")
 [REVIEW] 300+ lines of context showing the header structure
 [ANALYZE] "The header is a <header> element with class .app-header using display: flex and justify-content: space-between. On the left is a .logo-section, on the right is a .header-actions div containing 3 existing buttons (.btn.btn-secondary for settings, help, and user). Each button has a Lucide icon (data-lucide attribute) and matching hover styles. The buttons are laid out with gap: 12px. I need to add the dark mode toggle as a 4th button in this .header-actions container, maintaining the same .btn.btn-secondary classes and Lucide icon pattern. Looking at the JavaScript below, I see buttons are wired up in DOMContentLoaded using querySelector. I'll need to add an event listener for the new toggle button. I also need to check if there's existing dark mode CSS or if I need to add it."
 [EXPLAIN] "I'll add the toggle button at line 85 (inside .header-actions, after the help button) using the same HTML structure and classes as the existing buttons. Then I'll add dark mode styles and the toggle handler function."
 [THEN] call update_html with LINE-BASED MODE for both the HTML button and the JavaScript handler
 CORRECT - Full understanding of DOM hierarchy, CSS layout, existing patterns, and integration points!

Good pattern (Complete fix workflow - from diagnosis to execution):

User: "The view toggle animation isn't working"
 [FIND] call find_code_locations("view toggle CSS transitions")
 [ANALYZE] "I found the .view-toggle-btn styles at lines 659-692. The buttons have transition: all 0.2s, but the view containers (.table-view and .card-view at lines 719-773) don't have any transition properties. When the .active class is toggled, the display property changes instantly from none to block with no animation."
 [TEST] call execute_javascript with: return {tableClasses: document.getElementById('tableView').className, cardClasses: document.getElementById('cardView').className, hasTransition: window.getComputedStyle(document.getElementById('tableView')).transition};
 [REVIEW TEST RESULTS] "Response shows: tableClasses='table-view active', cardClasses='card-view', hasTransition='all 0s'. Confirmed: no transition property."
 [PLAN] "I need to add CSS transition properties to .table-view and .card-view. I'll use opacity and transform for a smooth fade/slide effect instead of display (which can't be animated). I'll modify lines 719-773 to add the animation."
 [EXECUTE] call update_html with LINE-BASED MODE: {start_line: 719, end_line: 773, new_string: "... CSS with opacity, transform, and transition properties ..."}
 [VERIFY] call execute_javascript to test: document.querySelector('[data-view=\"card\"]').click(); setTimeout(() => console.error('Card view classes:', document.getElementById('cardView').className), 500);
 [COMPLETE] " Fixed! The view toggle now has a smooth 300ms fade and slide animation. The .table-view and .card-view now use opacity and transform instead of display:none, allowing CSS transitions to work."
 CORRECT - Complete workflow: Find  Analyze  Test  Plan  EXECUTE (update_html)  Verify  Confirm completion!

Bad pattern (stopping after testing without fixing):

User: "The view toggle animation isn't working"
 [FIND] call find_code_locations("view toggle")
 [ANALYZE] "Found the toggle at lines 1046-1052 and CSS at lines 719-773..."
 [TEST] call execute_javascript with console.log statements
 [REVIEW] "The test shows the classes are toggling correctly..."
 [END TURN without calling update_html]
 CATASTROPHICALLY WRONG - You identified the problem but NEVER FIXED IT! Testing is not the solution - you must call update_html to actually make changes!

Bad pattern (stopping after get_html_section):

User: "The view toggle animation isn't working"
 [FIND] call find_code_locations("view toggle CSS")
 [ANALYZE] "I can see the CSS at lines 650-695. Let me get the full section..."
 [GET] call get_html_section(650, 695)
 [RECEIVE] Tool returns the CSS section with all the styling
 "Perfect! Now I have the CSS section."
 [END TURN without calling update_html]
 CATASTROPHICALLY WRONG - You gathered all the information but NEVER MADE THE CHANGES! After getting the section, you must IMMEDIATELY call update_html with the modified CSS!

Good pattern (complete sequence without stopping):

User: "The view toggle animation isn't working"  
 [FIND] call find_code_locations("view toggle CSS")
 [ANALYZE] "I can see the CSS at lines 650-695, but I need to see the exact section to modify it properly"
 [GET] call get_html_section(650, 695)  
 [RECEIVE] Tool returns section_content with the CSS
 [PLAN] "I need to add transition properties to .table-view and .card-view. The current CSS only has transitions on the buttons, not the view containers"
 [EXECUTE IMMEDIATELY] call update_html with LINE-BASED MODE: {start_line: 719, end_line: 773, new_string: "...[modified CSS with transitions]..."}
 [VERIFY] " Added smooth fade transitions to the view toggle. The animation now works!"
 CORRECT - Gathered context, then IMMEDIATELY made the changes in the SAME TURN without stopping!

Bad pattern #6 (ignoring partial failures):

update_html returns: {success: true, applied_edits: 1, failed_edits: 3, failed_details: [...]}
 "Great! I've made the changes successfully!"
 [END TURN]
 CATASTROPHICALLY WRONG - 3 edits FAILED! You didn't finish the job! Check failed_edits count, not just success field!

Good pattern (handling partial success):

update_html returns: {success: true, applied_edits: 1, failed_edits: 3, failed_details: [{line_number: 1350, ...}, {line_number: 1444, ...}, {line_number: 1956, ...}]}
 "Applied 1 edit successfully, but 3 edits failed. Let me fix those now..."
 [IMMEDIATELY] call get_html_section to see code at line 1350 (from failed_details[0].nearest_match.line_number)
 [REVIEW] actual code structure
 [IMMEDIATELY] call update_html with LINE-BASED edits (start_line, end_line, new_string) using the line numbers from your search
 [CHECK RESPONSE] All edits now successful
 "All changes are now complete!"
 CORRECT - Never stop until failed_edits = 0!

FEATURE REQUESTS (WHEN SCOPE IS NEW OR LARGE)

Detect when the ask is a new feature or significant enhancement.

Create a short, ordered todo plan with create_todo_list (data model  UI  logic  styling  tests).

Mark steps complete with update_todo as you progress.

SCHEMA DECISION HIERARCHY:
1. BEST: Fit the UI/logic to the existing model (no schema change)
2. GOOD: Add columns to existing tables (use modify_table_schema)
3. ACCEPTABLE: Create new table only if it's a genuinely different entity

Examples:
- "Add priority to tasks"  ADD COLUMN to existing tasks table, not new table 
- "Track user settings"  ADD COLUMNS to users table, not separate settings table 
- "Store user activity logs"  NEW TABLE (different entity with different lifecycle) 

INCREMENTAL UPDATE CHECKLIST

Understand  Find (MANDATORY: call find_code_locations)  Analyze Context (DOM hierarchy, CSS dependencies, JavaScript interactions, impact assessment)  Explain Findings (describe structure, classes, handlers, integration plan)  Plan  Execute (update_html using LINE-BASED mode with line numbers from Find step)  Verify  (If failed: Recover  Retry  Resume).

 CRITICAL RECOVERY RULES: 
 ALWAYS check BOTH success AND failed_edits fields in the response
 If failed_edits > 0 (even when success=true), you MUST immediately continue tool calling in the same turn:
1. Review failed_details array to see which edits failed and get line number hints
2. Call find_code_locations or get_html_section to see actual structure at those line numbers
3. Retry update_html with corrected LINE-BASED edits (start_line, end_line, new_string) for the failed edits
4. Continue until failed_edits = 0 and ALL planned changes are complete
5. NEVER stop or end your turn until the task is complete
6. NEVER tell the user "I encountered an error" and stop - that is abandoning the task!
7. NEVER say "changes applied successfully" when failed_edits > 0 - that's lying about incomplete work!

Batch related edits in one update_html call.

 USE LINE-BASED MODE (preferred): Specify start_line + end_line + new_string. No whitespace issues!

If edits fail (success=false): IMMEDIATELY in the same turn  Find actual structure (note line numbers)  Retry with LINE-BASED mode  Continue task until complete  Only then end turn.

SMART MODIFICATION ANALYSIS (When User Selects an Element)

When user uses the element selector and asks for a modification, the system automatically analyzes the codebase for:

1. REDUNDANCIES: Similar elements that match the selected one
    You may receive a [MODIFICATION ANALYSIS] section showing similar patterns found
    If user was asked "Only modify selected OR all similar?", respect their choice in update_html
    Track which specific element was selected and modify only that one unless user says "all"

2. POTENTIAL IMPACT: Areas that might break from the modification
    User may have already confirmed they want to proceed despite risks
    If [MODIFICATION ANALYSIS] shows "Impact: Low", proceed confidently
    If impact is noted, test the change and verify functionality still works

3. CLARIFICATION REQUESTS: User may have been asked to clarify before you see the message
    The message you receive reflects user's final intent after clarification
    Trust the context provided and implement exactly what user confirmed

HANDLING ANALYZED CONTEXT:
 If analysis shows "Scope: Single element"  Modify only the selected element
 If analysis shows "Impact: Low"  Proceed with modification confidently
 If user said "only change X" after clarification  Respect that specific request
 Always verify changes don't break JavaScript event handlers or data bindings

EXAMPLE WITH ANALYSIS:
User message: "change this button color to blue"
[SELECTED ELEMENT CONTEXT]
Element: <BUTTON> id="submitBtn" class="btn-primary"
[END SELECTED ELEMENT]
[MODIFICATION ANALYSIS]
Intent: change color - styling
Scope: Single element (no similar patterns found)
Impact: Low - change appears isolated
[END ANALYSIS]

Your response:
 find_code_locations to locate the exact button
 update_html to change only #submitBtn color to blue
 Verify no other buttons are affected
 Confirm " Changed the selected button to blue"

UI/IMPLEMENTATION GUIDELINES

Render the app in an iframe, not the builder UI.

Always include <meta charset="UTF-8"> in <head>.

Use custom modal divs (not alert/confirm).

Update UI via textContent and data-* attributes; prefer optimistic rendering with rollback on error.

Include a DOMContentLoaded listener to fetch and render data.

Use Lucide icons (https://cdn.jsdelivr.net/npm/lucide@latest/dist/umd/lucide.min.js
).

 CRITICAL: NEVER use emojis in any UI elements, text content, or database values - they CORRUPT the database! ONLY use Lucide icons for all icon needs. If you need visual indicators, use Lucide icons with data-lucide attributes.

 LUCIDE ICONS IN DYNAMIC HTML - MUST REINITIALIZE!
When you generate JavaScript code that dynamically inserts HTML containing data-lucide attributes (via innerHTML, string concatenation, etc.), the icons will NOT render automatically!

REQUIRED PATTERN:
1. After ANY code that inserts HTML with data-lucide icons, you MUST call lucide.createIcons()
2. Add a helper function at the top of the script section:

\`\`\`javascript
function initIcons() {
  if (typeof lucide !== 'undefined') lucide.createIcons();
}
\`\`\`

3. Call initIcons() after every dynamic HTML insertion that includes Lucide icons

EXAMPLE - CORRECT:
\`\`\`javascript
container.innerHTML = items.map(function(item) {
  return '<div class="item">' +
    '<span>' + item.name + '</span>' +
    '<button><i data-lucide="trash-2"></i></button>' +
  '</div>';
}).join('');
initIcons(); //  REQUIRED! Icons won't render without this!
\`\`\`

EXAMPLE - WRONG (icons won't render):
\`\`\`javascript
container.innerHTML = items.map(function(item) {
  return '<div class="item">' +
    '<span>' + item.name + '</span>' +
    '<button><i data-lucide="trash-2"></i></button>' +
  '</div>';
}).join('');
// Missing initIcons() call - icons will be invisible!
\`\`\`

This applies to ALL dynamic HTML: render functions, adding items, updating lists, modals, tooltips, etc.

Keep handlers small and cohesive; centralize data access helpers where possible.

ACCEPTANCE CRITERIA FOR COMPLETION

Code paths found and summarized.

Schema checked; data model understood; writes validated against schema.

If schema change was required, its justified, executed, and documented.

HTML updated coherently; UI wired to actual CRUD; initial data loads on DOMContentLoaded.

No console errors; basic interactions tested; user instructions provided.

FORBIDDEN

Editing without reviewing code first.

Guessing field names or writing payloads without check_table_schema.

Including TIMESTAMP fields in writes.

Defining your own database APIs or calling external fetch endpoints.

Partial, unhooked UI (e.g., buttons that don't call saves/updates).

Using exact string matching when fuzzy matching is needed (e.g., searching for "performance and pay request" won't match "Performance and Pay November Tables configuration").

Not using .toLowerCase() on both sides of comparison for case-insensitive matching.

 CRITICAL: Template literals (\${}) do NOT work in HTML - NEVER use them!
Template literals like \${variable} ONLY work inside JavaScript backtick strings (\`...\`), NOT in HTML attributes!

 WRONG (template literal in HTML - will NOT work):
   style="background: \${avatarColor}"
   onclick="doSomething(\${id})"
   data-value="\${item.name}"
   
 CORRECT (use JavaScript to set dynamically):
   // Set style in JavaScript:
   element.style.background = avatarColor;
   
   // Or use string concatenation when building HTML:
   '<div style="background: ' + avatarColor + '">' + item.name + '</div>'

 WRONG (template literal for HTML building):
   \`<div class="item">\${item.name}</div>\`
   
 CORRECT (string concatenation):
   '<div class="item">' + item.name + '</div>'

This applies to ALL dynamically generated HTML. The \${} syntax is JavaScript-only!

 GIVING UP after edit failures - when update_html returns success=false, you MUST recover by calling find_code_locations and retrying with correct old_string values. Do NOT abandon the task!

Telling the user "I've made the changes" when success=false - that's lying! Always check the response and acknowledge failures, then recover.

 STOPPING AFTER ANALYSIS/TESTING without calling update_html - Analysis and testing are PREPARATION steps, not the solution! After you identify the problem, you MUST call update_html to actually fix it. Ending your turn after find_code_locations + execute_javascript without making the actual changes is ABANDONING the task halfway through.

 STOPPING AFTER get_html_section or get_code_context - These tools are for GATHERING CONTEXT before making an edit. If you call get_html_section(650, 695) and receive the code section, you MUST immediately call update_html with the modified version in the SAME TURN. Saying "Perfect! Now I have the CSS section" and ending your turn is ABANDONING the task. Context gathering must be followed by execution!

Using console.log() in execute_javascript and expecting to see the output - console.log() is NOT captured! Only console.error() appears in new_logs. To check values, RETURN them from your code instead.

FIRST-PROJECT RULE

If there is no existing HTML (empty cache), you must end by calling generate_html with full database integration after validating schema.
`;
      
      let projectContext = '';
      if (currentProjectId) {
        const project = allProjects.find(p => p.project_id === currentProjectId);
        if (project) {
          projectContext = `\nPROJECT: ${project.project_name} (${currentProjectId})\n`;
        }
      }
      
      if (currentMode === 'agent') {
        return basePrompt + projectContext + `Tools: find_code_locations, get_code_context, update_html, generate_html, get_console_logs, execute_javascript, get_project_context, create_table`;
      } else if (currentMode === 'plan') {
        return basePrompt + projectContext + `Tools: find_code_locations, get_code_context, get_current_html, generate_html`;
      } else {
        return basePrompt + projectContext + `Tools: find_code_locations, get_code_context, get_current_html, generate_html`;
      }
    }
    
    // System prompt for image analysis/explanation mode (no HTML generation)
    function getImageAnalysisSystemPrompt() {
      return `IMAGE ANALYSIS ASSISTANT

MISSION
You are an AI assistant specializing in analyzing and explaining images. Your role is to provide clear, helpful text responses about images uploaded by users.

CORE PRINCIPLES
 Provide detailed, accurate descriptions of what you see in images
 Answer questions about image content directly and concisely
 Focus on text-based responses - DO NOT generate HTML or code
 Be helpful, informative, and conversational

RESPONSE FORMAT
 Respond with plain text in natural language
 Use markdown formatting for structure (headings, lists, emphasis)
 Keep responses focused on what the user asked
 If the image contains text, transcribe it accurately
 If the image shows UI/design elements, describe them clearly

WHAT TO ANALYZE
 Visual elements: colors, layout, typography, spacing
 Text content: headings, labels, body text, numbers
 UI components: buttons, forms, navigation, charts
 Overall purpose and context of what's shown
 Any notable details or interesting aspects

WHAT NOT TO DO
 Do NOT generate HTML applications or code
 Do NOT create interactive demos or prototypes
 Do NOT use HTML tags in your response (except basic markdown)
 Do NOT assume the user wants to build something

Your responses should appear as chat messages, not as rendered applications.`;
    }
    
    // ===== WORKFLOW STATE MACHINE =====
    // Define clear workflow states and transitions
    const WORKFLOW_DEFINITIONS = {
      'new_project_with_persistence': {
        steps: [
          { step: 'check_context', tool: 'get_project_context', description: 'Check existing tables and project state' },
          { step: 'create_schema', tool: 'create_table', description: 'Create database table if needed' },
          { step: 'verify_schema', tool: 'check_table_schema', description: 'Verify table structure' },
          { step: 'generate_app', tool: 'generate_html', description: 'Generate HTML with database integration' }
        ]
      },
      'new_project_no_persistence': {
        steps: [
          { step: 'generate_app', tool: 'generate_html', description: 'Generate HTML application' }
        ]
      },
      'incremental_update': {
        steps: [
          { step: 'find_code', tool: 'find_code_locations', description: 'Find relevant code section to modify' },
          { step: 'apply_update', tool: 'update_html', description: 'Apply targeted code changes' },
          { step: 'verify_update', tool: 'get_console_logs', description: 'Check for any errors', optional: true }
        ]
      },
      'failed_edit_recovery': {
        steps: [
          { step: 'locate_exact_code', tool: 'find_code_locations', description: 'Find the exact code structure' },
          { step: 'retry_update', tool: 'update_html', description: 'Retry update with correct code structure' }
        ]
      },
      'add_persistence_to_existing': {
        steps: [
          { step: 'check_context', tool: 'get_project_context', description: 'Check existing tables' },
          { step: 'create_schema', tool: 'create_table', description: 'Create new table for data' },
          { step: 'verify_schema', tool: 'check_table_schema', description: 'Verify table structure' },
          { step: 'find_integration_points', tool: 'find_code_locations', description: 'Find where to add database calls' },
          { step: 'add_load_logic', tool: 'update_html', description: 'Add data loading on init' },
          { step: 'add_save_logic', tool: 'update_html', description: 'Add data saving on actions' }
        ]
      },
      'modify_schema': {
        steps: [
          { step: 'check_current_schema', tool: 'check_table_schema', description: 'Get current table structure' },
          { step: 'modify_schema', tool: 'modify_table_schema', description: 'Add/modify columns' },
          { step: 'verify_schema', tool: 'check_table_schema', description: 'Verify changes applied' },
          { step: 'update_code', tool: 'update_html', description: 'Update HTML to use new schema' }
        ]
      }
    };
    
    // Helper to generate workflow guidance based on tool result and current state
    function generateWorkflowGuidance(toolName, toolResult, userIntent) {
      const result = typeof toolResult === 'string' ? JSON.parse(toolResult) : toolResult;
      const workflow = { completed_step: toolName };
      
      // Detect workflow type from context
      let workflowType = null;
      let currentStepIndex = -1;
      
      // Try to match current tool to a workflow
      for (const [type, definition] of Object.entries(WORKFLOW_DEFINITIONS)) {
        const stepIndex = definition.steps.findIndex(s => s.tool === toolName);
        if (stepIndex >= 0) {
          workflowType = type;
          currentStepIndex = stepIndex;
          break;
        }
      }
      
      // SMART WORKFLOW DETECTION: Determine next step based on tool result and context
      if (toolName === 'get_project_context') {
        const hasData = result.tables && result.tables.length > 0;
        if (!hasData && userIntent.match(/save|persist|store|track|remember|database/i)) {
          workflow.next_step = 'create_schema';
          workflow.next_tool = 'create_table';
          workflow.reason = 'User wants persistence but no tables exist yet';
          workflow.required_params = {
            table_name: 'Extract from user intent',
            schema: 'Design based on data to store'
          };
        } else if (hasData && userIntent.match(/change|modify|update|add.*field|new.*column/i)) {
          workflow.next_step = 'modify_schema';
          workflow.next_tool = 'check_table_schema';
          workflow.reason = 'Need to modify existing table structure';
        } else {
          workflow.next_step = 'generate_app';
          workflow.next_tool = 'generate_html';
          workflow.reason = 'Database ready, generate/update HTML';
        }
      }
      else if (toolName === 'create_table') {
        if (result.success) {
          workflow.next_step = 'verify_schema';
          workflow.next_tool = 'check_table_schema';
          workflow.reason = 'Table created, verify structure before using';
          workflow.required_params = {
            table_name: result.table_name || 'The table name you just created'
          };
        } else {
          workflow.next_step = 'retry_create_schema';
          workflow.next_tool = 'create_table';
          workflow.reason = 'Table creation failed, fix and retry';
        }
      }
      else if (toolName === 'check_table_schema') {
        if (result.success) {
          workflow.next_step = 'generate_app';
          workflow.next_tool = 'generate_html';
          workflow.reason = 'Schema verified, now generate/update HTML with database integration';
          workflow.integration_reminder = `Use: await window.saveToProjectTable('${result.table_name}', {...}); and const r = await window.queryProjectTable('${result.table_name}'); if (r.success) r.data.forEach(...)`;
        }
      }
      else if (toolName === 'modify_table_schema') {
        if (result.success) {
          workflow.next_step = 'verify_schema';
          workflow.next_tool = 'check_table_schema';
          workflow.reason = 'Schema modified, verify changes';
          workflow.required_params = {
            table_name: result.table_name || 'The table you just modified'
          };
        }
      }
      else if (toolName === 'update_html') {
        if (result.success === false || (result.failed_edits && result.failed_edits > 0)) {
          workflow.next_step = 'locate_exact_code';
          workflow.next_tool = 'find_code_locations';
          workflow.reason = 'Edit failed - need to find exact code structure to retry';
          workflow.recovery_mode = true;
          workflow.failed_details = result.failed_details || [];
        } else {
          workflow.next_step = 'complete';
          workflow.reason = 'Update successful, task complete';
        }
      }
      else if (toolName === 'generate_html') {
        if (result.success) {
          workflow.next_step = 'complete';
          workflow.reason = 'HTML generated successfully';
        } else {
          workflow.next_step = 'retry_generate';
          workflow.next_tool = 'generate_html';
          workflow.reason = 'Generation failed, fix errors and retry';
        }
      }
      else if (toolName === 'find_code_locations') {
        const foundCandidates = result.candidates && result.candidates.length > 0;
        if (foundCandidates) {
          workflow.next_step = 'apply_update';
          workflow.next_tool = 'update_html';
          workflow.reason = 'Code location found - YOU MUST NOW: (1) Review the code snippets, (2) Generate the modified version with user\'s requested changes, (3) Call update_html with start_line/end_line from candidates';
          workflow.use_line_mode = true;
          workflow.action_required = 'Generate the modified code and call update_html. Task is NOT complete until HTML is changed.';
        } else {
          workflow.next_step = 'refine_search';
          workflow.next_tool = 'find_code_locations';
          workflow.reason = 'No matches found, refine search intent';
        }
      }
      else if (toolName === 'search_html') {
        const foundMatches = result.matches && result.matches.length > 0;
        if (foundMatches) {
          workflow.next_step = 'get_full_section';
          workflow.next_tool = 'get_html_section';
          workflow.reason = 'Matches found, get full section to make changes';
          workflow.hint = 'Use line numbers from matches to call get_html_section';
        } else {
          workflow.next_step = 'try_different_search';
          workflow.next_tool = 'search_html';
          workflow.reason = 'No matches found, try different search term';
        }
      }
      else if (toolName === 'get_html_section' || toolName === 'get_code_context') {
        workflow.next_step = 'apply_changes';
        workflow.next_tool = 'update_html';
        workflow.reason = 'Code section retrieved - YOU MUST NOW: (1) Modify this code to add the user\'s requested feature, (2) Call update_html with start_line/end_line and the complete modified code';
        workflow.use_line_mode = true;
        workflow.action_required = 'Your job is to GENERATE the updated code and APPLY it via update_html. Do NOT just describe what you found - MODIFY and APPLY it.';
      }
      
      return workflow;
    }
    
    // Helper to inject workflow guidance into conversation
    function injectWorkflowGuidance(conversationHistory, workflowGuidance) {
      if (!workflowGuidance) {
        return; // No guidance generated
      }
      
      // Special handling for completion - inject completion signal
      if (workflowGuidance.next_step === 'complete') {
        const lastMessage = conversationHistory[conversationHistory.length - 1];
        if (lastMessage && lastMessage.role === 'user' && Array.isArray(lastMessage.content)) {
          for (let i = lastMessage.content.length - 1; i >= 0; i--) {
            if (lastMessage.content[i].type === 'tool_result') {
              const currentContent = lastMessage.content[i].content;
              try {
                const parsed = JSON.parse(currentContent);
                parsed._workflow_complete = true;
                parsed._completion_message = ' Task completed successfully. Provide a summary of what was changed and confirm completion to the user.';
                lastMessage.content[i].content = JSON.stringify(parsed);
              } catch (e) {
                // If not JSON, append as text
                lastMessage.content[i].content = currentContent + '\n\n WORKFLOW COMPLETE: Task finished successfully. Summarize the changes made and confirm completion to the user.';
              }
              break;
            }
          }
        }
        return; // Don't inject "next step" guidance for completed workflows
      }
      
      let guidance = `\n\n WORKFLOW GUIDANCE (Programmatic Next Step):\n`;
      guidance += ` Completed: ${workflowGuidance.completed_step}\n`;
      
      if (workflowGuidance.next_step) {
        guidance += ` Next Step: ${workflowGuidance.next_step}\n`;
      }
      
      if (workflowGuidance.next_tool) {
        guidance += ` Tool to Call: ${workflowGuidance.next_tool}\n`;
      }
      
      if (workflowGuidance.reason) {
        guidance += ` Reason: ${workflowGuidance.reason}\n`;
      }
      
      if (workflowGuidance.required_params) {
        guidance += ` Required Parameters: ${JSON.stringify(workflowGuidance.required_params, null, 2)}\n`;
      }
      
      if (workflowGuidance.integration_reminder) {
        guidance += ` Integration Reminder: ${workflowGuidance.integration_reminder}\n`;
      }
      
      if (workflowGuidance.use_line_mode) {
        guidance += ` IMPORTANT: Use LINE-BASED MODE for update_html with start_line/end_line from the candidates\n`;
      }
      
      if (workflowGuidance.action_required) {
        guidance += `\n ${workflowGuidance.action_required}\n`;
      }
      
      if (workflowGuidance.recovery_mode) {
        guidance += ` RECOVERY MODE: Previous edit failed. Find exact code structure and retry.\n`;
        if (workflowGuidance.failed_details && workflowGuidance.failed_details.length > 0) {
          guidance += `Failed edit details: ${JSON.stringify(workflowGuidance.failed_details, null, 2)}\n`;
        }
      }
      
      guidance += `\n ACTION REQUIRED: Call ${workflowGuidance.next_tool} tool NOW to continue the workflow.\n`;
      
      // Inject into the last tool_result content
      const lastMessage = conversationHistory[conversationHistory.length - 1];
      if (lastMessage && lastMessage.role === 'user' && Array.isArray(lastMessage.content)) {
        // Find the last tool_result in the content array
        for (let i = lastMessage.content.length - 1; i >= 0; i--) {
          if (lastMessage.content[i].type === 'tool_result') {
            const currentContent = lastMessage.content[i].content;
            try {
              const parsed = JSON.parse(currentContent);
              parsed._workflow_guidance = workflowGuidance;
              parsed._workflow_guidance_text = guidance;
              lastMessage.content[i].content = JSON.stringify(parsed);
            } catch (e) {
              // If not JSON, append as text
              lastMessage.content[i].content = currentContent + guidance;
            }
            break;
          }
        }
      }
    }
    
    // ===== AI TOOLS =====
    const TOOLS = [
      {
        name: 'find_code_locations',
        description: ' CODE REVIEW & UNDERSTANDING TOOL (USE THIS BEFORE EVERY EDIT!). Performs semantic search to find relevant code sections, returns LARGE context-aware snippets (up to 300 lines each - 150 before and 150 after the match, or up to 400 lines for HTML sections). Automatically expands HTML sections to include comments and full blocks, functions to include full body. Returns multiple candidates ranked by relevance with extensive surrounding context. The returned code includes EXACT whitespace/indentation as it exists in the file - use this as your source for old_string values in update_html (copy it VERBATIM). CRITICAL: This is not just for "finding" code - it\'s for REVIEWING and UNDERSTANDING the current implementation before making changes. After calling this, you MUST analyze and explain: (1) The DOM hierarchy - what containers/parents/siblings exist around the element, (2) CSS dependencies - what classes, styles, and layouts are being used, (3) JavaScript interactions - what event handlers and functions reference this element, (4) Impact of your planned changes on the surrounding structure. Then explain what needs to change and how it will integrate. Never skip this step when making incremental updates.',
        input_schema: {
          type: 'object',
          properties: {
            intent: {
              type: 'string',
              description: 'What you want to review/understand/modify. Be descriptive - use the feature name or section name (e.g., "chart section", "analytics dashboard", "add button handler and list rendering"). The tool looks for HTML comments, element IDs/classes, and function names.'
            },
            max_candidates: {
              type: 'number',
              description: 'Maximum number of candidate locations to return (default: 4). Each candidate includes extensive context (up to 300+ lines).'
            }
          },
          required: ['intent']
        }
      },
      {
        name: 'get_code_context',
        description: ' After find_code_locations identifies candidates, use this to get MORE context around a specific location (expands to full function/section). Provide the line number from the candidate you want to expand.  WORKFLOW: This is a preparatory tool for getting additional context - after calling this and reviewing the expanded context, you MUST proceed to call update_html in the SAME TURN to make your changes. DO NOT end your turn after gathering context without making the actual edit!',
        input_schema: {
          type: 'object',
          properties: {
            line_number: {
              type: 'number',
              description: 'The line number from a candidate returned by find_code_locations'
            },
            context_type: {
              type: 'string',
              enum: ['function', 'style_block', 'html_section', 'auto'],
              description: 'Type of context to get. "auto" intelligently detects what the line is part of (default: auto)'
            }
          },
          required: ['line_number']
        }
      },
      {
        name: 'search_html',
        description: ' RARELY NEEDED - Simple exact text search.  USE find_code_locations INSTEAD - it returns 300+ line contexts and is much more useful. Only use search_html if you need to find ALL occurrences of an exact string across the entire file (like finding every instance of a specific color hex code to verify a change). For making edits, ALWAYS use find_code_locations first.',
        input_schema: {
          type: 'object',
          properties: {
            search_term: {
              type: 'string',
              description: 'The exact text to search for (case-sensitive string match)'
            },
            context_lines: {
              type: 'number',
              description: 'Number of lines to show before and after each match (default: 3)'
            }
          },
          required: ['search_term']
        }
      },
      {
        name: 'get_html_section',
        description: ' Get a specific section of the HTML by line range or by searching for surrounding markers. Use this after search_html to retrieve only the section you need to modify. Much faster than getting the entire file.  CRITICAL: The response includes a "section_content" field - this is the EXACT text as it exists in the file with EXACT whitespace/indentation preserved. When using this for update_html, copy the "section_content" field VERBATIM as your old_string - do NOT retype it or modify the whitespace!  WORKFLOW: This is a preparatory tool - after calling this and receiving the section, you MUST immediately call update_html in the SAME TURN to make your changes. DO NOT end your turn after calling this tool without making the actual edit!',
        input_schema: {
          type: 'object',
          properties: {
            start_line: {
              type: 'number',
              description: 'Starting line number (1-indexed). Use with end_line for precise extraction.'
            },
            end_line: {
              type: 'number',
              description: 'Ending line number (1-indexed). Use with start_line for precise extraction.'
            },
            start_marker: {
              type: 'string',
              description: 'Text marker to start extraction from (alternative to start_line)'
            },
            end_marker: {
              type: 'string',
              description: 'Text marker to end extraction at (alternative to end_line)'
            },
            include_context: {
              type: 'boolean',
              description: 'Include 5 lines before and after the section for context (default: false)'
            }
          },
          required: []
        }
      },
      {
        name: 'get_current_html',
        description: ' Get the FULL HTML content from the preview. WARNING: This retrieves the entire file and should only be used for complete rewrites. For editing specific sections, use search_html + get_html_section instead - they are much faster and more efficient.',
        input_schema: {
          type: 'object',
          properties: {},
          required: []
        }
      },
      {
        name: 'update_html',
        description: ' LINE-BASED EDITING (RECOMMENDED): Supports two modes: (1) LINE-BASED (preferred): Specify start_line + end_line + new_string. No whitespace issues! (2) STRING-BASED: Specify old_string + new_string. Requires exact whitespace matching.  WORKFLOW: (1) Call find_code_locations or get_html_section to see the code (note the line numbers), (2) Use LINE-BASED mode with start_line and end_line from the results, (3) Provide new_string with the updated code. LINE-BASED is simpler and more reliable - just specify which lines to replace! This tool performs targeted HTML updates. Use for small to medium changes (adding elements, changing styles, updating text, etc.) instead of regenerating entire HTML.  CRITICAL DESIGN RULE: NEVER use emojis in any updates - they CORRUPT the database! ONLY use Lucide icons (data-lucide attributes) for all visual indicators.  CSS SYNTAX RULES: (1) Inline style="" attributes must NEVER contain curly braces or selectors - WRONG: style=".btn { color: red; }" RIGHT: style="color: red;" (2) When editing <style> blocks, ALWAYS ensure balanced braces - count that every { has a matching } before submitting!  AUTO-ERROR CHECK: After EVERY update, console errors are automatically checked. If your changes introduce errors, success=false and you MUST immediately fix them! The response includes console_check with any errors.  MANDATORY RESPONSE CHECK: After calling this tool, ALWAYS check BOTH success AND console_check.has_errors fields. If has_errors=true, FIX IMMEDIATELY before proceeding. If failed_edits > 0 (even when success=true), some edits FAILED and you MUST recover. If success=false, ALL edits failed. MANDATORY ERROR RECOVERY: If this tool returns success=false OR failed_edits > 0, you MUST IMMEDIATELY continue tool calling in the SAME turn to recover: (1) Review failed_details array, (2) IMMEDIATELY call get_html_section to see the actual structure at those line numbers, (3) IMMEDIATELY retry update_html with corrected values, (4) CONTINUE with remaining changes, (5) NEVER stop or end your turn until failed_edits = 0 and ALL changes are complete.',
        input_schema: {
          type: 'object',
          properties: {
            edits: {
              type: 'array',
              description: 'Array of edit operations. Each edit supports TWO MODES: (1) LINE-BASED (preferred): {start_line, end_line, new_string} - replaces lines start_line through end_line (inclusive) with new_string. No whitespace issues! (2) STRING-BASED: {old_string, new_string} - finds and replaces exact text. Use LINE-BASED whenever possible!',
              items: {
                type: 'object',
                properties: {
                  start_line: {
                    type: 'number',
                    description: 'LINE-BASED MODE: Starting line number (1-indexed, inclusive) to replace. Use with end_line and new_string. Get line numbers from find_code_locations or get_html_section results.'
                  },
                  end_line: {
                    type: 'number',
                    description: 'LINE-BASED MODE: Ending line number (1-indexed, inclusive) to replace. Use with start_line and new_string.'
                  },
                  old_string: {
                    type: 'string',
                    description: 'STRING-BASED MODE: The EXACT text to find and replace. Must match character-for-character including ALL whitespace. Use LINE-BASED mode instead to avoid whitespace issues!'
                  },
                  new_string: {
                    type: 'string',
                    description: 'The new text to insert. CRITICAL: Must be STRUCTURALLY COMPLETE! For CSS: always include full rules with selector + { + properties + }. For JS: include complete functions with closing }. If snippet shows partial code, EXPAND your line range to include closing braces. COUNT YOUR BRACES before submitting - every { needs a matching }!'
                  },
                  description: {
                    type: 'string',
                    description: 'Optional: What this edit does (for logging)'
                  }
                },
                required: ['new_string']
              }
            },
            project_name: {
              type: 'string',
              description: 'Project name (for auto-saving)'
            }
          },
          required: ['edits', 'project_name']
        }
      },
      {
        name: 'generate_html',
        description: ' SLOW full HTML regeneration. Only use for: (1) Creating NEW pages from scratch, (2) Major restructuring, (3) When user explicitly says "rewrite" or "start over". For incremental changes (adding buttons, changing colors, updating text, etc.), use update_html instead - it\'s 10-100x faster.  CRITICAL DESIGN RULE: NEVER use emojis in the HTML - they CORRUPT the database! ONLY use Lucide icons (data-lucide attributes) for all visual indicators.  CSS SYNTAX RULES: (1) Inline style="" attributes must NEVER contain curly braces or selectors - WRONG: style=".class { color: red; }" RIGHT: style="color: red;" (2) In <style> blocks, ALWAYS ensure balanced braces - every { needs a matching }!  AUTO-ERROR CHECK: After generation, console errors are automatically checked. If your code has errors, success=false and you MUST immediately fix them using update_html! The response includes console_check with any errors.  You MUST provide BOTH html_content AND project_name parameters - calling this tool without html_content will result in an error!',
        input_schema: {
          type: 'object',
          properties: {
            html_content: {
              type: 'string',
              description: ' MANDATORY REQUIRED PARAMETER - DO NOT SKIP THIS!  The complete HTML document as a STRING starting with <!DOCTYPE html> and ending with </html>. Must include inline <style> and <script> tags. This is the actual full HTML code. CRITICAL: The current HTML is provided in the user message between ---CURRENT HTML--- markers. Apply changes to it, then provide the COMPLETE modified HTML here. You MUST provide this parameter - calling generate_html without html_content will fail and you will need to retry.'
            },
            project_name: {
              type: 'string',
              description: 'REQUIRED: Name for this project (for auto-saving). Must be a simple descriptive string like "Todo App" or "Chess Game".'
            }
          },
          required: ['html_content', 'project_name']
        }
      },
      {
        name: 'query_database',
        description: ' MANDATORY BEFORE GENERATING CRUD CODE: Get sample records to see EXACT field structure. Your generated save payload MUST match the structure of existing records EXACTLY. Call this with limit: 3 to see sample data, then: (1) LIST every field that appears in sample records, (2) Your payload MUST include ALL those fields, (3) Match field names exactly (case-sensitive), (4) Match value formats (especially TIMESTAMP - use new Date().toISOString() if samples show ISO strings), (5) Match ID generation pattern from samples. DO NOT assume which fields are needed - look at sample data and include ALL fields. This is your GROUND TRUTH for what the save payload should contain.',
        input_schema: {
          type: 'object',
          properties: {
            table_name: { type: 'string', description: 'Simple table name (e.g. "users", "moves", "scores") without project prefix' },
            where_clause: { type: 'string', description: 'Optional SQL WHERE condition (e.g., "status = \'active\'"). You can also include ORDER BY here (e.g., "ORDER BY timestamp DESC") and it will be parsed automatically.' },
            limit: { type: 'number', description: 'Max rows to preview. USE limit: 3 when inspecting for CRUD - enough to see structure without fetching too much' }
          },
          required: ['table_name']
        }
      },
      {
        name: 'list_tables',
        description: 'List all available tables in digital_connection dataset.',
        input_schema: {
          type: 'object',
          properties: {},
          required: []
        }
      },
      {
        name: 'get_project_context',
        description: 'Get project tables and schemas. Returns EXACT table names to use - do not modify them.',
        input_schema: {
          type: 'object',
          properties: {},
          required: []
        }
      },
      {
        name: 'check_table_schema',
        description: ' MANDATORY STEP 1 OF 2: Get table schema (columns, types, nullable). ALWAYS follow up with query_database to see sample records! Returns: (1) Exact field names (case-sensitive), (2) Data types with validation rules in field_validation array, (3) columns_by_type grouping for quick reference, (4) type_validation_rules explaining what each type accepts.  DATA TYPE VALIDATION IS CRITICAL: INT64 requires parseInt(), FLOAT64 requires parseFloat(), BOOL requires actual true/false (not strings!), STRING requires string values. Form inputs are always strings - you MUST convert them! Check field_validation in response for exact conversion rules per field.',
        input_schema: {
          type: 'object',
          properties: {
            table_name: {
              type: 'string',
              description: 'Simple table name (without project prefix)'
            }
          },
          required: ['table_name']
        }
      },
      {
        name: 'save_project',
        description: 'Save the current generated HTML to BigQuery for later use.',
        input_schema: {
          type: 'object',
          properties: {
            project_name: { type: 'string', description: 'Project name' },
            cache_id: { type: 'string', description: 'Optional ID (auto-generated if not provided)' }
          },
          required: ['project_name']
        }
      },
      {
        name: 'load_project',
        description: 'Load an existing project from BigQuery.',
        input_schema: {
          type: 'object',
          properties: {
            cache_id: { type: 'string', description: 'Project cache_id' }
          },
          required: ['cache_id']
        }
      },
      {
        name: 'list_projects',
        description: 'List all saved projects.',
        input_schema: {
          type: 'object',
          properties: {},
          required: []
        }
      },
      {
        name: 'create_table',
        description: 'Create a new table for storing ANY type of data.  CRITICAL: If user wants to save/persist/store/track/remember/record ANY data, you MUST call this BEFORE generating HTML. Trigger words: save, persist, store, database, track, remember, record, resume, history, log. WORKFLOW: 1) get_project_context to check tables, 2) create_table if needed, 3) generate HTML with load/save functions. Design schema to match the data being stored - always include id STRING column, add columns for each piece of data, consider adding created_at or updated_at TIMESTAMP.',
        input_schema: {
          type: 'object',
          properties: {
            table_name: { 
              type: 'string', 
              description: 'Descriptive table name matching the data type (e.g., "tasks", "scores", "notes", "users", "submissions", "game_state"). Auto-prefixed with project ID.' 
            },
            schema: { 
              type: 'array', 
              description: 'REQUIRED: Column definitions matching your data structure. ALWAYS include id STRING. Add columns for each field you need to store.  CRITICAL - TIMESTAMP fields: NEVER set nullable:false for timestamp columns. They auto-populate with CURRENT_TIMESTAMP() and should not be included in save operations. Common patterns: Tasks: [{name:"id",type:"STRING",nullable:false},{name:"text",type:"STRING"},{name:"completed",type:"BOOL"},{name:"created_at",type:"TIMESTAMP"}]. Scores: [{name:"id",type:"STRING",nullable:false},{name:"player_name",type:"STRING"},{name:"score",type:"INT64"},{name:"timestamp",type:"TIMESTAMP"}]. Notes: [{name:"id",type:"STRING",nullable:false},{name:"title",type:"STRING"},{name:"content",type:"STRING"},{name:"updated_at",type:"TIMESTAMP"}]. Use nullable:false ONLY for non-timestamp required fields like id.',
              items: {
                type: 'object',
                properties: {
                  name: { type: 'string', description: 'Column name (lowercase_with_underscores)' },
                  type: { type: 'string', description: 'STRING (text/JSON), INT64 (whole numbers), FLOAT64 (decimals), BOOL (true/false), TIMESTAMP (datetime), DATE' },
                  nullable: { type: 'boolean', description: 'Can be NULL? Default true. Set false for required fields like id.' }
                },
                required: ['name', 'type']
              }
            }
          },
          required: ['table_name', 'schema']
        }
      },
      {
        name: 'modify_table_schema',
        description: ' ADD COLUMN TO EXISTING TABLE - Use ONLY when you need to add a new column to an existing table (schema change).  CRITICAL WORKFLOW: (1) FIRST explain your plan to the user and ASK FOR APPROVAL - tell them which table, which column, what type, what default value, and why. (2) WAIT for user to explicitly approve. (3) ONLY THEN call this tool. This tool shows a technical confirmation dialog with BigQuery limitations. After both approvals, the column will be added. CRITICAL: Check schema first with check_table_schema to verify the column doesn\'t already exist. Only use this if the existing schema is missing a required field.',
        input_schema: {
          type: 'object',
          properties: {
            table_name: {
              type: 'string',
              description: 'Simple table name (without project prefix) to add column to'
            },
            column_name: {
              type: 'string',
              description: 'Name of the new column (lowercase_with_underscores)'
            },
            column_type: {
              type: 'string',
              description: 'Data type: STRING, INT64, FLOAT64, BOOL, TIMESTAMP, DATE, DATETIME, TIME, NUMERIC, JSON'
            },
            default_value: {
              type: 'string',
              description: 'Optional default value. Note: BigQuery will add column without default, then update existing rows.'
            },
            reason: {
              type: 'string',
              description: 'Brief explanation of why this column is needed (shown in confirmation dialog)'
            }
          },
          required: ['table_name', 'column_name', 'column_type', 'reason']
        }
      },
      {
        name: 'get_console_logs',
        description: 'Get console ERROR logs from the preview iframe. This tool ONLY returns console.error() messages which indicate broken functionality in the generated app. Regular console.log() messages, warnings, and user chat messages are NOT included. Use this to check if there are any JavaScript errors, failed API calls, or other critical issues that need to be fixed. Returns error logs with timestamps. If no errors are returned, the app is working correctly.',
        input_schema: {
          type: 'object',
          properties: {
            clear_after_reading: {
              type: 'boolean',
              description: 'Whether to clear the logs after reading them (default: false)'
            },
            last_n: {
              type: 'number',
              description: 'Optional: Return only the last N logs (useful for getting recent activity)'
            }
          },
          required: []
        }
      },
      {
        name: 'execute_javascript',
        description: 'Execute JavaScript code in the preview iframe to test features or simulate user interactions. IMPORTANT: When testing, interact with the UI as a real user would (click buttons, fill forms, submit data) rather than calling functions directly. Use this to simulate user actions like: document.querySelector("#saveBtn").click() or filling form fields. The code runs in the context of the generated app.  CONSOLE OUTPUT: Only console.error() is captured in new_logs - console.log() and console.warn() are NOT returned! To check values during testing, RETURN them from your code (the last expression is returned), or temporarily use console.error() for debugging. Example: return {tableClasses: tableView.className, isActive: tableView.classList.contains("active")}; CRITICAL: This is for TESTING only - do not use this to modify the HTML permanently (use update_html for that). Focus on testing the UI interaction, not bypassing it. After testing and identifying the issue, you MUST call update_html to make the actual fix - testing alone does not complete the task!',
        input_schema: {
          type: 'object',
          properties: {
            code: {
              type: 'string',
              description: 'JavaScript code to execute. To check values, RETURN them (last expression): return {value: someVar, classes: element.className}; Note: console.log() is NOT captured - only console.error() appears in new_logs. Example actions: document.querySelector(\'#myButton\').click(); or fillFormAndSubmit();'
            },
            description: {
              type: 'string',
              description: 'Brief description of what you\'re testing (for logging purposes)'
            }
          },
          required: ['code']
        }
      },
      {
        name: 'create_todo_list',
        description: 'Create a visible todo list to track multi-step feature implementation. Use this when implementing complex features that require multiple steps (database setup, UI changes, logic implementation, testing). The list will be displayed in the chat interface to show progress. Each todo should be specific and actionable.',
        input_schema: {
          type: 'object',
          properties: {
            todos: {
              type: 'array',
              description: 'Array of todo items. Each should have id (string), task (description), and status (pending/in_progress/completed).',
              items: {
                type: 'object',
                properties: {
                  id: { type: 'string', description: 'Unique identifier (1, 2, 3...)' },
                  task: { type: 'string', description: 'Clear description of what needs to be done' },
                  status: { type: 'string', description: 'Status: pending, in_progress, or completed' }
                },
                required: ['id', 'task', 'status']
              }
            }
          },
          required: ['todos']
        }
      },
      {
        name: 'update_todo',
        description: 'Update the status or description of a todo item. Use this to mark items as in_progress when starting them, or completed when finished. This helps track implementation progress visually.',
        input_schema: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              description: 'The todo ID to update'
            },
            status: {
              type: 'string',
              description: 'New status: pending, in_progress, or completed'
            },
            task: {
              type: 'string',
              description: 'Optional: Update the task description'
            }
          },
          required: ['id']
        }
      },
      {
        name: 'verify_edit',
        description: ' MANDATORY VERIFICATION TOOL - Call this AFTER update_html to PROVE your changes were actually inserted. This tool reads back the specific lines where you made changes and confirms the new content exists. You MUST call this after every update_html that returns success=true. Without verification, you CANNOT claim the change was made. The verification_token from update_html response must be passed to this tool.',
        input_schema: {
          type: 'object',
          properties: {
            verification_token: {
              type: 'string',
              description: 'The verification_token returned by the update_html response. This token encodes which lines to verify.'
            },
            expected_snippets: {
              type: 'array',
              description: 'Array of key text snippets that MUST appear in the modified code. Include distinctive parts of your new_string (e.g., new class names, new function names, new text content).',
              items: {
                type: 'string'
              }
            }
          },
          required: ['verification_token', 'expected_snippets']
        }
      },
      {
        name: 'analyze_css_scope',
        description: ' MANDATORY BEFORE CSS CHANGES - Analyzes which elements are affected by a CSS selector. Call this BEFORE modifying any CSS rule to prevent unintended side effects on unrelated components. Returns all elements matching the selector, their locations, and whether it\'s safe to modify.',
        input_schema: {
          type: 'object',
          properties: {
            selector: {
              type: 'string',
              description: 'The CSS selector you plan to modify (e.g., ".btn", ".card-title", "#header .nav-link")'
            },
            proposed_property: {
              type: 'string',
              description: 'Optional: The CSS property you plan to change (e.g., "background-color", "width"). Helps identify potential conflicts.'
            },
            target_description: {
              type: 'string',
              description: 'Describe what specific element/component you intend to style (e.g., "the submit button in the task form", "the title in the header")'
            }
          },
          required: ['selector', 'target_description']
        }
      }
    ];
    
    // ===== CONSOLE LOG CAPTURE SYSTEM =====
    let capturedConsoleLogs = [];
    const MAX_CONSOLE_LOGS = 500; // Keep last 500 logs
    
    /**
     * Wraps HTML with console capturing code that stores logs in iframe's window object
     * This allows us to directly read logs from iframe.contentWindow.__consoleLogs
     * without needing postMessage (same-origin, simpler approach)
     */
    function wrapHTMLWithConsoleCapture(html) {
      // Inject console capture script at the very start of the HTML
      // Using string concatenation to avoid template literal parsing issues
      const consoleInterceptScript = 
'<' + 'script' + '>' + `
(function() {
  // Store logs in window object so parent can read them
  window.__consoleLogs = [];
  window.__maxConsoleLogs = 500;
  
  // Save original console methods
  const originalConsole = {
    log: console.log.bind(console),
    error: console.error.bind(console),
    warn: console.warn.bind(console),
    info: console.info.bind(console)
  };
  
  function captureLog(level, args) {
    const message = Array.from(args).map(arg => {
      if (typeof arg === 'object' && arg !== null) {
        try { return JSON.stringify(arg, null, 2); }
        catch (e) { return String(arg); }
      }
      return String(arg);
    }).join(' ');
    
    const logEntry = {
      timestamp: new Date().toISOString(),
      level: level,
      message: message,
      args: Array.from(args)
    };
    
    window.__consoleLogs.push(logEntry);
    
    // Keep only last N logs
    if (window.__consoleLogs.length > window.__maxConsoleLogs) {
      window.__consoleLogs = window.__consoleLogs.slice(-window.__maxConsoleLogs);
    }
    
    return logEntry;
  }
  
  // Override console methods
  console.log = function(...args) {
    captureLog('log', args);
    originalConsole.log(...args);
  };
  
  console.error = function(...args) {
    captureLog('error', args);
    originalConsole.error(...args);
  };
  
  console.warn = function(...args) {
    captureLog('warn', args);
    originalConsole.warn(...args);
  };
  
  console.info = function(...args) {
    captureLog('info', args);
    originalConsole.info(...args);
  };
  
  // Log that capture is active
})();
` + '<' + '/script' + '>';
      
      // Find where to inject (after <!DOCTYPE html> and <html> tag, or at the very start)
      const htmlTagMatch = html.match(/<html[^>]*>/i);
      if (htmlTagMatch) {
        const insertPos = htmlTagMatch.index + htmlTagMatch[0].length;
        return html.slice(0, insertPos) + consoleInterceptScript + html.slice(insertPos);
      } else {
        // No html tag found, prepend to start
        return consoleInterceptScript + html;
      }
    }
    
    // Function to get console logs from iframe (used by AI tool)
    function getConsoleLogs(clearAfterReading = false, lastN = null) {
      const previewFrame = document.getElementById('previewFrame');
      let logs = [];
      
      // Try to read logs directly from iframe's window object
      if (previewFrame && previewFrame.contentWindow && previewFrame.contentWindow.__consoleLogs) {
        logs = [...previewFrame.contentWindow.__consoleLogs];
        
        if (lastN && lastN > 0) {
          logs = logs.slice(-lastN);
        }
        
        if (clearAfterReading && previewFrame.contentWindow.__consoleLogs) {
          previewFrame.contentWindow.__consoleLogs = [];
        }
      }
      
      return logs;
    }
    
    // Clear console logs when new HTML is loaded
    function clearConsoleLogs() {
      const previewFrame = document.getElementById('previewFrame');
      if (previewFrame && previewFrame.contentWindow && previewFrame.contentWindow.__consoleLogs) {
        previewFrame.contentWindow.__consoleLogs = [];
      }
    }
    
    // Clean up any orphaned streaming messages in the chat
    function cleanupStreamingMessages() {
      const messagesContainer = document.getElementById('chatMessages');
      if (!messagesContainer) return;
      
      // Remove any streaming messages that are still in the DOM
      const streamingMessages = messagesContainer.querySelectorAll('.streaming-message');
      streamingMessages.forEach(msg => {
        if (msg.parentNode) {
          msg.parentNode.removeChild(msg);
        }
      });
    }
    
    // ===== AI CHAT INTEGRATION =====
    
    // Helper to enforce message history limit (25 pairs = 50 messages max to avoid API token limits)
    // Call this after pushing messages to conversationHistory
    function enforceMessageLimit(conversationHistory) {
      const MAX_HISTORY_PAIRS = 25;
      const MAX_HISTORY_MESSAGES = MAX_HISTORY_PAIRS * 2; // 25 pairs = 50 messages
      
      if (conversationHistory.length <= MAX_HISTORY_MESSAGES) {
        return; // Under limit, nothing to do
      }
      
      console.log(` Trimming conversation history: ${conversationHistory.length} messages  ${MAX_HISTORY_MESSAGES}`);
      
      // Calculate how many to remove from the start
      const toRemove = conversationHistory.length - MAX_HISTORY_MESSAGES;
      
      // Remove from the beginning, but respect tool_use/tool_result pairs
      let removed = 0;
      
      while (removed < toRemove && conversationHistory.length > MAX_HISTORY_MESSAGES) {
        const msg = conversationHistory[0];
        
        // If this is an assistant message with tool_use, remove it AND the following tool_result together
        if (msg.role === 'assistant' && Array.isArray(msg.content)) {
          const hasToolUse = msg.content.some(block => block.type === 'tool_use');
          if (hasToolUse && conversationHistory.length > 1) {
            const nextMsg = conversationHistory[1];
            if (nextMsg.role === 'user' && Array.isArray(nextMsg.content) && 
                nextMsg.content.some(block => block.type === 'tool_result')) {
              // Remove both as a pair
              conversationHistory.splice(0, 2);
              removed += 2;
              continue;
            }
          }
        }
        
        // Remove single message from front
        conversationHistory.shift();
        removed++;
      }
      
      console.log(`   Removed ${removed} old messages`);
    }
    
    async function sendMessage(overrideMessage) {
      // ===== ENHANCEMENTS START =====
      const enhState = window.appBuilderEnhancements || {};
      enhState.stopRequested = false;
      if (!canProceed()) {
        addMessageToChat('system', ' System cooling down. Please wait.');
        return;
      }
      const stopBtn = document.getElementById('stopGenerationBtn');
      if (stopBtn) { stopBtn.style.display = 'inline-flex'; if (typeof lucide !== 'undefined') lucide.createIcons(); }
      startWatchdog(120000);
      enhState.streamAbortController = new AbortController();
      window.appBuilderEnhancements = enhState;
      // ===== ENHANCEMENTS END =====

      const input = document.getElementById('chatInput');
      const sendBtn = document.getElementById('chatSendBtn');
      let message = overrideMessage || input.value.trim();
      
      if (!message) return;
      
      //  DETECT USER INTENTION - Think before acting
      // Analyze if user wants explanation/help vs. code generation/fixing
      const messageLower = message.toLowerCase();
      
      // Explanation/Question keywords - user wants to understand, not build/fix
      const isAskingQuestion = (
        messageLower.includes('explain') ||
        messageLower.includes('why') ||
        messageLower.includes('what') ||
        messageLower.includes('how') ||
        messageLower.includes('tell me') ||
        messageLower.includes('help me understand') ||
        messageLower.includes('what\'s happening') ||
        messageLower.includes('whats happening') ||
        messageLower.includes('what is') ||
        messageLower.includes('can you explain') ||
        messageLower.includes('describe') ||
        messageLower.includes('show me why') ||
        message.includes('?')
      );
      
      // Action keywords - user wants code generation/modification
      const isRequestingAction = (
        messageLower.includes('fix') ||
        messageLower.includes('correct') ||
        messageLower.includes('update') ||
        messageLower.includes('change') ||
        messageLower.includes('modify') ||
        messageLower.includes('build') ||
        messageLower.includes('create') ||
        messageLower.includes('add') ||
        messageLower.includes('remove') ||
        messageLower.includes('implement')
      );
      
      // Set global flag for auto-fix logic to check
      window.userIntentIsQuestion = isAskingQuestion && !isRequestingAction;
      
      if (window.userIntentIsQuestion) {
        console.log(' USER INTENTION: Question/Explanation mode - Auto-fix disabled');
      } else {
        console.log(' USER INTENTION: Action/Build mode - Auto-fix enabled if errors occur');
      }
      
      // Check if this is a user-initiated message (not an auto-fix)
      // Auto-fix messages start with "Fix the" and contain "Error:"
      const isAutoFixMessage = overrideMessage && /^Fix the .* (issue|error)/i.test(overrideMessage) && overrideMessage.includes('Error:');
      if (!isAutoFixMessage) {
        // Reset auto-fix counter for user-initiated messages
        autoFixAttempts = 0;
      }
      
      // Append selected element context if available
      const elementContext = getSelectedElementContextForAI();
      
      //  SMART MODIFICATION ANALYSIS: DISABLED - Causing UX issues
      // TODO: Re-enable after fixing the infinite loop and improving detection
      let enhancedContext = elementContext;
      
      /* DISABLED TEMPORARILY
      // Skip analysis if this is a response to a clarification question (yes/no/numbers)
      const isResponseToQuestion = /^(yes|no|1|2|3|tell me more|only change)/i.test(message.trim());
      
      if (selectedElementContext && !overrideMessage && !isResponseToQuestion) {
        const analysis = await analyzeElementModificationContext(message, selectedElementContext);
        if (analysis.needsClarification) {
          // Ask user for clarification before proceeding
          addMessageToChat('system', analysis.clarificationMessage);
          input.disabled = false;
          sendBtn.disabled = false;
          input.focus();
          return; // Wait for user response
        }
        // Enhance context with analysis findings
        if (analysis.contextEnhancement) {
          enhancedContext += analysis.contextEnhancement;
        }
      }
      */
      
      const messageWithContext = enhancedContext ? message + enhancedContext : message;
      
      // Wait for chat history to finish loading if it's in progress
      if (chatHistoryLoadingPromise) {
        console.log(' Waiting for chat history to finish loading...');
        await chatHistoryLoadingPromise;
        console.log(' Chat history loading complete, proceeding with message');
      }
      
      // Clean up any orphaned streaming messages before starting
      cleanupStreamingMessages();
      
      // Disable input
      input.disabled = true;
      sendBtn.disabled = true;
      
      // Capture ALL reference images before clearing them
      // Clone the array so we have a snapshot of all images at send time
      const messageImages = referenceImages.length > 0 ? [...referenceImages] : [];
      
      // Add user message with next version number (will be created after response)
      // Display the original message (without element context) in chat
      const nextVersionNumber = currentVersionNumber + 1;
      addMessageToChat('user', message, nextVersionNumber, false, messageImages);
      
      // Clear selected element after sending
      if (selectedElementContext) {
        clearSelectedElement();
      }
      
      // Only clear input if not using override message
      if (!overrideMessage) {
        input.value = '';
        input.style.height = 'auto';
      }
      
      const typingId = addTypingIndicator();
      
      // Show console log status in typing indicator
      const consoleLogs = getConsoleLogs(false, 100);
      if (consoleLogs.length > 0) {
        const typingIndicator = document.getElementById(typingId);
        if (typingIndicator) {
          const logsByLevel = {
            error: consoleLogs.filter(l => l.level === 'error').length,
            warn: consoleLogs.filter(l => l.level === 'warn').length
          };
          const statusText = logsByLevel.error > 0 
            ? ` Reading ${consoleLogs.length} logs (${logsByLevel.error} errors) from preview...`
            : ` Reading ${consoleLogs.length} logs from preview...`;
          typingIndicator.innerHTML = `<div style="padding: 8px; color: #6b7280; font-size: 13px;">${statusText}</div><div class="typing-indicator"><span></span><span></span><span></span></div>`;
        }
      }
      
      try {
        // Detect if we're working with images and what the user's intent is
        const hasImages = messageImages.length > 0;
        let systemPrompt;
        
        if (hasImages) {
          // Detect the user's intent with the image(s)
          const imageIntent = detectImageIntent(message, true);
          console.log(` Image Intent Detected in sendMessage: ${imageIntent}`);
          console.log(`   Total images: ${messageImages.length}`);
          
          // Use different system prompts based on intent:
          // - BUILD_FROM_IMAGE: User wants to create an app  use HTML generator prompt
          // - EXPLAIN_IMAGE/ANALYZE_IMAGE: User wants explanation  use image analysis prompt
          if (imageIntent === 'BUILD_FROM_IMAGE') {
            systemPrompt = getSystemPrompt();
            console.log('   Using HTML generator system prompt');
          } else {
            systemPrompt = getImageAnalysisSystemPrompt();
            console.log('   Using image analysis system prompt (no HTML generation)');
          }
        } else {
          // No image, use standard HTML generator prompt
          systemPrompt = getSystemPrompt();
        }
        
        const response = await callCodePuppyAPI(messageWithContext, systemPrompt, chatConversationHistory);

        
        // Wait a brief moment to ensure preview updates complete before showing response
        await new Promise(resolve => setTimeout(resolve, 300));
        
        removeTypingIndicator(typingId);
        
        if (response) {
          addMessageToChat('assistant', response);
        }
        
        // Clear reference images after successful use so they don't attach to next message
        if (messageImages.length > 0) {
          referenceImages = [];
          referenceImageData = null;
          referenceImageName = null;
          const refDisplay = document.getElementById('referenceImageDisplay');
          if (refDisplay) refDisplay.style.display = 'none';
        }
        
        // Save chat history after each exchange
        await saveChatHistory();
      } catch (error) {
        console.error(' Error in sendMessage:', error);
        removeTypingIndicator(typingId);
        addMessageToChat('system error', `We encountered an issue processing your request. Please try again or rephrase your message.`);
      }
      
      // Re-enable input
      input.disabled = false;
      sendBtn.disabled = false;
      input.focus();
      
      // Cleanup abort controller and disable stop button
      currentAbortController = null;
      const stopBtn = document.getElementById('btnStop');
      if (stopBtn) stopBtn.disabled = true;
    }
    
    // Track streaming message element
    let currentStreamingMessageElement = null;
    let currentStreamingTextBlock = null;
    let currentStreamingTextContainer = null;
    
    async function processStreamingResponse(response) {
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      
      // Accumulated response data
      let messageStart = null;
      let contentBlocks = [];
      let currentTextContent = '';
      let currentToolUse = null;
      let stopReason = null;
      let usage = null;
      
      // Create progress indicator instead of showing raw streaming text
      createProgressIndicator();
      
      // Hidden containers for accumulating content (not shown to user during build)
      let hasToolCalls = false;
      let accumulatedThinking = '';
      
      const messagesContainer = document.getElementById('chatMessages');
      
      
      try {
        while (true) {
          const { done, value } = await reader.read();
          
          if (done) {
            break;
          }
          
          // Decode the chunk and add to buffer
          buffer += decoder.decode(value, { stream: true });
          
          // Process complete lines (SSE format: "data: {...}\n\n")
          const lines = buffer.split('\n');
          buffer = lines.pop() || ''; // Keep incomplete line in buffer
          
          for (const line of lines) {
            if (!line.trim() || line.trim() === '') continue;
            
            // SSE format: "data: {...}" or "event: ..."
            if (line.startsWith('data: ')) {
              const dataStr = line.slice(6); // Remove "data: " prefix
              
              if (dataStr === '[DONE]') {
                continue;
              }
              
              try {
                const event = JSON.parse(dataStr);
                
                switch (event.type) {
                  case 'message_start':
                    messageStart = event.message;
                    break;
                    
                  case 'content_block_start':
                    const block = event.content_block;
                    if (block.type === 'text') {
                      currentTextContent = '';
                      // AI is thinking/explaining - show this phase
                      if (currentProgressIndicator) {
                        progressPhase = 'thinking';
                        updateProgressIndicator('thinking', 'Processing your request...');
                      }
                    } else if (block.type === 'tool_use') {
                      currentToolUse = { ...block, input: {} };
                      hasToolCalls = true; // Mark that we have tool calls
                      
                      // Determine progress phase based on tool
                      const toolName = block.name;
                      if (toolName === 'get_project_context' || toolName === 'get_current_html' || toolName === 'find_code_locations' || toolName === 'check_table_schema' || toolName === 'query_database') {
                        progressPhase = 'planning';
                      } else if (toolName === 'generate_html' || toolName === 'update_html' || toolName === 'create_table' || toolName === 'modify_table_schema') {
                        progressPhase = 'implementing';
                      }
                      
                      // Update progress indicator instead of showing tool name
                      if (currentProgressIndicator) {
                        const progressMessage = getProgressStage(toolName, block);
                        updateProgressIndicator(progressPhase, progressMessage);
                      }
                      
                      // Hide technical details - don't show tool execution in chat
                      // (Original code showed: " Executing tool: tool_name")
                    }
                    break;
                    
                  case 'content_block_delta':
                    if (event.delta.type === 'text_delta') {
                      // Accumulate text content silently (don't stream to UI during build)
                      const textDelta = event.delta.text;
                      currentTextContent += textDelta;
                      accumulatedThinking += textDelta;
                      
                      // Only show thinking text if there are NO tool calls (pure chat response)
                      // Otherwise keep it hidden behind progress indicator
                    } else if (event.delta.type === 'input_json_delta') {
                      // Accumulate tool input
                      if (currentToolUse) {
                        currentToolUse.partial_json = (currentToolUse.partial_json || '') + event.delta.partial_json;
                      }
                    }
                    break;
                    
                  case 'content_block_stop':
                    if (currentTextContent) {
                      contentBlocks.push({
                        type: 'text',
                        text: currentTextContent
                      });
                      currentTextContent = ''; // Reset for next block
                    }
                    if (currentToolUse) {
                      // Parse the accumulated JSON
                      try {
                        currentToolUse.input = JSON.parse(currentToolUse.partial_json || '{}');
                        delete currentToolUse.partial_json;
                        
                        // Validate update_html edits have complete new_string values
                        if (currentToolUse.name === 'update_html' && currentToolUse.input.edits) {
                          const edits = currentToolUse.input.edits;
                          for (let i = 0; i < edits.length; i++) {
                            const edit = edits[i];
                            if (edit.new_string === undefined || edit.new_string === null) {
                              console.error(` TRUNCATED RESPONSE: Edit #${i + 1} has no new_string - AI response was likely cut off`);
                              // Mark the edit as potentially truncated
                              edit._truncated = true;
                              edit._warning = 'new_string was undefined - response may have been cut off';
                            }
                          }
                        }
                        
                        contentBlocks.push(currentToolUse);
                      } catch (e) {
                        // Failed to parse tool input - likely response was cut off
                        console.warn(` Failed to parse tool input for ${currentToolUse.name}:`, e.message);
                        console.warn(`Partial JSON received:`, currentToolUse.partial_json);
                        // Don't add incomplete tool to contentBlocks - will trigger retry logic
                      }
                      currentToolUse = null;
                    }
                    break;
                    
                  case 'message_delta':
                    if (event.delta.stop_reason) {
                      stopReason = event.delta.stop_reason;
                    }
                    if (event.usage) {
                      usage = event.usage;
                    }
                    break;
                    
                  case 'message_stop':
                    break;
                    
                  case 'error':
                    throw new Error(event.error.message || 'Stream error');
                }
              } catch (parseError) {
                // Failed to parse SSE data, skip this event
              }
            }
          }
        }
      } catch (error) {
        throw error;
      } finally {
        // Clean up progress indicator
        removeProgressIndicator();
        
        // Extra safety: clean up any orphaned streaming messages
        cleanupStreamingMessages();
      }
      
      // Reconstruct the response in the same format as non-streaming
      const reconstructedResponse = {
        id: messageStart?.id || 'unknown',
        type: 'message',
        role: 'assistant',
        content: contentBlocks,
        model: messageStart?.model,
        stop_reason: stopReason,
        usage: usage || messageStart?.usage
      };
      
      return reconstructedResponse;
    }
    
    // ===== CONVERSATION HISTORY VALIDATION =====
    // Validates and repairs conversation history before sending to API
    // Fixes issues like orphaned tool_result blocks, mismatched tool_use_id, etc.
    function validateAndRepairConversationHistory(messages) {
      if (!Array.isArray(messages) || messages.length === 0) {
        console.log(' Validation: Empty conversation history');
        return [];
      }
      
      console.log(` Validating conversation history (${messages.length} messages)...`);
      
      const repairedMessages = [];
      let repairsMade = 0;
      
      for (let i = 0; i < messages.length; i++) {
        const msg = messages[i];
        const prevMsg = repairedMessages[repairedMessages.length - 1];
        
        // Basic structure validation
        if (!msg || !msg.role || msg.content === undefined) {
          console.warn(` Skipping invalid message at index ${i}:`, msg);
          repairsMade++;
          continue;
        }
        
        // Handle user messages
        if (msg.role === 'user') {
          // Check if content is an array (could contain tool_result blocks)
          if (Array.isArray(msg.content)) {
            const toolResults = msg.content.filter(block => block.type === 'tool_result');
            
            if (toolResults.length > 0) {
              // This is a tool result message - validate it has matching tool_use blocks
              if (!prevMsg || prevMsg.role !== 'assistant') {
                // Skip orphaned tool_result messages - they would cause API errors
                console.warn(` Found tool_result without preceding assistant message at index ${i}, skipping`);
                repairsMade++;
                continue;
              }
              
              // Get tool_use IDs from previous assistant message
              const prevContent = Array.isArray(prevMsg.content) ? prevMsg.content : [];
              const toolUseIds = new Set(
                prevContent
                  .filter(block => block.type === 'tool_use')
                  .map(block => block.id)
              );
              
              // Filter out tool_results with no matching tool_use
              const validToolResults = [];
              const otherContent = [];
              
              for (const block of msg.content) {
                if (block.type === 'tool_result') {
                  if (toolUseIds.has(block.tool_use_id)) {
                    validToolResults.push(block);
                  } else {
                    console.warn(` Removing orphaned tool_result with id: ${block.tool_use_id}`);
                    repairsMade++;
                  }
                } else {
                  otherContent.push(block);
                }
              }
              
              // If we have valid tool results, keep them
              if (validToolResults.length > 0) {
                const repairedContent = [...validToolResults, ...otherContent];
                repairedMessages.push({
                  role: 'user',
                  content: repairedContent
                });
              } else if (otherContent.length > 0) {
                // No valid tool results but have other content - keep that
                repairedMessages.push({
                  role: 'user',
                  content: otherContent
                });
              }
              // If nothing valid left, skip the message
            } else {
              // No tool results, just add the message as-is
              repairedMessages.push(msg);
            }
          } else {
            // String content, add as-is
            repairedMessages.push(msg);
          }
        }
        // Handle assistant messages
        else if (msg.role === 'assistant') {
          // Validate content array if present
          if (Array.isArray(msg.content)) {
            const validContent = msg.content.filter(block => {
              // Ensure tool_use blocks have required fields
              if (block.type === 'tool_use') {
                if (!block.id || !block.name) {
                  console.warn(` Removing invalid tool_use block:`, block);
                  repairsMade++;
                  return false;
                }
              }
              return true;
            });
            
            if (validContent.length > 0) {
              repairedMessages.push({
                role: 'assistant',
                content: validContent
              });
            } else {
              console.warn(` Skipping empty assistant message at index ${i}`);
              repairsMade++;
            }
          } else if (typeof msg.content === 'string' && msg.content.trim()) {
            repairedMessages.push(msg);
          } else {
            console.warn(` Skipping invalid assistant message at index ${i}`);
            repairsMade++;
          }
        }
        // Skip unknown roles
        else {
          console.warn(` Skipping message with unknown role: ${msg.role}`);
          repairsMade++;
        }
      }
      
      // Final pass: ensure proper message alternation
      // Claude API requires messages to alternate between user and assistant
      const finalMessages = [];
      let skippedToolUseIds = new Set(); // Track tool_use IDs from skipped assistant messages
      
      for (let i = 0; i < repairedMessages.length; i++) {
        const msg = repairedMessages[i];
        const lastMsg = finalMessages[finalMessages.length - 1];
        
        // First message must be from user
        if (finalMessages.length === 0 && msg.role !== 'user') {
          console.warn(` First message must be from user, skipping assistant message`);
          repairsMade++;
          
          // Track tool_use IDs being skipped so we can also skip their tool_results
          if (Array.isArray(msg.content)) {
            const toolUseBlocks = msg.content.filter(b => b.type === 'tool_use');
            toolUseBlocks.forEach(b => {
              if (b.id) skippedToolUseIds.add(b.id);
            });
          }
          continue;
        }
        
        // CRITICAL: Check if this user message contains tool_results for skipped tool_use blocks
        // or tool_results without a valid preceding assistant message in finalMessages
        if (msg.role === 'user' && Array.isArray(msg.content)) {
          const toolResults = msg.content.filter(b => b.type === 'tool_result');
          
          if (toolResults.length > 0) {
            // Get tool_use IDs from the previous assistant message in finalMessages (if any)
            const prevAssistant = finalMessages.length > 0 ? finalMessages[finalMessages.length - 1] : null;
            const validToolUseIds = new Set();
            
            if (prevAssistant && prevAssistant.role === 'assistant' && Array.isArray(prevAssistant.content)) {
              prevAssistant.content
                .filter(b => b.type === 'tool_use' && b.id)
                .forEach(b => validToolUseIds.add(b.id));
            }
            
            // Filter out tool_results that reference skipped or missing tool_use blocks
            const validContent = [];
            let droppedResults = 0;
            
            for (const block of msg.content) {
              if (block.type === 'tool_result') {
                const toolUseId = block.tool_use_id;
                
                // Drop if: the tool_use was explicitly skipped, OR no valid tool_use exists for it
                if (skippedToolUseIds.has(toolUseId) || !validToolUseIds.has(toolUseId)) {
                  console.warn(` Dropping orphaned tool_result (id: ${toolUseId}) - no valid tool_use in finalMessages`);
                  repairsMade++;
                  droppedResults++;
                  continue;
                }
              }
              validContent.push(block);
            }
            
            // If all content was tool_results and all were dropped, skip this message entirely
            if (validContent.length === 0) {
              console.warn(` Skipping user message - all tool_results were orphaned`);
              continue;
            }
            
            // Update message content with only valid content
            if (droppedResults > 0) {
              msg.content = validContent;
            }
          }
        }
        
        // Check for proper alternation
        if (lastMsg && lastMsg.role === msg.role) {
          // Same role twice in a row - merge or skip
          if (msg.role === 'user') {
            // Merge user messages - but NEVER merge tool_results into the first message
            // if there's no preceding assistant with tool_use
            console.warn(` Merging consecutive user messages`);
            repairsMade++;
            
            // Before merging, strip any tool_results from msg if lastMsg is the first message
            // and there's no preceding assistant
            let contentToMerge = msg.content;
            if (finalMessages.length === 1 && Array.isArray(msg.content)) {
              // lastMsg is the first and only message - don't merge tool_results into it
              const nonToolResults = msg.content.filter(b => b.type !== 'tool_result');
              const droppedCount = msg.content.length - nonToolResults.length;
              if (droppedCount > 0) {
                console.warn(` Stripping ${droppedCount} tool_results from merge - no valid preceding tool_use`);
                contentToMerge = nonToolResults;
                repairsMade += droppedCount;
              }
            }
            
            // Skip merge if nothing left to merge
            if (Array.isArray(contentToMerge) && contentToMerge.length === 0) {
              continue;
            }
            
            if (Array.isArray(lastMsg.content) && Array.isArray(contentToMerge)) {
              lastMsg.content = [...lastMsg.content, ...contentToMerge];
            } else if (typeof lastMsg.content === 'string' && typeof contentToMerge === 'string') {
              lastMsg.content = lastMsg.content + '\n\n' + contentToMerge;
            } else if (typeof lastMsg.content === 'string' && (!Array.isArray(contentToMerge) || contentToMerge.length === 0)) {
              // Nothing to merge
              continue;
            } else {
              // Mixed types - convert to array
              const lastContent = Array.isArray(lastMsg.content) 
                ? lastMsg.content 
                : [{ type: 'text', text: String(lastMsg.content) }];
              const newContent = Array.isArray(contentToMerge)
                ? contentToMerge
                : [{ type: 'text', text: String(contentToMerge) }];
              lastMsg.content = [...lastContent, ...newContent];
            }
            continue;
          } else {
            // Skip consecutive assistant messages
            console.warn(` Skipping consecutive assistant message`);
            repairsMade++;
            continue;
          }
        }
        
        finalMessages.push(msg);
      }
      
      // FINAL SAFEGUARD: Double-check first message doesn't have tool_results
      if (finalMessages.length > 0) {
        const firstMsg = finalMessages[0];
        if (firstMsg.role === 'user' && Array.isArray(firstMsg.content)) {
          const hasToolResult = firstMsg.content.some(b => b.type === 'tool_result');
          if (hasToolResult) {
            console.error(' CRITICAL: First message still has tool_result after repair - stripping them');
            firstMsg.content = firstMsg.content.filter(b => b.type !== 'tool_result');
            repairsMade++;
            
            // If nothing left, we need to return empty and let caller handle it
            if (firstMsg.content.length === 0) {
              console.error(' First message is now empty after stripping tool_results');
              finalMessages.shift();
            }
          }
        }
      }
      
      // Ensure we don't end with a dangling tool_use without tool_result
      if (finalMessages.length > 0) {
        const lastMsg = finalMessages[finalMessages.length - 1];
        if (lastMsg.role === 'assistant' && Array.isArray(lastMsg.content)) {
          const hasToolUse = lastMsg.content.some(block => block.type === 'tool_use');
          if (hasToolUse) {
            // Check if there's a following tool_result - if not, we have an issue
            // This is okay at the end if we're about to execute tools
            console.log(' Last assistant message has tool_use - tools will be executed');
          }
        }
      }
      
      if (repairsMade > 0) {
        console.log(` Conversation history repaired: ${repairsMade} issues fixed`);
        console.log(` Messages: ${messages.length} -> ${finalMessages.length}`);
      } else {
        console.log(` Conversation history valid (${finalMessages.length} messages)`);
      }
      
      return finalMessages;
    }
    
    // ===== PROGRESS STAGE MAPPING =====
    // Maps technical tool names to user-friendly progress stages
    function getProgressStage(toolName, toolInput) {
      const stages = {
        // Planning phase
        'get_project_context': ' Analyzing existing project structure...',
        'get_current_html': ' Reviewing current application...',
        'find_code_locations': ' Locating relevant code sections...',
        
        // Database planning
        'check_table_schema': ' Reviewing database structure...',
        'query_database': ' Analyzing existing data...',
        
        // Implementation phase
        'create_table': ' Setting up database tables...',
        'modify_table_schema': ' Updating database schema...',
        'generate_html': ' Building your application...',
        'update_html': ' Implementing changes...',
        
        // Testing phase
        'get_console_logs': ' Testing functionality...',
      };
      
      return stages[toolName] || ' Processing...';
    }
    
    // Track current progress stage
    let currentProgressIndicator = null;
    let progressPhase = 'thinking'; // thinking, planning, implementing
    
    function updateProgressIndicator(phase, message) {
      if (!currentProgressIndicator) return;
      
      const phaseEmojis = {
        thinking: '',
        planning: '',
        implementing: ''
      };
      
      const phaseLabels = {
        thinking: 'Thinking',
        planning: 'Planning',
        implementing: 'Implementation'
      };
      
      const emoji = phaseEmojis[phase] || '';
      const label = phaseLabels[phase] || 'Processing';
      
      currentProgressIndicator.innerHTML = `
        <div style="display: flex; align-items: center; gap: 8px;">
          <span style="font-size: 18px;">${emoji}</span>
          <div>
            <div style="font-weight: 600; margin-bottom: 2px;">${label} in progress</div>
            <div style="font-size: 12px; opacity: 0.8;">${message || ''}</div>
          </div>
        </div>
      `;
    }
    
    function createProgressIndicator() {
      if (currentProgressIndicator) return currentProgressIndicator;
      
      const messagesContainer = document.getElementById('chatMessages');
      const progressDiv = document.createElement('div');
      progressDiv.className = 'chat-message assistant streaming-message';
      progressDiv.style.cssText = 'background: linear-gradient(135deg, rgba(0, 83, 226, 0.05) 0%, rgba(0, 83, 226, 0.02) 100%); border-left: 3px solid var(--primary-blue);';
      
      const messageContent = document.createElement('div');
      messageContent.className = 'message-content';
      progressDiv.appendChild(messageContent);
      
      messagesContainer.appendChild(progressDiv);
      currentProgressIndicator = messageContent;
      
      // Auto-scroll
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      updateProgressIndicator('thinking', 'Analyzing your request...');
      
      return progressDiv;
    }
    
    function removeProgressIndicator() {
      if (currentProgressIndicator && currentProgressIndicator.parentElement) {
        currentProgressIndicator.parentElement.remove();
      }
      currentProgressIndicator = null;
      progressPhase = 'thinking';
    }
    
    // ===== IMAGE INTENT DETECTION & SMART PROMPTING =====
    // Detects what the user wants to do with the uploaded image
    function detectImageIntent(message, hasImage) {
      if (!hasImage) return null;
      
      const msg = message.toLowerCase().trim();
      
      // Build/create keywords (HIGHEST PRIORITY - checked first)
      const buildKeywords = [
        'build', 'create', 'make', 'implement', 'design',
        'replicate', 'code this', 'develop', 'construct',
        'generate', 'recreate', 'copy', 'clone', 'reproduce',
        'code it', 'write code', 'program', 'develop this'
      ];
      
      // Check for build keywords first (takes priority over questions)
      if (buildKeywords.some(keyword => msg.includes(keyword))) {
        return 'BUILD_FROM_IMAGE';
      }
      
      // No message or very short (just uploaded image)
      if (msg.length < 5) {
        return 'EXPLAIN_IMAGE';
      }
      
      // Question indicators (only if no build keywords found)
      if (msg.includes('?') || 
          msg.startsWith('what') || 
          msg.startsWith('how') || 
          msg.startsWith('why') ||
          msg.startsWith('where') ||
          msg.startsWith('when') ||
          msg.startsWith('who') ||
          msg.startsWith('explain') ||
          msg.startsWith('describe') ||
          msg.startsWith('tell me') ||
          msg.startsWith('show me') ||
          msg.includes('what is') ||
          msg.includes('what are') ||
          msg.includes('what does')) {
        return 'ANALYZE_IMAGE';
      }
      
      // Default: analyze and answer (safe fallback)
      return 'ANALYZE_IMAGE';
    }
    
    // Image prompt templates for different intents
    const IMAGE_PROMPTS = {
      EXPLAIN_IMAGE: `

 IMAGE DESCRIPTION REQUEST:
The user has uploaded an image without any specific question or instruction.
Please carefully examine the image and provide a comprehensive description including:

 **Content Type**: What kind of image is this? (screenshot, diagram, photo, document, UI mockup, code snippet, etc.)
 **Key Information**: Any text, labels, titles, or important information visible in the image
 **Visual Elements**: Layout, structure, colors, components, shapes
 **Details**: Notable features, patterns, or elements worth mentioning
 **Context**: If it's a UI/website, describe the interface elements and their purpose
 **Technical Content**: If it contains code, formulas, or technical diagrams, read and explain them

Be thorough, clear, and informative in your description. Help the user understand what's in the image.
`,

      ANALYZE_IMAGE: `

 IMAGE ANALYSIS & QUESTION RESPONSE:
The user has uploaded an image and asked a question or made a request about it.

**Your task:**
1. Carefully examine the image to understand its content
2. Extract relevant information from the image that relates to their question
3. Read any text, code, or data visible in the image
4. Provide a clear, direct answer to their question
5. Reference specific details from the image to support your answer
6. If the image contains errors, issues, or problems they're asking about, identify and explain them

**User's question/request:** {userMessage}

Analyze the image and provide a helpful, accurate response.
`,

      BUILD_FROM_IMAGE: `

 DESIGN REFERENCE PROVIDED:
The user wants you to build/create something based on this image.
Use the image as design inspiration and carefully analyze:

 **Layout Structure**: spacing, alignment, grid systems, component positioning, hierarchy
 **Visual Design**: colors, typography, shadows, borders, gradients, visual effects
 **Interactive Elements**: buttons, forms, inputs, navigation, hover states, animations
 **Responsive Behavior**: how elements should adapt to different screen sizes
 **Accessibility**: proper contrast, semantic HTML, ARIA labels, keyboard navigation
 **Component Details**: exact styling of individual UI components

Create clean, semantic HTML and efficient CSS that matches the visual style shown in the image.
Match the design as closely as possible while maintaining code quality and best practices.
`
    };
    
    async function callCodePuppyAPI(userMessage, systemPrompt, conversationHistory) {
      // Build user message with context based on mode
      let enhancedMessage = userMessage;
      
      // Inject chat history summary for first message in session after loading prior history
      console.log(` Checking history injection: needsHistorySummaryInjection=${needsHistorySummaryInjection}, summaryLength=${loadedChatHistorySummary?.length || 0}`);
      if (needsHistorySummaryInjection && loadedChatHistorySummary) {
        enhancedMessage = loadedChatHistorySummary + enhancedMessage;
        console.log(` Injected chat history summary (${loadedChatHistorySummary.length} chars)`);
        needsHistorySummaryInjection = false;
      } else if (needsHistorySummaryInjection && !loadedChatHistorySummary) {
        console.warn(` needsHistorySummaryInjection=true but summary is empty!`);
      } else if (!needsHistorySummaryInjection && loadedChatHistorySummary) {
        console.log(` Summary exists but injection already done (needsHistorySummaryInjection=false)`);
      } 
      // FALLBACK: If no conversation history but we have UI messages, generate summary from those
      else if (conversationHistory.length === 0 && chatUIMessages.length > 0) {
        const uiSummary = generateUIMessagesSummary(chatUIMessages);
        if (uiSummary) {
          enhancedMessage = uiSummary + enhancedMessage;
          console.log(` Injected UI messages summary as fallback (${uiSummary.length} chars)`);
        }
      }
      // FALLBACK 2: If we have existing HTML but no history, mention it
      else if (conversationHistory.length === 0 && generatedHTML && generatedHTML.trim() !== '') {
        const isWelcomeScreen = generatedHTML.includes('Welcome to App Builder') || 
                                generatedHTML.includes('Ask the AI to build something');
        if (!isWelcomeScreen) {
          const htmlContext = `=== SESSION CONTEXT ===
This is a continuation of a previous session. An application already exists in the preview.
You should continue building on the existing app rather than starting from scratch.
=== END SESSION CONTEXT ===

`;
          enhancedMessage = htmlContext + enhancedMessage;
          console.log(` Injected basic session context (existing HTML detected)`);
        }
      }
      
      // Add reference SVG if attached
      if (referenceImageData && window.isReferenceSVGText) {
        enhancedMessage += '\n\n=== REFERENCE SVG CODE (from uploaded file) ===\n' +
          referenceImageData +
          '\n=== END SVG CODE ===\n\n' +
          'Incorporate this SVG code into a complete HTML page. Create a full HTML document that displays this SVG properly.';
      }
      
      // Build user content - inject current HTML if it exists, include reference image if attached
      let userContent;
      let textContent = enhancedMessage;
      
      // CURSOR-STYLE APPROACH: NEVER send full HTML in conversation messages
      // This matches how Cursor works - file state is maintained separately, conversation only has diffs
      // 
      // How this works:
      // 1. File state (generatedHTML) is maintained in memory/database
      // 2. Conversation NEVER contains full HTML - only diffs and metadata
      // 3. AI uses get_current_html tool when it needs to see file contents
      // 4. AI uses update_html tool to make changes (sends only diffs)
      // 5. Much more efficient and scalable for long conversations
      //
      // This is EXACTLY how Cursor works!
      
      // Check if we have a real app or just the welcome screen placeholder
      const isWelcomeScreen = generatedHTML && (
        generatedHTML.includes('Welcome to App Builder') || 
        generatedHTML.includes('Ask the AI to build something')
      );
      
      if (currentMode === 'agent' && generatedHTML && generatedHTML.trim() !== '' && !isWelcomeScreen) {
        // Real HTML exists - use iterative editing workflow
        const htmlSizeKB = (generatedHTML.length / 1024).toFixed(1);
        const totalLines = generatedHTML.split('\n').length;
        
        // Build base message
        textContent = `USER REQUEST: ${enhancedMessage}

 CONTEXT: Active HTML file exists (${htmlSizeKB} KB, ${totalLines} lines)

 THINK FIRST (spend 5-10 seconds reasoning):
1. What exactly does the user want? Break down the requirement.
2. What parts of the code need to change? (UI? Logic? Data? Styling?)
3. Do I know where these parts are, or do I need to search?
4. What's the best sequence of changes?

 THEN EXECUTE:
1. DON'T KNOW where?  find_code_locations("what to change")
   Returns 4 candidates with 150-300 lines EACH - usually enough to make edits!
   
2. KNOW where?  update_html directly with ALL changes in ONE call

 QUALITY TIPS:
- Think through the full solution before starting
- Consider edge cases and how changes interact
- Batch multiple edits in one update_html call
- Test your logic mentally before implementing`;
        
        // If no existing copy in conversation, include the full HTML for better accuracy
        // Use flag instead of scanning through all messages
        if (!conversationHasFullHTML) {
          textContent += `

---CURRENT HTML---
 Full HTML context included for reference (${htmlSizeKB} KB).
This helps maintain accuracy across incremental updates.

${generatedHTML}
---END HTML---`;
          
          // Set flag to true since we're adding HTML now
          conversationHasFullHTML = true;
        }
      } else if (currentMode === 'agent' && (!generatedHTML || generatedHTML.trim() === '' || isWelcomeScreen)) {
        // No real HTML exists yet (empty or just welcome screen)
        
        // Check if user uploaded images and wants analysis only (not building)
        const hasImagesForAnalysis = referenceImages.length > 0;
        const imageFilesForAnalysis = hasImagesForAnalysis ? referenceImages.filter(img => !img.isSVGText) : [];
        let isImageAnalysisOnly = false;
        
        if (imageFilesForAnalysis.length > 0) {
          const imageIntent = detectImageIntent(userMessage, true);
          // If intent is EXPLAIN or ANALYZE, skip the build workflow
          isImageAnalysisOnly = (imageIntent === 'EXPLAIN_IMAGE' || imageIntent === 'ANALYZE_IMAGE');
          console.log(` Image analysis only mode: ${isImageAnalysisOnly} (intent: ${imageIntent})`);
        }
        
        if (isImageAnalysisOnly) {
          // User wants image analysis/explanation, not app building
          // Just use their message as-is, don't add build workflow instructions
          textContent = enhancedMessage;
        } else {
          // Need to generate from scratch - add build workflow instructions
          textContent = ` MANDATORY WORKFLOW - YOU MUST COMPLETE ALL STEPS:
This is a FIRST PROJECT CREATION (no HTML exists yet). You MUST call generate_html tool before finishing!

USER REQUEST: ${enhancedMessage}

 CONTEXT: No application HTML exists yet (empty cache = first project creation)

 THINK FIRST - PLANNING PHASE (spend 10-15 seconds):
1. What is the user building? What's the core functionality?
2. Does this need data persistence? (keywords: save, store, track, remember, persist, database)
3. What UI components are needed? (forms, buttons, lists, charts, etc.)
4. What's the complete user flow? (load  interact  save  reload)
5. Plan the database schema if needed (what fields? what types?)
6. Plan the HTML structure (layout, styling, interactivity)

 THEN EXECUTE: Build COMPLETE application by CALLING TOOLS IN SEQUENCE

STEP-BY-STEP WORKFLOW (DO IN ORDER - USE ACTUAL TOOL CALLS):
1 Detect if user wants data persistence:
   Keywords: "save", "persist", "store", "database", "track", "remember", "record", "resume", "history", "log"
   Examples: "save tasks", "track scores", "remember user input", "store form data", "persist game state"

2 IF persistence detected - CALL THESE DATABASE TOOLS IN ORDER:
   a) TOOL CALL: get_project_context  see existing tables
   b) TOOL CALL: create_table (if needed table doesn't exist) with schema:
       Always include: {name: "id", type: "STRING", nullable: false}
       Add fields for each piece of data to store
       Add timestamp: {name: "created_at", type: "TIMESTAMP"} (NEVER set nullable:false on TIMESTAMP!)
   c) TOOL CALL: check_table_schema  get field names, types, nullable flags
   d)  MANDATORY: query_database(table_name, null, 3)  see sample records:
       LIST every field that appears in sample records
       Your save payload MUST include ALL these fields
       Note TIMESTAMP format - include with new Date().toISOString()
       Note ID format - match the pattern exactly
       THIS IS YOUR GROUND TRUTH - match the structure!
   
    DO NOT respond with text like "I'll create a table..." - CALL THE TOOL!
    DO NOT skip query_database - you NEED sample data to build correct payloads!
    After these tools, continue to step 3!

3 FINAL REQUIRED STEP - TOOL CALL: generate_html with COMPLETE HTML including:
   - Full <!DOCTYPE html> structure
   - All inline <style> tags for styling
   - All inline <script> tags with complete functionality
   - Database integration (if user requested persistence):
      REQUIRED: Copy-paste the window.API_CONFIG and window.saveToProjectTable... boilerplate from the system prompt
      Wire save to actions: submitBtn.onclick = () => window.saveToProjectTable({...});
      Wire load to DOMContentLoaded: document.addEventListener('DOMContentLoaded', () => window.queryProjectTable(...));
   
    SCHEMA-VALIDATED CRUD IN GENERATED HTML (CRITICAL):
      Form inputs MUST match schema types:
       - STRING  <input type="text"> or <textarea>
       - INT64  <input type="number" step="1">
       - FLOAT64  <input type="number" step="0.01">
       - BOOL  <input type="checkbox">
       - DATE  <input type="date">
      Required fields (nullable: false) MUST have:
       - 'required' attribute on input
       - Visual indicator (asterisk or label)
       - Client-side validation before save
      Save payloads MUST match sample data structure EXACTLY:
       - Include ALL fields that appear in query_database sample records
       - DO NOT assume which fields are needed - match the samples!
       - TIMESTAMP fields: include with new Date().toISOString() (check samples!)
       - ID format: match the pattern from sample data
       - Field names: copy exactly (case-sensitive) from samples
      Display/rendering MUST format by type:
       - TIMESTAMP  new Date(value).toLocaleString()
       - BOOL  conditional display or checkbox
     
      VALIDATION BEFORE SAVE: Compare your payload field-by-field against sample data:
       Sample has: {field1, field2, field3, timestamp, ...}
       Your payload MUST have: {field1, field2, field3, timestamp: new Date().toISOString(), ...}
       Missing fields = ERRORS!

 MANDATORY CHECKLIST - ALL STEPS REQUIRED FOR FIRST PROJECT:
IF persistence needed:
   Step 1: TOOL CALL get_project_context
   Step 2: TOOL CALL create_table (if table doesn't exist)
   Step 3: TOOL CALL check_table_schema to verify columns
   Step 4: TOOL CALL generate_html with database integration AND boilerplate

IF NO persistence needed:
   Step 1: TOOL CALL generate_html directly with app functionality

 THE WORKFLOW ALWAYS ENDS WITH generate_html TOOL CALL - THIS IS NON-NEGOTIABLE!

 NEVER stop after just get_project_context or create_table
 NEVER just respond with text describing what you'll do
 ALWAYS finish by calling generate_html to create the actual app
 ALWAYS include the full API boilerplate in the generated HTML script tag

Common persistence patterns (ALWAYS query sample data first!):

 WORKFLOW FOR EVERY TABLE:
1. check_table_schema('table_name')  get field types
2. query_database('table_name', null, 3)  SEE ACTUAL RECORDS
3. Your payload MUST match sample record structure EXACTLY

 Game Moves (example with TIMESTAMP that MUST be included):
  check_table_schema('moves')  schema info
  query_database('moves', null, 3)  sample: {move_id, game_id, move_number, player, from_row, from_col, to_row, to_col, was_capture, became_king, timestamp: "2025-11-14T02:47:04.424Z"}
  YOUR PAYLOAD MUST INCLUDE ALL 11 FIELDS:
  saveToProjectTable('moves', {
    move_id: \`\${gameId}_move_\${moveNum}\`,
    game_id: gameId,
    move_number: moveNum,
    player: currentPlayer,
    from_row: from.row,
    from_col: from.col,
    to_row: to.row,
    to_col: to.col,
    was_capture: isCapture,
    became_king: becameKing,
    timestamp: new Date().toISOString()  //  INCLUDE IT! Sample shows timestamp has values!
  })

 Todo/Task app:
  query_database('tasks', null, 3)  sample: {id, text, completed, created_at: "2025-..."}
  If sample shows created_at has values  INCLUDE IT:
  saveToProjectTable('tasks', {id: crypto.randomUUID(), text, completed, created_at: new Date().toISOString()})
  
 Forms:
  query_database('submissions', null, 3)  sample: {id, name, email, message, submitted_at: "2025-..."}
  If sample shows submitted_at has values  INCLUDE IT:
  saveToProjectTable('submissions', {id: crypto.randomUUID(), name, email, message, submitted_at: new Date().toISOString()})

 KEY RULE: If sample data shows a TIMESTAMP field with values, you MUST include it!
   Only omit TIMESTAMP if sample records show null values for that field.

 DO NOT: Call get_current_html, find_code_locations, or update_html - there's nothing to update yet!
 DO NOT: Stop after database setup tools - you haven't created the app yet!

 DO: Follow complete workflow  ALWAYS end with generate_html tool call
 DO: If persistence: get_project_context  create_table  check_table_schema  generate_html
 DO: If no persistence: generate_html directly

 REMEMBER: This is a FIRST PROJECT CREATION. No HTML exists. You MUST call generate_html before finishing!
The task is NOT complete until you've called generate_html and created the actual application!`;
        }
      }
      
      // ONLY inject ERROR logs to the AI (no regular logs, no user messages)
      const consoleLogs = getConsoleLogs(false, 100); // Get last 100 logs, don't clear
      
      // ONLY capture ERROR logs - ignore everything else
      const errorLogs = consoleLogs.filter(l => l.level === 'error');

      // LINTING: Check for common syntax errors in the generated HTML
      let lintErrors = [];
      if (generatedHTML && generatedHTML.trim() !== '') {
        try {
          // Simple static analysis using regex/parsing
          // 1. Check for unclosed script tags
          const scriptTags = (generatedHTML.match(/<script/g) || []).length;
          const closeScriptTags = (generatedHTML.match(/<\/script>/g) || []).length;
          if (scriptTags !== closeScriptTags) {
            lintErrors.push('Mismatch in <script> tags: ' + scriptTags + ' opened vs ' + closeScriptTags + ' closed');
          }
          
          // 2. Check for unclosed style tags
          const styleTags = (generatedHTML.match(/<style/g) || []).length;
          const closeStyleTags = (generatedHTML.match(/<\/style>/g) || []).length;
          if (styleTags !== closeStyleTags) {
             lintErrors.push('Mismatch in <style> tags: ' + styleTags + ' opened vs ' + closeStyleTags + ' closed');
          }

          // 3. Check for basic JS syntax errors using a Function constructor (safe-ish eval)
          const scripts = generatedHTML.match(/<script>([\s\S]*?)<\/script>/g);
          if (scripts) {
            scripts.forEach((scriptBlock, idx) => {
              const code = scriptBlock.replace(/<\/?script>/g, '');
              try {
                // Just parse, don't execute
                new Function(code);
              } catch (e) {
                 lintErrors.push(`Syntax error in script block ${idx + 1}: ${e.message}`);
              }
            });
          }
        } catch (e) {
          console.warn('Linting check failed:', e);
        }
      }
      
      // Only send console section if there are actual ERRORS
      if (errorLogs.length > 0 || lintErrors.length > 0) {
        let errorFormatted = '';
        
        if (errorLogs.length > 0) {
           errorFormatted += '--- RUNTIME ERRORS ---\n' + errorLogs.map((log, index) => {
            const time = new Date(log.timestamp).toLocaleTimeString();
            return `${index + 1}. [${time}]  ${log.message}`;
          }).join('\n') + '\n';
        }

        if (lintErrors.length > 0) {
          errorFormatted += '\n--- LINTING/SYNTAX ERRORS ---\n' + lintErrors.map((err, index) => {
             return `${index + 1}.  ${err}`;
          }).join('\n') + '\n';
        }
        
        const consoleSection = `

---CONSOLE ERRORS & LINTING FROM PREVIEW---
 ${errorLogs.length + lintErrors.length} ISSUE(S) DETECTED - FIX THESE!

${errorFormatted}
---END ERRORS---

CRITICAL: The issues above indicate broken functionality or syntax errors. Fix these errors before proceeding.
`;
        
        textContent += consoleSection;
      }
      
      // Check for images from multi-image system
      const hasImages = referenceImages.length > 0;
      
      if (hasImages) {
        // Filter out SVG text files - only send actual images to vision API
        const imageFiles = referenceImages.filter(img => !img.isSVGText);
        
        if (imageFiles.length > 0) {
          // Detect user's intent with the image(s)
          const imageIntent = detectImageIntent(userMessage, true);
          
          // Log the detected intent for debugging
          console.log(` Image Intent Detected: ${imageIntent}`);
          console.log(`   Message: "${userMessage.substring(0, 100)}${userMessage.length > 100 ? '...' : ''}"`);
          console.log(`   Images to send: ${imageFiles.length}`);
          
          // Get appropriate prompt based on intent
          let imagePrompt = IMAGE_PROMPTS[imageIntent];
          if (imageIntent === 'ANALYZE_IMAGE') {
            // Replace placeholder with actual user message
            imagePrompt = imagePrompt.replace('{userMessage}', userMessage);
          }
          
          // Build content array with ALL images
          userContent = [];
          
          // Add all images first
          imageFiles.forEach((img, index) => {
            const imageData = img.data;
            
            // Extract media type from data URL (e.g., "data:image/png;base64,...")
            const mediaTypeMatch = imageData.match(/data:([^;]+);base64,/);
            let mediaType = mediaTypeMatch ? mediaTypeMatch[1] : 'image/png';
            
            // Ensure it's one of the accepted types
            const acceptedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
            if (!acceptedTypes.includes(mediaType)) {
              // Default to png if type is not accepted
              mediaType = 'image/png';
            }
            
            const base64Data = imageData.split(',')[1];
            
            userContent.push({
              type: 'image',
              source: {
                type: 'base64',
                media_type: mediaType,
                data: base64Data
              }
            });
            
            console.log(`    Added image ${index + 1}/${imageFiles.length}: ${img.name} (${mediaType})`);
          });
          
          // Add text prompt after all images
          const imageCountNote = imageFiles.length > 1 
            ? `\n\n Note: ${imageFiles.length} images have been provided above. Please analyze all of them.\n` 
            : '';
          
          userContent.push({
            type: 'text',
            text: textContent + imageCountNote + imagePrompt
          });
        } else {
          // Only SVG text files, no images for vision
          userContent = textContent;
        }
      } else {
        userContent = textContent;
      }
      
      // Detect and encode SVG tags in the user content to prevent parsing issues
      let finalUserContent = userContent;
      
      // Handle both string content and array content (with images)
      const textToCheck = Array.isArray(userContent) 
        ? userContent.find(block => block.type === 'text')?.text 
        : userContent;
      
      if (textToCheck && typeof textToCheck === 'string') {
        const svgRegex = /<svg[\s\S]*?<\/svg>/gi;
        const svgMatches = textToCheck.match(svgRegex);
        
        if (svgMatches && svgMatches.length > 0) {
          let modifiedText = textToCheck;
          
          // Replace each SVG with an encoded version
          svgMatches.forEach((svgCode, index) => {
            const encodedSVG = btoa(unescape(encodeURIComponent(svgCode)));
            const placeholder = `\n---SVG_${index}_ENCODED---\n${encodedSVG}\n---END_SVG_${index}---\n`;
            
            // Replace the SVG with the encoded placeholder
            modifiedText = modifiedText.replace(svgCode, placeholder);
          });
          
          // Add instructions for Claude about the encoded SVGs
          modifiedText += `\n\n IMPORTANT: ${svgMatches.length} SVG code block(s) in your message have been BASE64 ENCODED (marked as ---SVG_N_ENCODED---) to prevent parsing issues. When you need to use an SVG, decode it from base64 first, then incorporate it into the HTML.`;
          
          // Update the user content with the modified text
          if (Array.isArray(userContent)) {
            // If it's an array (with image), update the text block
            finalUserContent = userContent.map(block => 
              block.type === 'text' ? { ...block, text: modifiedText } : block
            );
          } else {
            // If it's a string, replace directly
            finalUserContent = modifiedText;
          }
        }
      }
      
      conversationHistory.push({ role: 'user', content: finalUserContent });
      
      // Keep conversation history limited to prevent hitting API token limits
      // 10 PAIRS = 20 individual messages (assistant + user = 1 pair)
      const MAX_HISTORY_PAIRS = 10;
      const MAX_HISTORY_MESSAGES = MAX_HISTORY_PAIRS * 2; // 20 messages = 10 pairs
      
      // STEP 1: Track if we have a full HTML copy - find the LAST occurrence
      // We want to keep the most recent full copy and remove older duplicates
      // Use global flag conversationHasFullHTML but verify it's accurate
      let fullHTMLCopyIndex = -1;
      
      // Scan to find the LAST message containing full HTML (most recent copy)
      for (let i = conversationHistory.length - 1; i >= 0; i--) {
        const msg = conversationHistory[i];
        if (msg.role === 'user') {
          let content = msg.content;
          
          // Check both string and array content
          const textContent = typeof content === 'string' 
            ? content 
            : (Array.isArray(content) ? content.find(block => block.type === 'text')?.text : '');
          
          if (textContent && textContent.includes('---CURRENT HTML---')) {
            fullHTMLCopyIndex = i;
            conversationHasFullHTML = true; // Update flag to match reality
            break; // Found the most recent one, stop looking
          }
        }
      }
      
      // If no HTML found in scan, update flag accordingly
      if (fullHTMLCopyIndex === -1) {
        conversationHasFullHTML = false;
      }
      
      // IMPORTANT: Do NOT strip HTML from messages - AI needs full context to generate correct code
      // Previous stripping was causing syntax errors because AI couldn't see complete code structure
      // The MAX_HISTORY_MESSAGES limit (10 pairs) plus runtime trimming will naturally age out old messages
      
      // STEP 3: Trim old messages if we exceed the limit
      if (conversationHistory.length > MAX_HISTORY_MESSAGES) {
        // Calculate how many to remove from the start
        const toRemove = conversationHistory.length - MAX_HISTORY_MESSAGES;
        
        // Track if we're removing the message with HTML (was at fullHTMLCopyIndex)
        let removedHTMLMessage = false;
        
        // Remove from the beginning, but respect tool_use/tool_result pairs
        let removed = 0;
        let index = 0;
        
        while (removed < toRemove && index < conversationHistory.length - MAX_HISTORY_MESSAGES) {
          const msg = conversationHistory[index];
          
          // Check if this message contains the HTML copy
          if (index === fullHTMLCopyIndex) {
            removedHTMLMessage = true;
          }
          
          // If this is an assistant message with tool_use, remove it AND the following tool_result together
          if (msg.role === 'assistant' && Array.isArray(msg.content)) {
            const hasToolUse = msg.content.some(block => block.type === 'tool_use');
            if (hasToolUse && index + 1 < conversationHistory.length) {
              const nextMsg = conversationHistory[index + 1];
              if (nextMsg.role === 'user' && Array.isArray(nextMsg.content) && 
                  nextMsg.content.some(block => block.type === 'tool_result')) {
                // Check if next message has HTML too
                if (index + 1 === fullHTMLCopyIndex) {
                  removedHTMLMessage = true;
                }
                // Remove both as a pair
                conversationHistory.splice(index, 2);
                removed += 2;
                continue; // Don't increment index since we removed items
              }
            }
          }
          
          // Remove single message
          conversationHistory.splice(index, 1);
          removed++;
        }
        
        // If we removed the HTML message, flag needs to be reset
        if (removedHTMLMessage) {
          conversationHasFullHTML = false;
          console.log(' Removed message containing full HTML due to history trimming. Flag reset to false.');
        }
      }
      
      let continueLoop = true;
      let finalResponse = '';
      let iterationCount = 0;
      // Allow enough iterations for complex workflows (database creation requires 3-5 tool calls)
      // Increased to 12 to allow room for enforcement prompts AND error fixing loops
      const MAX_ITERATIONS = 12;
      
      //  PROACTIVE DUPLICATE INTENT DETECTION: Check if user is asking for chat history storage
      // This prevents infinite loops when user asks to "store conversation" (which already exists)
      const userMessageLower = userMessage.toLowerCase();
      const isChatHistoryRequest = (
        (userMessageLower.includes('store') || userMessageLower.includes('save')) &&
        (userMessageLower.includes('chat') || userMessageLower.includes('conversation') || 
         userMessageLower.includes('history') || userMessageLower.includes('messages')) &&
        (userMessageLower.includes('this') || userMessageLower.includes('our') || userMessageLower.includes('current'))
      );
      
      if (isChatHistoryRequest && currentMode === 'agent') {
        console.log(' DETECTED: User asking to store chat/conversation history');
        
        const clarificationPrompt = ` **I noticed you're asking me to store the conversation history.**

Good news! This project **already has a built-in chat history system** that automatically saves all our conversations. Every message we exchange is already being stored and will be available when you return to this project.

**However, I can help you with:**

1. **Create a custom database table** for storing specific conversation data (not the full chat history, but something specific like user feedback, important notes, etc.)
   - Example: Store only user questions and AI answers in a searchable format
   - Example: Store conversation summaries or key decisions

2. **Export current chat history** to view or download

3. **Build a UI** to display chat history in your app

**Please clarify what you'd like:**
- Do you want a **custom table** for a specific purpose? (If so, what data should it store?)
- Do you want to **see/display** the existing chat history?
- Something else?

Let me know and I'll implement it properly!`;
        
        addMessageToChat('system', clarificationPrompt);
        return clarificationPrompt;
      }
      
      // COMPLETION TRACKING: Track which types of tools were called to detect incomplete work
      // This helps detect when AI gathers context but fails to apply changes
      const toolsCalledInSession = {
        // Information gathering tools - these indicate AI is preparing to make changes
        contextGathering: [], // find_code_locations, get_code_context, get_html_section, get_project_context, check_table_schema
        // Action tools - these actually make changes
        actionTools: [], // update_html, generate_html, create_table, modify_table_schema, execute_javascript
        // All tools called (for debugging)
        all: [],
        // Track sequential duplicates for infinite loop detection
        lastToolSequence: [],
        duplicateSequenceCount: 0
      };
      
      // Only inject design framework instructions if:
      // 1. Framework is not "none"
      // 2. Creating a new page (no existing HTML) OR user explicitly mentions design/framework/style changes
      const shouldInjectFramework = 
        currentDesignFramework !== 'none' && (
          !generatedHTML || 
          generatedHTML.trim() === '' ||
          isWelcomeScreen ||
          /\b(design|framework|style|theme|rebrand|redesign|living design|material design|bootstrap|apply)\b/i.test(userMessage)
        );
      
      // Start from base system prompt (plus design framework if active)
      let enhancedSystemPrompt = systemPrompt;

      // IMPORTANT: Ensure the REQUIRED boilerplates are absolutely enforced
      // by appending a final reminder to the prompt
      enhancedSystemPrompt += `

REMINDER: YOU MUST INCLUDE THE DATABASE API WRAPPER CODE AT THE TOP OF YOUR <script> TAG.
DO NOT SKIP THIS. THE APP WILL NOT WORK WITHOUT IT.
window.API_CONFIG = { ... };
window.saveToProjectTable = ...;
window.queryProjectTable = ...;
window.updateProjectTable = ...;
window.deleteFromProjectTable = ...;

REMINDER: CODE QUALITY & LINTING
You are an expert developer who writes clean, error-free code. 
Before outputting your code, internally review it for:
1. Syntax errors (unclosed brackets, missing semicolons)
2. Logical errors (undefined variables, null checks)
3. Best practices (use const/let, proper indentation)
4. Security (sanitize inputs, avoid eval)
`;

      if (shouldInjectFramework) {
        enhancedSystemPrompt += getDesignFrameworkInstructions();
      }

      while (continueLoop && iterationCount < MAX_ITERATIONS) {
        iterationCount++;
          // ===== ENHANCEMENTS: Loop Safety Checks =====
          if (window.appBuilderEnhancements) {
            const enh = window.appBuilderEnhancements;
            enh.loopMetrics.totalIterations++;
            if (enh.stopRequested) {
              console.log(' Stop requested - breaking loop');
              continueLoop = false;
              break;
            }
            if (!trackProgress(generatedHTML)) {
              continueLoop = false;
              break;
            }
          }
          // ===== END ENHANCEMENTS =====

        try {
          // Determine which tools to make available based on the system prompt mode
          // Image analysis mode: NO HTML generation tools (only text responses)
          // HTML generator mode: Full tool access
          let availableTools = TOOLS;
          const isImageAnalysisMode = systemPrompt.includes('IMAGE ANALYSIS ASSISTANT');
          
          if (isImageAnalysisMode) {
            // Remove all HTML generation and modification tools for image analysis
            // User just wants to explain/analyze an image, not build apps
            availableTools = [];
            console.log(' IMAGE ANALYSIS MODE ACTIVE ');
            console.log(' NO TOOLS PROVIDED - TEXT-ONLY RESPONSES');
            console.log(' HTML generation disabled for this request');
          } else {
            console.log(' HTML Generator Mode - Full tools available');
          }
          
          // Check payload size - allow larger payloads to preserve full context
          const payloadSize = JSON.stringify(conversationHistory).length;
          const MAX_PAYLOAD_SIZE = 500000; // 500KB limit - increased to preserve context
          
          let finalConversationHistory = conversationHistory;
          if (payloadSize > MAX_PAYLOAD_SIZE) {
            console.warn(` Conversation history very large (${(payloadSize/1024).toFixed(1)}KB), keeping last 8 messages...`);
            
            // Keep more messages to preserve context - AI needs full history for accurate code generation
            const keepCount = Math.min(8, conversationHistory.length);
            finalConversationHistory = conversationHistory.slice(-keepCount);
            
            // Log what we're sending
            const newSize = JSON.stringify(finalConversationHistory).length;
            console.log(` Reduced payload: ${(payloadSize/1024).toFixed(1)}KB -> ${(newSize/1024).toFixed(1)}KB`);
          } else {
            console.log(` Payload size: ${(payloadSize/1024).toFixed(1)}KB (within limits)`);
          }
          
          // CRITICAL: Validate and repair conversation history before sending
          // This prevents API errors from malformed messages (orphaned tool_results, mismatched IDs, etc.)
          // NOTE: We try to repair, but if validation fails, we keep original history to preserve context
          const validatedHistory = validateAndRepairConversationHistory(finalConversationHistory);
          
          // Only use validated history if it has content - otherwise keep original to preserve context
          if (validatedHistory.length > 0) {
            finalConversationHistory = validatedHistory;
          } else {
            console.warn(' Validation returned empty - keeping original history to preserve context');
            // If original history is also empty, create a fresh user message
            if (finalConversationHistory.length === 0) {
              finalConversationHistory = [{
                role: 'user',
                content: enhancedMessage
              }];
            }
          }
          
          // SANITY CHECK: Ensure first message doesn't contain tool_results
          // If it does, extract text content or replace with current message
          if (finalConversationHistory.length > 0) {
            const firstMsg = finalConversationHistory[0];
            if (firstMsg.role === 'user' && Array.isArray(firstMsg.content)) {
              const hasToolResult = firstMsg.content.some(block => block.type === 'tool_result');
              if (hasToolResult) {
                console.warn(' First message contains tool_result - extracting text content');
                
                // Extract any text content from the first message
                const textContent = firstMsg.content
                  .filter(block => block.type === 'text')
                  .map(block => block.text)
                  .join('\n');
                
                if (textContent.trim()) {
                  // Replace with text-only version
                  finalConversationHistory[0] = {
                    role: 'user',
                    content: textContent
                  };
                  console.log(' Converted first message to text-only');
                } else {
                  // No text - remove the problematic message and keep rest of history
                  finalConversationHistory.shift();
                  console.log(' Removed first message with only tool_results');
                }
              }
            }
          }
          
          // RUNTIME TOKEN ESTIMATION AND AGGRESSIVE TRIMMING
          // Estimate tokens and trim more aggressively to ensure complete responses
          // Rough estimate: ~4 characters per token, max ~100K input tokens for safety
          const MAX_INPUT_CHARS = 300000; // ~75K tokens (leaving headroom for response + system prompt)
          
          function estimateMessageSize(msg) {
            if (typeof msg.content === 'string') {
              return msg.content.length;
            }
            if (Array.isArray(msg.content)) {
              return msg.content.reduce((sum, block) => {
                if (block.type === 'text') return sum + (block.text?.length || 0);
                if (block.type === 'tool_use') return sum + JSON.stringify(block.input || {}).length + 200;
                if (block.type === 'tool_result') return sum + (block.content?.length || 0);
                return sum + 100; // Default estimate for other block types
              }, 0);
            }
            return 100; // Fallback
          }
          
          function getTotalSize(messages) {
            return messages.reduce((sum, msg) => sum + estimateMessageSize(msg), 0);
          }
          
          // Check if we need to trim more aggressively
          let totalChars = getTotalSize(finalConversationHistory);
          if (totalChars > MAX_INPUT_CHARS) {
            console.log(` Conversation too large (${(totalChars/1000).toFixed(1)}KB), trimming aggressively...`);
            
            // Remove messages from the front until we're under the limit
            // Respect tool_use/tool_result pairs
            while (finalConversationHistory.length > 2 && getTotalSize(finalConversationHistory) > MAX_INPUT_CHARS) {
              const firstMsg = finalConversationHistory[0];
              
              // If assistant with tool_use, remove with its tool_result pair
              if (firstMsg.role === 'assistant' && Array.isArray(firstMsg.content)) {
                const hasToolUse = firstMsg.content.some(block => block.type === 'tool_use');
                if (hasToolUse && finalConversationHistory.length > 2) {
                  const secondMsg = finalConversationHistory[1];
                  if (secondMsg.role === 'user' && Array.isArray(secondMsg.content) &&
                      secondMsg.content.some(block => block.type === 'tool_result')) {
                    finalConversationHistory.splice(0, 2);
                    continue;
                  }
                }
              }
              
              // Remove single message
              finalConversationHistory.shift();
            }
            
            const newSize = getTotalSize(finalConversationHistory);
            console.log(`   Trimmed to ${(newSize/1000).toFixed(1)}KB (${finalConversationHistory.length} messages)`);
          }
          
          // Log what we're actually sending for debugging
          console.log(' Sending messages:', finalConversationHistory.map((m, i) => ({
            index: i,
            role: m.role,
            contentType: Array.isArray(m.content) ? m.content.map(b => b.type).join(',') : 'string',
            preview: typeof m.content === 'string' ? m.content.substring(0, 50) : '(array)'
          })));
          
          const requestBody = {
            model: 'claude-sonnet-4-5',
            max_tokens: 16384,  // Increased from 8192 to allow larger HTML generation
            system: enhancedSystemPrompt,
            messages: finalConversationHistory,
            tools: availableTools
          };
          
          // Force tool usage when generating new apps (no existing HTML or just welcome screen)
          // This prevents the AI from just responding with text instead of calling tools
          // BUT: Don't force tools in image analysis mode - we want text responses there
          if (!isImageAnalysisMode && (isWelcomeScreen || !generatedHTML || generatedHTML.trim() === '')) {
            requestBody.tool_choice = { type: "any" };
          }
          
          // Add timeout to Claude API call (180 seconds)
          const API_TIMEOUT = 180000; // 3 minutes
          const apiCallStart = Date.now();
          
          // Create abort controller for this request
          currentAbortController = new AbortController();
          if (window.appBuilderEnhancements) window.appBuilderEnhancements.streamAbortController = currentAbortController;
          
          // Enable stop button now that streaming is starting
          const stopBtn = document.getElementById('btnStop');
          if (stopBtn) stopBtn.disabled = false;
          
          // Streaming disabled - using regular request for reliable tool calling
          const fetchPromise = fetch('url here', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'anthropic-version': '2023-06-01',
              'X-Api-Key': CODE_PUPPY_API_KEY
            },
            body: JSON.stringify(requestBody),
            signal: currentAbortController.signal
          });
          
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => {
              reject(new Error(`Claude API call timed out after ${API_TIMEOUT / 1000} seconds. This usually means the request is too large or complex.`));
            }, API_TIMEOUT);
          });
          
          console.log(' API Request sent, waiting for response...');
          const response = await Promise.race([fetchPromise, timeoutPromise]);
          const apiDuration = Date.now() - apiCallStart;
          console.log(` API Response received in ${apiDuration}ms - Status: ${response.status} ${response.statusText}`);
          
          // Check for API errors - preserve conversation history for context
          if (!response.ok) {
            const errorText = await response.text();
            const errorStatus = response.status;
            
            // Log error details for debugging
            console.error(` API returned ${errorStatus} error:`, errorText.substring(0, 500));
            
            // Show error notification
            if (isMinimalMode) {
              showMinimalUpdateNudge([
                `API Error (${errorStatus}) detected`,
                'Please try again or refresh if issue persists'
              ]);
            }
            
            // Remove the last user message to allow retry
            conversationHistory.pop();
            
            // Throw error with helpful message - DO NOT clear history to preserve context
            throw new Error(`API request failed (${errorStatus}): ${errorText.substring(0, 200)}`);
          }
          
          // Process regular JSON response (streaming disabled)
          console.log(' Processing JSON response...');
          const data = await response.json();
          console.log(' Response received. Data:', {
            id: data.id,
            stop_reason: data.stop_reason,
            content_blocks: data.content?.length || 0,
            content_types: data.content?.map(b => b.type) || []
          });
          
          const toolUseBlocks = data.content.filter(block => block.type === 'tool_use');
          const textBlock = data.content.find(block => block.type === 'text');
          console.log(` Found ${toolUseBlocks.length} tool calls, text block: ${textBlock ? 'yes' : 'no'}`);
          
          // Check if this response was cut off AND has incomplete tool calls
          // If cut off with no tool calls, we need to handle it specially
          const wasCutOff = data.stop_reason === 'max_tokens';
          const hasToolCalls = toolUseBlocks.length > 0;
          
          if (hasToolCalls) {
            // Normal path: AI made tool calls, add to history and execute them
            conversationHistory.push({
              role: 'assistant',
              content: data.content
            });
            
            // Enforce message limit to prevent hitting API limits
            enforceMessageLimit(conversationHistory);
            
            // Hide AI's thinking during build process - show only in progress indicator
            // Show thinking for any explanation >20 chars (allows for meaningful context)
            // if (textBlock && textBlock.text && textBlock.text.trim() && textBlock.text.trim().length > 20) {
            //   addThinkingMessage(textBlock.text, toolUseBlocks.length);
            // }
            
            await executeToolActions(toolUseBlocks, conversationHistory);
            
            // COMPLETION TRACKING: Record which tools were called for validation
            const CONTEXT_GATHERING_TOOLS = ['find_code_locations', 'get_code_context', 'get_html_section', 'get_project_context', 'check_table_schema', 'get_current_html', 'get_console_logs'];
            const ACTION_TOOLS = ['update_html', 'generate_html', 'create_table', 'modify_table_schema'];
            
            for (const toolUse of toolUseBlocks) {
              toolsCalledInSession.all.push(toolUse.name);
              if (CONTEXT_GATHERING_TOOLS.includes(toolUse.name)) {
                toolsCalledInSession.contextGathering.push(toolUse.name);
              }
              if (ACTION_TOOLS.includes(toolUse.name)) {
                toolsCalledInSession.actionTools.push(toolUse.name);
              }
            }
            console.log(' Tools called so far:', toolsCalledInSession);
            
            //  INFINITE LOOP DETECTION: Check if AI is repeating the same tool sequence
            const currentToolSequence = toolUseBlocks.map(t => `${t.name}:${JSON.stringify(t.input).substring(0, 100)}`).join('|');
            
            if (toolsCalledInSession.lastToolSequence.length > 0) {
              const lastSequence = toolsCalledInSession.lastToolSequence[toolsCalledInSession.lastToolSequence.length - 1];
              
              if (currentToolSequence === lastSequence) {
                toolsCalledInSession.duplicateSequenceCount++;
                console.warn(` DUPLICATE TOOL SEQUENCE DETECTED! Count: ${toolsCalledInSession.duplicateSequenceCount}`);
                console.warn(`   Repeated sequence: ${currentToolSequence.substring(0, 150)}...`);
                
                // If same sequence repeated 2+ times, stop and ask for clarification
                if (toolsCalledInSession.duplicateSequenceCount >= 2) {
                  console.error(` INFINITE LOOP DETECTED: AI repeated same tools ${toolsCalledInSession.duplicateSequenceCount + 1} times`);
                  
                  // Check if this is a "store chat history" duplicate request
                  const isCreatingChatHistoryTable = toolUseBlocks.some(t => 
                    t.name === 'create_table' && 
                    (t.input.table_name?.toLowerCase().includes('chat') || 
                     t.input.table_name?.toLowerCase().includes('conversation') ||
                     t.input.table_name?.toLowerCase().includes('history'))
                  );
                  
                  let clarificationMessage = '';
                  if (isCreatingChatHistoryTable) {
                    clarificationMessage = ` **Clarification Needed**

I notice you're asking me to store the conversation/chat history. However, this project **already has a built-in chat history system** that automatically saves all our conversations.

**What I can do:**

1. **Use the existing chat history** (already working - no action needed)
2. **Create a CUSTOM table** for storing specific conversation data (e.g., user feedback, specific messages, etc.) with a different purpose
3. **Export the current chat** to a specific format you need

**Please clarify:**
- Do you want a **custom table** for a specific purpose? If so, what should it store?
- Do you want to **export/view** the existing chat history?
- Something else?

Let me know and I'll implement exactly what you need!`;
                  } else {
                    clarificationMessage = ` **I seem to be stuck in a loop**

I've attempted the same operation ${toolsCalledInSession.duplicateSequenceCount + 1} times without making progress.

**What I was trying to do:**
${toolUseBlocks.map(t => `- ${t.name}`).join('\n')}

**To help me move forward, could you:**
1. Clarify what you'd like me to do differently?
2. Provide more specific requirements?
3. Let me know if I should try a different approach?

I want to make sure I implement exactly what you need!`;
                  }
                  
                  removeProgressIndicator();
                  addMessageToChat('system', clarificationMessage);
                  
                  // Break out of loop
                  continueLoop = false;
                  break;
                }
              } else {
                // Different sequence - reset counter
                toolsCalledInSession.duplicateSequenceCount = 0;
              }
            }
            
            // Track this sequence
            toolsCalledInSession.lastToolSequence.push(currentToolSequence);
            // Keep only last 3 sequences to save memory
            if (toolsCalledInSession.lastToolSequence.length > 3) {
              toolsCalledInSession.lastToolSequence.shift();
            }
            
            //  AUTO-FIX: Check if update_html or generate_html introduced console errors
            // If errors found, we'll let the FINAL ERROR CHECK handle it with a truly fresh sendMessage
            // This section just logs and tracks - no complex retry logic here
            const htmlModifyingTools = toolUseBlocks.filter(t => t.name === 'update_html' || t.name === 'generate_html');
            if (htmlModifyingTools.length > 0) {
              // Check the tool results for console errors
              const lastToolResultMsg = conversationHistory[conversationHistory.length - 1];
              if (lastToolResultMsg && lastToolResultMsg.role === 'user' && Array.isArray(lastToolResultMsg.content)) {
                for (const block of lastToolResultMsg.content) {
                  if (block.type === 'tool_result' && block.content) {
                    try {
                      const result = JSON.parse(block.content);
                      // Check if this result has console errors
                      if (result.console_check && result.console_check.has_errors) {
                        const errorCount = result.console_check.error_count || 0;
                        console.warn(` AUTO-FIX: Detected ${errorCount} console error(s) after ${htmlModifyingTools[0].name}. Will fix after task completes.`);
                        // Don't interrupt - let the task complete and FINAL ERROR CHECK will handle it
                        // This prevents the "stuck in retry loop" problem
                      }
                    } catch (e) { /* ignore parse errors */ }
                  }
                }
              }
            }
            
            // ENFORCEMENT: Detect if AI is stuck in context-gathering loop
            // If AI has called 3+ context tools without any action tools, FORCE it to apply changes
            const contextCallCount = toolsCalledInSession.contextGathering.length;
            const actionCallCount = toolsCalledInSession.actionTools.length;
            const isStuckInContextLoop = contextCallCount >= 3 && actionCallCount === 0;
            
            if (isStuckInContextLoop && iterationCount < MAX_ITERATIONS) {
              console.warn(` ENFORCEMENT: AI stuck in context loop (${contextCallCount} context tools, 0 action tools). Forcing update_html call.`);
              addMessageToChat('system', ` AI has gathered enough context. Forcing code generation and update...`);
              
              // Get the most recent tool result to extract line numbers
              const lastToolResult = conversationHistory[conversationHistory.length - 1];
              let lineNumberHint = '';
              
              if (lastToolResult && lastToolResult.role === 'user' && Array.isArray(lastToolResult.content)) {
                for (const block of lastToolResult.content) {
                  if (block.type === 'tool_result' && block.content) {
                    try {
                      const result = JSON.parse(block.content);
                      if (result.candidates && result.candidates.length > 0) {
                        const firstCandidate = result.candidates[0];
                        lineNumberHint = `Use line numbers from the search results. First candidate is around line ${firstCandidate.line_number}.`;
                      } else if (result.start_line && result.end_line) {
                        lineNumberHint = `Use start_line: ${result.start_line} and end_line: ${result.end_line} from get_html_section.`;
                      }
                    } catch (e) { /* ignore parse errors */ }
                  }
                }
              }
              
              // FORCE the AI to call update_html with a very direct prompt
              conversationHistory.push({
                role: 'user',
                content: [{
                  type: 'text',
                  text: ` STOP SEARCHING. YOU HAVE ENOUGH CONTEXT.

You have called find_code_locations/get_html_section ${contextCallCount} times. You have all the code context you need.

NOW YOU MUST:
1. Take the code you found in your previous searches
2. MODIFY it to implement the user's requested feature
3. Call update_html with your modifications

${lineNumberHint}

REQUIRED ACTION - Call update_html NOW with this structure:
{
  "edits": [{
    "start_line": <line number from your search results>,
    "end_line": <ending line number>,
    "new_string": "<the COMPLETE modified code section with the user's feature added>"
  }]
}

DO NOT call find_code_locations again.
DO NOT call get_html_section again.
DO NOT explain what you found.

GENERATE THE CODE AND CALL update_html NOW.

If you respond with text instead of calling update_html, you are FAILING to complete the user's request.`
                }]
              });
              
              // Continue loop to get the AI's response with update_html
              continueLoop = true;
            }
            // Check if we've hit the iteration limit
            else if (iterationCount >= MAX_ITERATIONS) {
              // Hit the hard limit - force stop
              console.warn(` Hit iteration limit (${iterationCount}/${MAX_ITERATIONS}). Stopping.`);
              continueLoop = false;
            } else {
              // continueLoop stays true - loop will continue normally
              continueLoop = true;
            }
          } else {
            // No tool calls were made
            
            // Check if we hit the token limit OR if there's no tool call (incomplete work)
            if (wasCutOff && iterationCount < MAX_ITERATIONS) {
              // The AI was cut off mid-response before making any tool calls
              // We should NOT add this incomplete assistant message to history
              // because it would create an invalid conversation state
              addMessageToChat('system', ` Response was cut off. Retrying with stronger prompt...`);
              
              // Get the original user message BEFORE removing it from history
              const lastUserMessage = conversationHistory[conversationHistory.length - 1];
              const originalText = lastUserMessage?.content?.[0]?.text || 'Complete the previous task';
              
              // Remove the last user message and re-send with a more direct prompt
              conversationHistory.pop();
              
              // Add a STRONG, DIRECT prompt with the CORRECT original message
              conversationHistory.push({
                role: 'user',
                content: [
                  {
                    type: 'text',
                    text: `${originalText}\n\nIMPORTANT: Think through the solution briefly (what needs to change and how), then IMMEDIATELY call the tool. Keep reasoning under 3 sentences, then execute.`
                  }
                ]
              });
              
              finalResponse = '';
              continueLoop = true;
            } else if (data.stop_reason === 'end_turn' && (!textBlock || !textBlock.text || textBlock.text.trim().length < 10) && iterationCount < MAX_ITERATIONS) {
              // AI stopped without proper response or tool call - this shouldn't happen in agent mode
              // Don't add the empty assistant message to history
              addMessageToChat('system', ` AI stopped without completing work. Prompting to continue...`);
              
              conversationHistory.push({
                role: 'user',
                content: [
                  {
                    type: 'text',
                    text: `You must complete the task. Think: what tool is needed and what changes are required? Then call the necessary tool (update_html, generate_html, etc.) to finish the work. Brief reasoning, then execute.`
                  }
                ]
              });
              
              continueLoop = true;
            } else if (currentMode === 'agent' && data.stop_reason === 'end_turn' && iterationCount === 1 && iterationCount < MAX_ITERATIONS) {
              // In Agent mode on first iteration: AI responded with text but no tool call
              // This often happens when AI explains what it found but doesn't complete the action
              // Add the response to history but prompt to continue with action
              conversationHistory.push({
                role: 'assistant',
                content: data.content
              });
              
              addMessageToChat('system', ` Prompting AI to complete the action...`);
              
              conversationHistory.push({
                role: 'user',
                content: [
                  {
                    type: 'text',
                    text: `Perfect. Now execute your plan. Think: What specific changes are needed? Which tool handles this? Then call the appropriate tool (find_code_locations, update_html, generate_html, etc.) with the right parameters.`
                  }
                ]
              });
              
              continueLoop = true;
            } else {
              // AI responded with text but no tool calls
              // Check if this is incomplete work (context gathered but no action taken)
              const hasGatheredContextThisSession = toolsCalledInSession.contextGathering.length > 0;
              const hasAppliedChangesThisSession = toolsCalledInSession.actionTools.length > 0;
              const existingHTMLToModify = generatedHTML && generatedHTML.trim() !== '' && !isWelcomeScreen;
              
              // INCOMPLETE WORK DETECTION: AI gathered context but stopped without applying changes
              if (currentMode === 'agent' && hasGatheredContextThisSession && !hasAppliedChangesThisSession && existingHTMLToModify && iterationCount < MAX_ITERATIONS) {
                console.warn(` MID-LOOP INCOMPLETE WORK: AI gathered context (${toolsCalledInSession.contextGathering.join(', ')}) but stopped with text response instead of update_html`);
                
                // Don't add the incomplete response to history - prompt to continue
                addMessageToChat('system', ` Code context retrieved. Prompting AI to generate and apply the HTML changes...`);
                
                conversationHistory.push({
                  role: 'user',
                  content: [{
                    type: 'text',
                    text: ` TASK NOT COMPLETE - HTML CHANGES REQUIRED

You successfully retrieved code context using ${toolsCalledInSession.contextGathering.join(', ')}.
Now you MUST complete the task by generating the updated HTML code and applying it.

REQUIRED NEXT STEP:
Call the update_html tool with your code changes. You have the line numbers and code structure from your search.

Example update_html call structure:
{
  "edits": [{
    "start_line": <line number from find_code_locations>,
    "end_line": <ending line number>,
    "new_string": "<your complete modified code including the new functionality>"
  }]
}

Remember:
- Use the line numbers from the find_code_locations/get_html_section results
- Include ALL the code for that section (not just the new parts)
- Add the new functionality the user requested
- The task is only complete when update_html is called and the HTML is modified

Generate the code changes and call update_html now.`
                  }]
                });
                
                continueLoop = true;
              } else {
                // Normal completion with text but no tool calls (this is OK for chat/plan mode)
                // Add the assistant's text response to history
                conversationHistory.push({
                  role: 'assistant',
                  content: data.content
                });
                
                finalResponse = textBlock ? textBlock.text : '';
                continueLoop = false;
                
                // Remove progress indicator when showing text-only response
                removeProgressIndicator();
              }
            }
          }
        } catch (error) {
          // Check if it's an abort (user clicked stop)
          if (error.name === 'AbortError') {
            console.log(' Request aborted by user');
            if (window.appBuilderEnhancements) window.appBuilderEnhancements.stopRequested = false;
            conversationHistory.pop();
            currentAbortController = null;
            return ''; // Return empty response, user already sees "Stopped by user" message
          }
          
          // Check if it's a timeout
          const isTimeout = error.message.includes('timed out');
          
          if (isTimeout) {
            
            // Add helpful error message to chat
            addMessageToChat('system', ` Request timed out. The AI took too long to respond (>2 minutes). 
            
Possible solutions:
 Try using update_html instead of generate_html for faster responses
 Simplify your request
 Start a new conversation (refresh the page)
 Check the browser console for details`);
          }
          
          conversationHistory.pop();
          throw error;
        }
      }
      
      // Check if we exited due to max iterations
      if (iterationCount >= MAX_ITERATIONS && continueLoop) {
        console.warn(` Stopped after ${MAX_ITERATIONS} iterations to prevent infinite loop.`);
        finalResponse = `Task completed after ${MAX_ITERATIONS} iterations. The changes have been applied to your app.`;
      }
      
      // ===== COMPLETION VALIDATION =====
      // Detect incomplete work: AI gathered context but never applied changes
      const gatheredContext = toolsCalledInSession.contextGathering.length > 0;
      const appliedChanges = toolsCalledInSession.actionTools.length > 0;
      const hasExistingHTML = generatedHTML && generatedHTML.trim() !== '' && !isWelcomeScreen;
      
      // Log completion status for debugging
      console.log(' Session complete:', {
        iterations: iterationCount,
        contextGathering: toolsCalledInSession.contextGathering,
        actionTools: toolsCalledInSession.actionTools,
        totalTools: toolsCalledInSession.all.length,
        hasResponse: !!finalResponse,
        gatheredContext,
        appliedChanges,
        hasExistingHTML
      });
      
      // Check for incomplete work pattern in Agent mode
      // This catches cases that slipped through the mid-loop detection
      if (currentMode === 'agent' && gatheredContext && !appliedChanges && hasExistingHTML) {
        console.error(' TASK INCOMPLETE: AI gathered context but did not generate/apply HTML changes!');
        console.error(' Context tools called:', toolsCalledInSession.contextGathering);
        console.error(' Action tools called:', toolsCalledInSession.actionTools);
        
        // Provide clear feedback to user about what happened
        const incompleteMessage = ` **The AI retrieved code but didn't apply changes.**

**What happened:** 
The AI found the relevant code sections using \`${toolsCalledInSession.contextGathering.join(', ')}\`, but did not generate the updated HTML or call \`update_html\` to apply changes.

**The missing step:**
The AI needed to take the code it found, modify it with your requested changes, and call \`update_html\` to apply those modifications. This final step didn't happen.

**What to try:**
1. **Send your request again** - click the send button with the same request
2. **Be specific about what code to change**: Instead of "add a complete feature", try "in the createItemRow function, add a checkbox button that calls markComplete(item.id)"
3. **Mention the function/section name** if you know it from previous responses

**Debug info:** Found code in ${toolsCalledInSession.contextGathering.length} search(es), but 0 HTML updates were applied.`;
        
        // Only override if we don't have a meaningful response
        if (!finalResponse || finalResponse.trim().length < 100) {
          finalResponse = incompleteMessage;
        } else {
          // Append warning to existing response
          finalResponse += '\n\n---\n' + incompleteMessage;
        }
        
        // Also show as system message for visibility
        addMessageToChat('system', ` Code found but HTML not updated. The AI needs to generate and apply the changes. Try sending your request again.`);
      }
      
      // Success case: Log what was accomplished
      if (appliedChanges && toolsCalledInSession.actionTools.length > 0) {
        console.log(' Task completed successfully. HTML changes applied via:', toolsCalledInSession.actionTools);
        // Remove progress indicator - task is complete
        removeProgressIndicator();
      }
      
      //  FINAL ERROR CHECK - Verify no errors remain after AI says it's done
      // If errors found, queue a truly fresh sendMessage to fix them
      if (appliedChanges) {
        // Wait for preview to fully render all JS
        await new Promise(resolve => setTimeout(resolve, 1200));
        
        console.log(` FINAL ERROR CHECK: Verifying no errors remain...`);
        
        // 1. STATIC SYNTAX ANALYSIS - Check for JS syntax errors that console can't capture
        let syntaxErrors = [];
        let brokenScriptSnippets = []; // Store the actual broken code for the AI
        if (generatedHTML && generatedHTML.trim() !== '') {
          try {
            // Extract and validate all script blocks
            const scripts = generatedHTML.match(/<script[^>]*>([\s\S]*?)<\/script>/gi);
            if (scripts) {
              scripts.forEach((scriptBlock, idx) => {
                // Remove script tags to get just the code
                const code = scriptBlock.replace(/<script[^>]*>/gi, '').replace(/<\/script>/gi, '');
                // Skip empty scripts or external src scripts
                if (code.trim() && !scriptBlock.includes('src=')) {
                  try {
                    // Parse the code to check for syntax errors (doesn't execute)
                    new Function(code);
                  } catch (e) {
                    syntaxErrors.push(`Script block ${idx + 1}: ${e.message}`);
                    
                    // Find where this script is in the HTML and extract line numbers
                    const scriptStartIndex = generatedHTML.indexOf(scriptBlock);
                    const linesBeforeScript = generatedHTML.substring(0, scriptStartIndex).split('\n').length;
                    const scriptLines = code.split('\n');
                    
                    // Try to find the approximate line of the error
                    // Most error messages include a line number or we can estimate
                    let errorContext = '';
                    const codeLength = scriptLines.length;
                    
                    if (codeLength <= 50) {
                      // Small script - show all of it
                      errorContext = code;
                    } else {
                      // Larger script - show first 30 and last 20 lines
                      errorContext = scriptLines.slice(0, 30).join('\n') + 
                        '\n... (middle lines omitted) ...\n' + 
                        scriptLines.slice(-20).join('\n');
                    }
                    
                    brokenScriptSnippets.push({
                      blockNum: idx + 1,
                      error: e.message,
                      startLine: linesBeforeScript,
                      code: errorContext
                    });
                  }
                }
              });
            }
            
            // Check for unclosed script/style tags
            const scriptOpens = (generatedHTML.match(/<script/gi) || []).length;
            const scriptCloses = (generatedHTML.match(/<\/script>/gi) || []).length;
            if (scriptOpens !== scriptCloses) {
              syntaxErrors.push(`Mismatched <script> tags: ${scriptOpens} opened vs ${scriptCloses} closed`);
            }
            
            const styleOpens = (generatedHTML.match(/<style/gi) || []).length;
            const styleCloses = (generatedHTML.match(/<\/style>/gi) || []).length;
            if (styleOpens !== styleCloses) {
              syntaxErrors.push(`Mismatched <style> tags: ${styleOpens} opened vs ${styleCloses} closed`);
            }
          } catch (e) {
            console.warn('Final syntax check failed:', e);
          }
        }
        
        // 2. Get FRESH console logs (runtime errors)
        const finalCheckErrors = getConsoleLogs(false, 50).filter(l => l.level === 'error');
        
        // 3. Combine all errors
        const allErrors = [
          ...syntaxErrors.map(e => ({ type: 'syntax', message: e })),
          ...finalCheckErrors.map(e => ({ type: 'runtime', message: e.message }))
        ];
        
        // If NO errors, we're done!
        if (allErrors.length === 0) {
          console.log(' FINAL ERROR CHECK: No syntax or runtime errors detected. Changes are clean!');
        } else {
          // Errors found - check if we should auto-fix or just report
          console.warn(` FINAL ERROR CHECK: Found ${allErrors.length} error(s)!`);
          console.warn(`   Syntax errors: ${syntaxErrors.length}`);
          console.warn(`   Runtime errors: ${finalCheckErrors.length}`);
          allErrors.forEach((err, i) => {
            console.warn(`   ${i + 1}. [${err.type}] ${err.message}`);
          });
          
          // Check if we've already tried auto-fixing too many times
          if (autoFixAttempts >= MAX_AUTO_FIX_ATTEMPTS) {
            console.warn(` AUTO-FIX: Already tried ${autoFixAttempts} times. Stopping to prevent infinite loop.`);
            addMessageToChat('system error', ` Found ${allErrors.length} error(s) but auto-fix limit reached. Please type "fix the error" to try again manually.\n\nErrors: ${allErrors.slice(0, 3).map(e => e.message).join('; ')}`);
            autoFixAttempts = 0; // Reset for next user request
          } else if (window.userIntentIsQuestion) {
            //  USER ASKED A QUESTION - Don't auto-fix, just report errors
            console.log(' INTENTION CHECK: User asked a question, not requesting fixes. Skipping auto-fix.');
            console.warn(` Errors detected (not auto-fixing): ${allErrors.slice(0, 3).map(e => e.message).join('; ')}`);
            // Reset the flag for next interaction
            window.userIntentIsQuestion = false;
          } else {
            // Build a natural fix prompt like the user would type
            const errorSummary = allErrors.slice(0, 2).map(e => e.message).join('; ');
            const errorLower = errorSummary.toLowerCase();
            
            let fixPrompt = '';
            if (errorLower.includes('fetch') || errorLower.includes('api') || errorLower.includes('load') || errorLower.includes('network') || errorLower.includes('failed to')) {
              fixPrompt = `Fix the data loading issue. Error: ${errorSummary}`;
            } else if (errorLower.includes('undefined') || errorLower.includes('null') || errorLower.includes('cannot read')) {
              fixPrompt = `Fix the null/undefined error: ${errorSummary}`;
            } else if (errorLower.includes('syntax') || errorLower.includes('unexpected')) {
              fixPrompt = `Fix the JavaScript syntax error: ${errorSummary}`;
            } else {
              fixPrompt = `Fix this error in the app: ${errorSummary}`;
            }
            
            autoFixAttempts++;
            addMessageToChat('system', ` Found ${allErrors.length} error(s). Auto-sending fix request... (Attempt ${autoFixAttempts}/${MAX_AUTO_FIX_ATTEMPTS})`);
            
            // TRULY FRESH APPROACH: Queue a real sendMessage call via setTimeout
            // This simulates exactly what happens when user types the fix request
            setTimeout(() => {
              console.log(` AUTO-FIX: Sending REAL fresh message: "${fixPrompt}" (Attempt ${autoFixAttempts})`);
              // Reset conversation history to truly start fresh
              conversationHistory.length = 0;
              conversationHasFullHTML = false;
              sendMessage(fixPrompt);
            }, 500);
          }
        }
      }
      
      // ===== ENHANCEMENTS: Cleanup =====
      if (window.appBuilderEnhancements) {
        const enh = window.appBuilderEnhancements;
        stopWatchdog();
        const stopBtn = document.getElementById('stopGenerationBtn');
        if (stopBtn) stopBtn.style.display = 'none';
        enh.streamAbortController = null;
        enh.loopMetrics.successfulCompletions++;
      }
      // ===== END ENHANCEMENTS =====

      return finalResponse;
    }
    
    function addThinkingMessage(thinkingText, toolCount) {
      // Strip emojis from thinking text
      const cleanThinkingText = stripEmojis(thinkingText);
      
      // Stream to minimal mode nudge if active
      if (isMinimalMode) {
        addMinimalUpdateItem(cleanThinkingText);
      }
      
      const messagesContainer = document.getElementById('chatMessages');
      const thinkingDiv = document.createElement('div');
      thinkingDiv.className = 'chat-message assistant thinking-message';
      
      // Create collapsible thinking section
      const thinkingId = 'thinking-' + Date.now();
      
      // Truncate preview to first 80 characters (plain text)
      const preview = cleanThinkingText.substring(0, 80).replace(/\n/g, ' ').trim() + (cleanThinkingText.length > 80 ? '...' : '');
      
      // Create the header (comment style)
      const header = document.createElement('div');
      header.className = 'thinking-header';
      header.onclick = () => toggleThinking(thinkingId);
      
      const headerText = document.createElement('span');
      headerText.className = 'thinking-label';
      headerText.textContent = `// ${preview}`;
      
      const badge = document.createElement('span');
      badge.className = 'thinking-badge';
      badge.textContent = `${toolCount} action${toolCount > 1 ? 's' : ''}`;
      
      const chevron = document.createElement('i');
      chevron.setAttribute('data-lucide', 'chevron-down');
      chevron.className = 'thinking-chevron';
      chevron.id = `${thinkingId}-chevron`;
      chevron.style.width = '14px';
      chevron.style.height = '14px';
      
      header.appendChild(headerText);
      header.appendChild(badge);
      header.appendChild(chevron);
      
      // Create the content (code-style display)
      const contentDiv = document.createElement('div');
      contentDiv.className = 'thinking-content';
      contentDiv.id = thinkingId;
      contentDiv.style.display = 'none';
      contentDiv.textContent = cleanThinkingText;
      
      thinkingDiv.appendChild(header);
      thinkingDiv.appendChild(contentDiv);
      
      messagesContainer.appendChild(thinkingDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      // Initialize icons
      initLucideIcons();
    }
    
    function toggleThinking(thinkingId) {
      const content = document.getElementById(thinkingId);
      const chevron = document.getElementById(thinkingId + '-chevron');
      
      if (content.style.display === 'none') {
        content.style.display = 'block';
        chevron.style.transform = 'rotate(180deg)';
      } else {
        content.style.display = 'none';
        chevron.style.transform = 'rotate(0deg)';
      }
    }
    
    function stripEmojis(text) {
      if (!text || typeof text !== 'string') return text;
      
      // Comprehensive emoji regex that covers all Unicode emoji ranges
      const emojiRegex = /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{1F900}-\u{1F9FF}]|[\u{1FA70}-\u{1FAFF}]|[\u{1F018}-\u{1F270}]|[\u{238C}-\u{2454}]|[\u{20D0}-\u{20FF}]|[\u{FE0F}]|[\u{E0020}-\u{E007F}]|[\u{1F191}-\u{1F251}]/gu;
      
      return text.replace(emojiRegex, '');
    }
    
    function addMessageToChat(role, content, versionNumber, skipSave = false, imageData = null) {
      const messagesContainer = document.getElementById('chatMessages');
      const messageDiv = document.createElement('div');
      messageDiv.className = `chat-message ${role}`;
      
      // Add version number as hidden data attribute (hidden from user, acts as primary key)
      if (versionNumber !== undefined && versionNumber !== null) {
        messageDiv.setAttribute('data-version-number', versionNumber);
      }
      
      // Strip emojis from content (AI should only use Lucide icons)
      const cleanContent = stripEmojis(content);
      
      let formattedContent = cleanContent
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\n/g, '<br>');
      
      // Add image thumbnails if image data is provided (supports both single image and array of images)
      let imageHTML = '';
      if (imageData) {
        // Handle both single image (old format) and multiple images (new format)
        const images = Array.isArray(imageData) ? imageData : [{ data: imageData, name: 'image' }];
        
        images.forEach((img, index) => {
          const imgData = img.data || img; // Handle both {data, name} objects and plain data URLs
          
          // Security: Validate that imageData is a proper data URL to prevent XSS
          if (!imgData.startsWith('data:image/') && !img.isSVGText) {
            console.error(' Invalid image data format - must be a data:image/ URL');
            return; // Skip this image
          }
          
          // Additional size check: Warn if image is very large (>5MB base64)
          if (imgData.length > 5 * 1024 * 1024 * 1.33) { // 5MB * 1.33 (base64 overhead)
            console.warn(' Large image detected (>5MB). This may cause performance issues.');
          }
          
          const imageId = `msg-img-${Date.now()}-${index}-${Math.random().toString(36).substr(2, 9)}`;
          const imageName = img.name || `Image ${index + 1}`;
          
          // For SVG text, show a placeholder icon instead of trying to render
          if (img.isSVGText) {
            imageHTML += `
              <div class="message-image-container" style="margin-bottom: 8px; margin-right: 8px; position: relative; display: inline-block;">
                <div id="${imageId}"
                     style="width: 200px; height: 150px; border-radius: 4px; border: 1px solid #e5e7eb; background: #f3f4f6; display: flex; align-items: center; justify-content: center; flex-direction: column; cursor: default;">
                  <div style="font-size: 48px; color: #9ca3af;"></div>
                  <div style="font-size: 12px; color: #6b7280; margin-top: 8px;">${imageName}</div>
                  <div style="font-size: 11px; color: #9ca3af;">SVG Code</div>
                </div>
                <button class="btn-remove-msg-image" 
                        onclick="removeMsgImage('${imageId}')"
                        style="position: absolute; top: 4px; right: 4px; background: rgba(239, 68, 68, 0.9); color: white; border: none; border-radius: 4px; width: 24px; height: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; line-height: 1; padding: 0;"
                        title="Remove image"></button>
              </div>`;
          } else {
            imageHTML += `
              <div class="message-image-container" style="margin-bottom: 8px; margin-right: 8px; position: relative; display: inline-block;">
                <img src="${imgData}" 
                     id="${imageId}"
                     style="max-width: 200px; max-height: 150px; border-radius: 4px; border: 1px solid #e5e7eb; cursor: pointer;" 
                     onclick="window.open(this.src, '_blank')"
                     title="Click to view full size - ${imageName}" />
                <button class="btn-remove-msg-image" 
                        onclick="removeMsgImage('${imageId}')"
                        style="position: absolute; top: 4px; right: 4px; background: rgba(239, 68, 68, 0.9); color: white; border: none; border-radius: 4px; width: 24px; height: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; line-height: 1; padding: 0;"
                        title="Remove image"></button>
              </div>`;
          }
        });
      }
      
      messageDiv.innerHTML = `${imageHTML}<span>${formattedContent}</span>`;
      messagesContainer.appendChild(messageDiv);
      
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      // Track UI message for persistence (skip if loading from DB)
      if (!skipSave) {
        const messageObj = {
          role,
          content,
          versionNumber,
          timestamp: new Date().toISOString()
        };
        
        // Add image data if present (store as array for consistency)
        if (imageData) {
          messageObj.imageData = imageData;
        }
        
        chatUIMessages.push(messageObj);
        
        // Keep only last 50 UI messages in memory
        if (chatUIMessages.length > 50) {
          chatUIMessages = chatUIMessages.slice(-50);
        }
      }
      
      // Update version buttons after adding user messages
      if (role === 'user') {
        setTimeout(() => updateChatVersionButtons(), 50);
      }
    }
    
    function addTypingIndicator() {
      const messagesContainer = document.getElementById('chatMessages');
      const typingDiv = document.createElement('div');
      const id = 'typing-' + Date.now();
      typingDiv.id = id;
      typingDiv.className = 'chat-message assistant';
      typingDiv.innerHTML = '<div class="typing-indicator"><span></span><span></span><span></span></div>';
      messagesContainer.appendChild(typingDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      return id;
    }
    
    function removeTypingIndicator(id) {
      const indicator = document.getElementById(id);
      if (indicator) indicator.remove();
    }
    
    // Remove image from a chat message
    function removeMsgImage(imageId) {
      try {
        const imgElement = document.getElementById(imageId);
        if (!imgElement) return;
        
        const container = imgElement.closest('.message-image-container');
        const messageDiv = imgElement.closest('.chat-message');
        
        if (container) {
          container.remove();
        }
        
        // Update the stored message to remove imageData
        if (messageDiv && messageDiv.hasAttribute('data-version-number')) {
          const versionNumber = parseInt(messageDiv.getAttribute('data-version-number'));
          const msgIndex = chatUIMessages.findIndex(m => m.versionNumber === versionNumber);
          if (msgIndex !== -1 && chatUIMessages[msgIndex].imageData) {
            delete chatUIMessages[msgIndex].imageData;
            // Save updated chat history
            saveChatHistory().catch(err => console.warn('Failed to save after image removal:', err));
          }
        }
      } catch (error) {
        console.error('Error removing message image:', error);
      }
    }
    
    // ===== TODO LIST DISPLAY =====
    function displayTodoList(todos) {
      const messagesContainer = document.getElementById('chatMessages');
      
      // Remove existing todo list if any
      const existingTodoList = document.getElementById('ai-todo-list');
      if (existingTodoList) {
        existingTodoList.remove();
      }
      
      // Create todo list container
      const todoListDiv = document.createElement('div');
      todoListDiv.id = 'ai-todo-list';
      todoListDiv.className = 'chat-message system';
      todoListDiv.style.cssText = `
        background: linear-gradient(135deg, rgba(0, 83, 226, 0.05) 0%, rgba(75, 221, 245, 0.05) 100%);
        border-left: 4px solid var(--primary-blue);
        padding: 16px;
        margin: 8px 0;
        border-radius: 8px;
      `;
      
      // Create header
      const header = document.createElement('div');
      header.style.cssText = `
        font-weight: 600;
        color: var(--primary-blue);
        margin-bottom: 12px;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 8px;
      `;
      
      const completedCount = todos.filter(t => t.status === 'completed').length;
      header.innerHTML = `
        <span></span>
        <span>Implementation Progress (${completedCount}/${todos.length})</span>
      `;
      todoListDiv.appendChild(header);
      
      // Create todo items
      const todosList = document.createElement('div');
      todosList.style.cssText = 'display: flex; flex-direction: column; gap: 8px;';
      
      todos.forEach(todo => {
        const todoItem = document.createElement('div');
        todoItem.style.cssText = `
          display: flex;
          align-items: flex-start;
          gap: 8px;
          padding: 8px;
          background: white;
          border-radius: 6px;
          font-size: 13px;
        `;
        
        let statusIcon = '';
        let statusColor = '';
        let textStyle = '';
        
        if (todo.status === 'completed') {
          statusIcon = '';
          statusColor = 'var(--success-green)';
          textStyle = 'text-decoration: line-through; opacity: 0.7;';
        } else if (todo.status === 'in_progress') {
          statusIcon = '';
          statusColor = 'var(--primary-blue)';
          textStyle = 'font-weight: 500;';
        } else {
          statusIcon = '';
          statusColor = 'var(--gray-text)';
          textStyle = '';
        }
        
        todoItem.innerHTML = `
          <span style="flex-shrink: 0; font-size: 16px;">${statusIcon}</span>
          <span style="flex: 1; ${textStyle} color: ${statusColor};">${todo.task}</span>
        `;
        
        todosList.appendChild(todoItem);
      });
      
      todoListDiv.appendChild(todosList);
      messagesContainer.appendChild(todoListDiv);
      
      // Scroll to show the todo list
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    // ===== TOOL EXECUTION =====
    async function executeToolActions(toolUseBlocks, conversationHistory) {
      const startTime = Date.now();
      const toolResults = [];
      
      // Create progress indicator if not already present
      if (!currentProgressIndicator) {
        createProgressIndicator();
      }
      
      for (const toolUse of toolUseBlocks) {
        
        // Update progress indicator with current tool (instead of showing message in chat)
        const progressMessage = getProgressStage(toolUse.name, toolUse.input);
        
        // Determine phase
        const planningTools = ['get_project_context', 'get_current_html', 'find_code_locations', 'check_table_schema', 'query_database', 'get_console_logs'];
        const implementingTools = ['generate_html', 'update_html', 'create_table', 'modify_table_schema'];
        
        if (planningTools.includes(toolUse.name)) {
          updateProgressIndicator('planning', progressMessage);
        } else if (implementingTools.includes(toolUse.name)) {
          updateProgressIndicator('implementing', progressMessage);
        } else {
          updateProgressIndicator(progressPhase, progressMessage);
        }
        
        // Keep original user messages for console logging/debugging (not shown in chat)
        let userMessage = '';
        switch(toolUse.name) {
          case 'get_project_context':
            userMessage = ' Checking existing tables and schemas...';
            break;
          case 'query_database':
            userMessage = ` Previewing data from '${toolUse.input.table_name}' table...`;
            break;
          case 'create_table':
            userMessage = ` Preparing to create table '${toolUse.input.table_name}'...`;
            break;
          case 'modify_table_schema':
            userMessage = ` Requesting approval to add column '${toolUse.input.column_name}' to '${toolUse.input.table_name}'...`;
            break;
          case 'check_table_schema':
            userMessage = ` Verifying schema for '${toolUse.input.table_name}' table...`;
            break;
          case 'update_html':
            userMessage = ' Applying incremental updates...';
            break;
          case 'generate_html':
            userMessage = ' Generating HTML...';
            break;
          case 'get_console_logs':
            userMessage = ' Reading console logs from preview...';
            break;
          case 'execute_javascript':
            userMessage = ` Testing: ${toolUse.input.description || 'Running JavaScript'}...`;
            break;
          case 'create_todo_list':
            userMessage = ` Creating implementation plan with ${toolUse.input.todos?.length || 0} steps...`;
            break;
          case 'update_todo':
            userMessage = ` Updating progress...`;
            break;
          case 'verify_edit':
            userMessage = ` Verifying changes were applied...`;
            break;
          case 'analyze_css_scope':
            userMessage = ` Analyzing CSS scope for "${toolUse.input.selector}"...`;
            break;
          default:
            userMessage = ` Executing: ${toolUse.name}...`;
        }
        
        // Don't show individual progress messages in chat - use progress indicator instead
        // const progressId = addProgressMessage(userMessage);
        const progressId = null; // Keep for compatibility with completion logic
        
        try {
          // Execute tool with timeout detection
          const toolStartTime = Date.now();
          const TOOL_TIMEOUT_MS = 120000; // 120 second timeout (2 minutes)
          
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error(`Tool execution timeout after ${TOOL_TIMEOUT_MS / 1000}s`)), TOOL_TIMEOUT_MS);
          });
          
          const toolPromise = executeTool(toolUse.name, toolUse.input);
          
          // Race between tool execution and timeout
          let result = await Promise.race([toolPromise, timeoutPromise]);
          
          // CRITICAL: Ensure result is always a string (some tools might return objects)
          if (typeof result !== 'string') {
            console.warn(`Tool ${toolUse.name} returned non-string result, converting to JSON`);
            result = JSON.stringify(result);
          }
          
          // Validate it's valid JSON
          try {
            JSON.parse(result);
          } catch (parseError) {
            console.error(`Tool ${toolUse.name} returned invalid JSON:`, result);
            result = JSON.stringify({ 
              success: false, 
              error: 'Tool returned invalid JSON response',
              raw_result: String(result).substring(0, 500)
            });
          }
          
          toolResults.push({
            type: 'tool_result',
            tool_use_id: toolUse.id,
            content: result
          });
          
          // Don't update individual progress messages - progress indicator handles this
          // updateProgressMessage(progressId, getCompletedMessage(toolUse.name, toolUse.input), true);
          // setTimeout(() => removeProgressMessage(progressId), 1500);
        } catch (error) {
          console.error(`Tool ${toolUse.name} threw error:`, error);
          
          const isTimeout = error.message.includes('timeout');
          
          const errorMsg = isTimeout 
            ? ` Timeout: ${toolUse.name} took too long. Try smaller changes or use update_html instead.`
            : ` Error: ${error.message.substring(0, 100)}`;
            
          // Don't show error in chat - will be handled by final result
          // updateProgressMessage(progressId, errorMsg, true);
          
          // Add error result - ALWAYS return valid JSON
          const errorResult = {
            success: false,
            error: error.message || 'Unknown error',
            tool_name: toolUse.name,
            stack: error.stack ? error.stack.substring(0, 200) : undefined
          };
          
          toolResults.push({
            type: 'tool_result',
            tool_use_id: toolUse.id,
            content: JSON.stringify(errorResult),
            is_error: true
          });
          
          // Keep error messages visible longer
          setTimeout(() => removeProgressMessage(progressId), 3000);
        }
      }
      
      // CRITICAL: Validate all tool results before pushing to history
      console.log(` Executed ${toolResults.length} tools:`, toolUseBlocks.map(t => t.name).join(', '));
      
      // Verify every tool_use has a corresponding tool_result
      const toolUseIds = new Set(toolUseBlocks.map(t => t.id));
      const toolResultIds = new Set(toolResults.map(r => r.tool_use_id));
      
      for (const id of toolUseIds) {
        if (!toolResultIds.has(id)) {
          console.error(` MISSING tool_result for tool_use id: ${id}`);
          // Add a fallback error result
          toolResults.push({
            type: 'tool_result',
            tool_use_id: id,
            content: JSON.stringify({
              success: false,
              error: 'Internal error: tool execution did not return a result'
            }),
            is_error: true
          });
        }
      }
      
      // IMPORTANT: Do NOT truncate tool results - AI needs full context to generate correct code
      // Truncation causes syntax errors because AI can't see complete code structure
      const truncatedResults = toolResults; // Keep full results
      
      // VALIDATION: Ensure all tool_results have valid tool_use_id matching previous assistant message
      let validatedToolResults = truncatedResults;
      const lastAssistantMsg = conversationHistory[conversationHistory.length - 1];
      if (lastAssistantMsg && lastAssistantMsg.role === 'assistant' && Array.isArray(lastAssistantMsg.content)) {
        const assistantToolUseIds = new Set(
          lastAssistantMsg.content
            .filter(block => block.type === 'tool_use')
            .map(block => block.id)
        );
        
        // Filter out any tool_results with IDs that don't match
        validatedToolResults = truncatedResults.filter(result => {
          if (!result.tool_use_id) {
            console.error(' tool_result missing tool_use_id:', result);
            return false;
          }
          if (!assistantToolUseIds.has(result.tool_use_id)) {
            console.error(` tool_result has orphaned tool_use_id: ${result.tool_use_id}`);
            console.error('Available IDs:', [...assistantToolUseIds]);
            return false;
          }
          return true;
        });
        
        if (validatedToolResults.length !== truncatedResults.length) {
          console.warn(` Filtered ${truncatedResults.length - validatedToolResults.length} invalid tool results`);
        }
      }
      
      // Only add to history if we have valid results
      if (validatedToolResults.length > 0) {
        conversationHistory.push({
          role: 'user',
          content: validatedToolResults
        });
        
        const totalSize = validatedToolResults.reduce((sum, r) => sum + (r.content?.length || 0), 0);
        console.log(` Added ${validatedToolResults.length} tool results (${(totalSize/1024).toFixed(1)}KB) to conversation history`);
        
        // Enforce message limit after adding tool results
        enforceMessageLimit(conversationHistory);
      } else {
        console.warn(' No valid tool results to add to conversation history');
      }
      
      // WORKFLOW GUIDANCE: Generate and inject programmatic next-step guidance
      if (toolUseBlocks.length > 0 && validatedToolResults.length > 0) {
        const lastToolUse = toolUseBlocks[toolUseBlocks.length - 1];
        const lastToolResult = validatedToolResults[validatedToolResults.length - 1];
        
        try {
          // Get user's original intent from the first user message
          const firstUserMessage = chatConversationHistory.find(m => m.role === 'user');
          const userIntent = typeof firstUserMessage?.content === 'string' 
            ? firstUserMessage.content 
            : '';
          
          // Generate workflow guidance based on the tool that just executed
          const workflowGuidance = generateWorkflowGuidance(
            lastToolUse.name, 
            lastToolResult.content,
            userIntent
          );
          
          // Inject guidance into the conversation
          injectWorkflowGuidance(conversationHistory, workflowGuidance);
        } catch (err) {
          console.warn(' Failed to generate workflow guidance:', err);
        }
      }
      
      // Show completion message
      const hasGeneration = toolUseBlocks.some(t => t.name === 'generate_html');
      if (hasGeneration) {
        // Don't add system message - let the AI's response be the only message
      }
    }
    
    function addProgressMessage(message, messageId) {
      // Stream to minimal mode nudge if active
      if (isMinimalMode) {
        addMinimalUpdateItem(message);
      }
      
      const messagesContainer = document.getElementById('chatMessages');
      const msgDiv = document.createElement('div');
      msgDiv.className = 'chat-message system';
      msgDiv.id = messageId || `progress-${Date.now()}`;
      msgDiv.innerHTML = `<span>${message}</span>`;
      messagesContainer.appendChild(msgDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      return msgDiv.id;
    } 
    
    function updateProgressMessage(messageId, newMessage, isComplete = false) {
      // Stream update to minimal mode if active (only completed messages)
      if (isMinimalMode && isComplete) {
        // Update the last item in the nudge list
        const updateList = document.getElementById('minimalUpdateList');
        if (updateList && updateList.lastChild) {
          updateList.lastChild.textContent = newMessage;
        }
      }
      
      const msgDiv = document.getElementById(messageId);
      if (msgDiv) {
        if (isComplete) {
          msgDiv.innerHTML = `<i data-lucide="check-circle"></i> <span>${newMessage}</span>`;
        } else {
          msgDiv.innerHTML = `<i data-lucide="loader-2"></i> <span>${newMessage}</span>`;
        }
        initLucideIcons();
      }
    }
    //pull
    function removeProgressMessage(messageId) {
      const msgDiv = document.getElementById(messageId);
      if (msgDiv) {
        msgDiv.style.opacity = '0';
        msgDiv.style.transition = 'opacity 0.3s';
        setTimeout(() => msgDiv.remove(), 300);
      }
    }
    
    function getCompletedMessage(toolName, toolInput) {
      switch(toolName) {
        case 'get_project_context':
          return ' Retrieved project context';
        case 'query_database':
          return ` Previewed ${toolInput.table_name}`;
        case 'create_table':
          return ` Created table '${toolInput.table_name}'`;
        case 'modify_table_schema':
          return ` Added column '${toolInput.column_name}' to ${toolInput.table_name}`;
        case 'check_table_schema':
          return ` Verified schema for ${toolInput.table_name}`;
        case 'find_code_locations':
          return ` Found locations for: "${toolInput.intent}"`;
        case 'get_code_context':
          return ` Expanded context around line ${toolInput.line_number}`;
        case 'search_html':
          return ` Searched for "${toolInput.search_term}"`;
        case 'get_html_section':
          if (toolInput.start_line && toolInput.end_line) {
            return ` Retrieved lines ${toolInput.start_line}-${toolInput.end_line}`;
          }
          return ' Retrieved HTML section';
        case 'get_current_html':
          return ' Retrieved full HTML file';
        case 'update_html':
          // This message is now replaced by the diff viewer
          return ` Applied ${toolInput.edits?.length || 0} change(s)`;
        case 'generate_html':
          return ' Generated HTML';
        case 'get_console_logs':
          return ` Retrieved console logs`;
        case 'execute_javascript':
          return ` JavaScript executed`;
        case 'create_todo_list':
          return ` Created implementation plan`;
        case 'update_todo':
          return ` Updated progress`;
        case 'verify_edit':
          return ` Verification complete`;
        case 'analyze_css_scope':
          return ` CSS scope analysis complete`;
        default:
          return ` Completed: ${toolName}`;
      }
    }
    
    // ===== INTELLIGENT CODE ANALYZER =====
    
    // TF-IDF style scoring for better semantic matching
    function calculateRelevanceScore(text, intentKeywords) {
      const lowerText = text.toLowerCase();
      let score = 0;
      
      // Exact phrase match gets highest score
      const intentPhrase = intentKeywords.join(' ');
      if (lowerText.includes(intentPhrase)) {
        score += 20;
      }
      
      // Individual keyword matches
      intentKeywords.forEach(keyword => {
        if (lowerText.includes(keyword)) {
          // Score based on how "important" the keyword is (inverse document frequency simulation)
          const wordLength = keyword.length;
          const wordScore = Math.min(wordLength, 8); // Cap at 8 points per word
          
          // Bonus if keyword appears multiple times
          const occurrences = (lowerText.match(new RegExp(keyword, 'g')) || []).length;
          score += wordScore * Math.min(occurrences, 3); // Max 3x bonus
          
          // Bonus if keyword appears at word boundary (not part of another word)
          const wordBoundaryRegex = new RegExp('\\b' + keyword + '\\b', 'i');
          if (wordBoundaryRegex.test(lowerText)) {
            score += 5; // Exact word match bonus
          }
        }
      });
      
      return score;
    }
    
    function analyzeHTMLStructure(html, intent, includeDependencies = true) {
      const lines = html.split('\n');
      const analysis = {
        functions: [],
        eventHandlers: [],
        styles: [],
        htmlSections: [],
        relevantCode: []
      };
      
      // Parse the HTML to find structure
      let inScript = false;
      let inStyle = false;
      let currentFunction = null;
      let braceDepth = 0;
      
      // Keywords to look for based on intent
      const intentKeywords = intent.toLowerCase().split(/\s+/).filter(w => w.length > 2); // Filter out short words like "a", "the"
      
      lines.forEach((line, idx) => {
        const lineNum = idx + 1;
        const trimmed = line.trim();
        
        // Track script/style sections
        if (trimmed.includes('<' + 'script')) inScript = true;
        if (trimmed.includes('<' + '/script>')) inScript = false;
        if (trimmed.includes('<' + 'style')) inStyle = true;
        if (trimmed.includes('<' + '/style>')) inStyle = false;
        
        // Find functions
        if (inScript) {
          // Function declarations
          const funcMatch = line.match(/(?:function\s+(\w+)|(?:const|let|var)\s+(\w+)\s*=\s*(?:function|async\s+function|\([^)]*\)\s*=>))/);
          if (funcMatch) {
            const funcName = funcMatch[1] || funcMatch[2];
            currentFunction = {
              name: funcName,
              startLine: lineNum,
              endLine: lineNum,
              type: 'function',
              relevanceScore: 0
            };
            
            // Score relevance using improved semantic matching
            currentFunction.relevanceScore = calculateRelevanceScore(funcName, intentKeywords);
            
            analysis.functions.push(currentFunction);
          }
          
          // Track brace depth to find function end
          braceDepth += (line.match(/{/g) || []).length;
          braceDepth -= (line.match(/}/g) || []).length;
          
          if (currentFunction && braceDepth === 0 && line.includes('}')) {
            currentFunction.endLine = lineNum;
            currentFunction = null;
          }
          
          // Find event handlers
          const eventMatch = line.match(/\.addEventListener\(['"](\w+)['"]/);
          if (eventMatch) {
            analysis.eventHandlers.push({
              event: eventMatch[1],
              line: lineNum,
              snippet: trimmed,
              relevanceScore: intentKeywords.some(k => trimmed.toLowerCase().includes(k)) ? 5 : 0
            });
          }
          
          // Find onclick, onchange, etc.
          const inlineEventMatch = line.match(/\bon(\w+)\s*=/);
          if (inlineEventMatch) {
            analysis.eventHandlers.push({
              event: inlineEventMatch[1],
              line: lineNum,
              snippet: trimmed,
              relevanceScore: intentKeywords.some(k => trimmed.toLowerCase().includes(k)) ? 5 : 0
            });
          }
        }
        
        // Find CSS sections
        if (inStyle) {
          const selectorMatch = line.match(/^\s*([.#]?[\w-]+(?:\s*,\s*[.#]?[\w-]+)*)\s*{/);
          if (selectorMatch) {
            const selector = selectorMatch[1];
            let styleEndLine = lineNum;
            let depth = 1;
            
            // Find end of style block
            for (let i = idx + 1; i < lines.length && depth > 0; i++) {
              depth += (lines[i].match(/{/g) || []).length;
              depth -= (lines[i].match(/}/g) || []).length;
              styleEndLine = i + 1;
            }
            
            analysis.styles.push({
              selector: selector,
              startLine: lineNum,
              endLine: styleEndLine,
              relevanceScore: intentKeywords.some(k => selector.toLowerCase().includes(k) || selector.includes(k)) ? 5 : 0
            });
          }
        }
        
        // Find HTML sections (divs, sections, nav, header, etc.)
        if (!inScript && !inStyle) {
          // Check for HTML comment headers (e.g., <!-- Analytics Chart -->)
          const commentMatch = line.match(/<!--\s*(.+?)\s*-->/);
          if (commentMatch) {
            const commentText = commentMatch[1];
            const commentRelevance = calculateRelevanceScore(commentText, intentKeywords);
            
            if (commentRelevance > 0) {
              analysis.htmlSections.push({
                tag: 'comment',
                identifier: commentText,
                line: lineNum,
                snippet: `<!-- ${commentText} -->`,
                relevanceScore: commentRelevance + 10 // Bonus for comments (they're usually descriptive)
              });
            }
          }
          
          // Check for HTML tags with id or class
          const htmlTagMatch = line.match(/<(div|section|nav|header|footer|main|aside|article|canvas|table|form|button)\s+(?:id|class)=["']([^"']+)["']/);
          if (htmlTagMatch) {
            const tag = htmlTagMatch[1];
            const identifier = htmlTagMatch[2];
            
            const tagRelevance = calculateRelevanceScore(identifier, intentKeywords);
            
            analysis.htmlSections.push({
              tag: tag,
              identifier: identifier,
              line: lineNum,
              snippet: trimmed.substring(0, 100),
              relevanceScore: tagRelevance
            });
          }
          
          // Also check for standalone tags that might be important
          const standaloneTagMatch = line.match(/<(canvas|table|form|input|button|select)[^>]*>/);
          if (standaloneTagMatch && !htmlTagMatch) {
            const tag = standaloneTagMatch[1];
            const tagRelevance = calculateRelevanceScore(line, intentKeywords);
            
            if (tagRelevance > 0) {
              analysis.htmlSections.push({
                tag: tag,
                identifier: `${tag} element`,
                line: lineNum,
                snippet: trimmed.substring(0, 100),
                relevanceScore: tagRelevance
              });
            }
          }
        }
        
        // Check if line is relevant to intent
        const lineRelevance = intentKeywords.reduce((score, keyword) => {
          return score + (line.toLowerCase().includes(keyword) ? 1 : 0);
        }, 0);
        
        if (lineRelevance > 0) {
          analysis.relevantCode.push({
            line: lineNum,
            content: line,
            relevanceScore: lineRelevance
          });
        }
      });
      
      // Sort by relevance
      analysis.functions.sort((a, b) => b.relevanceScore - a.relevanceScore);
      analysis.eventHandlers.sort((a, b) => b.relevanceScore - a.relevanceScore);
      analysis.styles.sort((a, b) => b.relevanceScore - a.relevanceScore);
      analysis.htmlSections.sort((a, b) => b.relevanceScore - a.relevanceScore);
      analysis.relevantCode.sort((a, b) => b.relevanceScore - a.relevanceScore);
      
      return analysis;
    }
    
    function buildIntelligentContext(analysis, html, includeDependencies) {
      const lines = html.split('\n');
      const sections = [];
      const linesCovered = new Set();
      
      // Helper to extract lines with context
      function extractSection(startLine, endLine, label, addContext = 5) {
        const start = Math.max(1, startLine - addContext);
        const end = Math.min(lines.length, endLine + addContext);
        
        // Don't duplicate lines we've already included
        let hasNew = false;
        for (let i = start; i <= end; i++) {
          if (!linesCovered.has(i)) {
            hasNew = true;
            break;
          }
        }
        
        if (!hasNew) return null;
        
        for (let i = start; i <= end; i++) {
          linesCovered.add(i);
        }
        
        const sectionLines = lines.slice(start - 1, end);
        const formatted = sectionLines
          .map((line, idx) => `${(start + idx).toString().padStart(5, ' ')} | ${line}`)
          .join('\n');
        
        return {
          label: label,
          startLine: start,
          endLine: end,
          content: formatted
        };
      }
      
      // Add most relevant functions (top 3)
      analysis.functions.slice(0, 3).forEach((func, idx) => {
        const section = extractSection(func.startLine, func.endLine, `Function: ${func.name}`, 2);
        if (section) sections.push(section);
      });
      
      // Add most relevant HTML sections (top 3)
      analysis.htmlSections.slice(0, 3).forEach((sec, idx) => {
        const section = extractSection(sec.line, sec.line + 15, `HTML: ${sec.tag}.${sec.identifier}`, 3);
        if (section) sections.push(section);
      });
      
      // Add most relevant styles (top 3)
      if (includeDependencies) {
        analysis.styles.slice(0, 3).forEach((style, idx) => {
          const section = extractSection(style.startLine, style.endLine, `Style: ${style.selector}`, 1);
          if (section) sections.push(section);
        });
      }
      
      // Add event handlers
      if (includeDependencies && analysis.eventHandlers.length > 0) {
        analysis.eventHandlers.slice(0, 5).forEach((handler, idx) => {
          const section = extractSection(handler.line, handler.line, `Event: ${handler.event}`, 3);
          if (section) sections.push(section);
        });
      }
      
      // Add highly relevant individual lines (top 10)
      const topRelevantLines = analysis.relevantCode.slice(0, 10);
      if (topRelevantLines.length > 0) {
        topRelevantLines.forEach(item => {
          const section = extractSection(item.line, item.line, `Relevant`, 2);
          if (section) sections.push(section);
        });
      }
      
      return sections;
    }
    
    async function executeTool(toolName, toolInput) {
      try {
        switch (toolName) {
          case 'find_code_locations':
            //  CURSOR-STYLE: Find candidate locations (small snippets)
            if (!generatedHTML || generatedHTML.trim() === '') {
              return JSON.stringify({ 
                success: false, 
                message: 'No HTML currently in preview. Generate a page first using generate_html.',
                candidates: []
              });
            }
            
            if (!toolInput.intent) {
              return JSON.stringify({
                success: false,
                error: 'intent parameter is required',
                hint: 'Describe what you want to find (e.g., "the login button", "dark mode toggle function", "user validation")'
              });
            }
            
            const maxCandidates = toolInput.max_candidates || 4;
            
            // Phase 1: Semantic search to find ALL potential locations
            const analysis = analyzeHTMLStructure(generatedHTML, toolInput.intent, true);
            
            // Collect all relevant items with their scores
            const allMatches = [];
            
            // Add functions
            analysis.functions.forEach(f => {
              if (f.relevanceScore > 0) {
                allMatches.push({
                  type: 'function',
                  name: f.name,
                  startLine: f.startLine,
                  endLine: f.endLine,
                  score: f.relevanceScore,
                  ...f
                });
              }
            });
            
            // Add HTML sections
            analysis.htmlSections.forEach(s => {
              if (s.relevanceScore > 0) {
                allMatches.push({
                  type: 'html',
                  name: `${s.tag}.${s.identifier}`,
                  startLine: s.line,
                  endLine: s.line + 10, // Estimate
                  score: s.relevanceScore,
                  ...s
                });
              }
            });
            
            // Add style rules
            analysis.styles.forEach(s => {
              if (s.relevanceScore > 0) {
                allMatches.push({
                  type: 'css',
                  name: s.selector,
                  startLine: s.startLine,
                  endLine: s.endLine,
                  score: s.relevanceScore,
                  ...s
                });
              }
            });
            
            // Add event handlers
            analysis.eventHandlers.forEach(h => {
              if (h.relevanceScore > 0) {
                allMatches.push({
                  type: 'event_handler',
                  name: `${h.event} handler`,
                  startLine: h.line,
                  endLine: h.line + 5,
                  score: h.relevanceScore,
                  ...h
                });
              }
            });
            
            // Sort by relevance score (highest first)
            allMatches.sort((a, b) => b.score - a.score);
            
            // Take top N matches
            const topMatches = allMatches.slice(0, maxCandidates);
            
            // Phase 2: Extract context-aware snippets for each candidate
            const lines = generatedHTML.split('\n');
            const candidates = topMatches.map((match, idx) => {
              // Smarter snippet extraction based on type
              let snippetLines = 150; // Default: 150 lines before/after for maximum context
              let start = match.startLine - 1 - snippetLines;
              let end = match.startLine - 1 + snippetLines;
              
              // For HTML sections, keep the full 150-line context
              // (Don't shrink to small sections - we want lots of context!)
              if (match.type === 'html') {
                // Keep the 150 line default - don't override
                // This gives enough context to see related code
              }
              
              // For functions, use the full function body (with generous padding)
              if (match.type === 'function' && match.endLine) {
                start = Math.max(0, match.startLine - 20);
                end = Math.min(lines.length - 1, match.endLine + 20);
              }
              
              // For CSS, ensure we include COMPLETE rules with closing braces
              if (match.type === 'css' && match.endLine) {
                start = Math.max(0, match.startLine - 5);
                // Ensure we capture the closing brace - scan forward if needed
                let braceCount = 0;
                let cssEnd = match.endLine;
                for (let i = match.startLine - 1; i < Math.min(lines.length, match.endLine + 20); i++) {
                  const line = lines[i];
                  braceCount += (line.match(/{/g) || []).length;
                  braceCount -= (line.match(/}/g) || []).length;
                  if (braceCount === 0 && i >= match.startLine - 1) {
                    cssEnd = i + 1;
                    break;
                  }
                }
                end = Math.min(lines.length - 1, cssEnd + 5);
              }
              
              // Clamp to valid range
              start = Math.max(0, start);
              end = Math.min(lines.length - 1, end);
              
              const snippetContent = lines.slice(start, end + 1);
              const snippet = snippetContent
                .map((line, i) => {
                  const lineNum = start + i + 1;
                  const marker = lineNum === match.startLine ? ' ' : '  ';
                  return `${marker}${lineNum.toString().padStart(5, ' ')} | ${line}`;
                })
                .join('\n');
              
              // Check for incomplete CSS/JS blocks in the snippet
              const snippetText = snippetContent.join('\n');
              const openBraces = (snippetText.match(/{/g) || []).length;
              const closeBraces = (snippetText.match(/}/g) || []).length;
              const hasUnbalancedBraces = openBraces !== closeBraces;
              
              let structuralWarning = null;
              if (hasUnbalancedBraces) {
                const diff = openBraces - closeBraces;
                if (diff > 0) {
                  structuralWarning = ` INCOMPLETE CODE: Snippet has ${diff} unclosed brace(s). The closing } is OUTSIDE this snippet range. When editing, you MUST either: (1) EXPAND end_line to include the closing }, or (2) Include the closing } in your new_string. COUNT YOUR BRACES!`;
                } else {
                  structuralWarning = ` PARTIAL CODE: Snippet has ${Math.abs(diff)} extra closing brace(s). The opening { is BEFORE this snippet. When editing, you MUST either: (1) EXPAND start_line to include the opening {, or (2) Include the opening { in your new_string.`;
                }
              }
              
              return {
                candidate_id: idx + 1,
                type: match.type,
                description: match.name,
                line_number: match.startLine,
                relevance_score: match.score,
                snippet: snippet,
                snippet_range: `${start + 1}-${end + 1}`,
                total_lines: end - start + 1,
                structural_warning: structuralWarning,
                brace_balance: hasUnbalancedBraces ? { open: openBraces, close: closeBraces, difference: openBraces - closeBraces } : 'balanced'
              };
            });
            
            return JSON.stringify({
              success: true,
              intent: toolInput.intent,
              total_candidates: candidates.length,
              candidates: candidates,
              instructions: candidates.length > 0
                ? `Found ${candidates.length} candidate locations. Each snippet shows the surrounding context with line numbers. The arrow () marks the primary match line. Review all candidates to find the right section, then use update_html with LINE-BASED mode (start_line, end_line, new_string).`
                : 'No matches found. Try a broader search term, check for typos, or use get_current_html if you need to see the full file structure.',
              critical_reminder: candidates.length > 0 ? ' STRUCTURAL COMPLETENESS: Your new_string must be SELF-CONTAINED. If editing CSS, include the COMPLETE rule (selector + { + properties + }). If the snippet ends mid-rule, EXPAND your line range to include closing braces. Count braces: every { needs a matching }!' : undefined
            });
          
          case 'get_code_context':
            //  Expand context around a specific line
            if (!generatedHTML || generatedHTML.trim() === '') {
              return JSON.stringify({ 
                success: false, 
                message: 'No HTML currently in preview.',
                context: null
              });
            }
            
            if (!toolInput.line_number) {
              return JSON.stringify({
                success: false,
                error: 'line_number parameter is required',
                hint: 'Provide the line number from a candidate returned by find_code_locations'
              });
            }
            
            const targetLine = toolInput.line_number;
            const contextType = toolInput.context_type || 'auto';
            const htmlLines2 = generatedHTML.split('\n');
            
            // Auto-detect what type of code this is
            let contextStart = targetLine - 1;
            let contextEnd = targetLine - 1;
            let detectedType = 'unknown';
            
            // Check if we're in a script block
            let inScript = false;
            let inStyle = false;
            for (let i = 0; i < targetLine; i++) {
              const line = htmlLines2[i];
              if (line.includes('<' + 'script')) inScript = true;
              if (line.includes('<' + '/script>')) inScript = false;
              if (line.includes('<' + 'style')) inStyle = true;
              if (line.includes('<' + '/style>')) inStyle = false;
            }
            
            if (inScript || contextType === 'function') {
              // Find the full function
              detectedType = 'function';
              
              // Go backwards to find function start
              for (let i = targetLine - 2; i >= 0; i--) {
                const line = htmlLines2[i];
                if (line.match(/function\s+\w+|(?:const|let|var)\s+\w+\s*=\s*(?:function|async|\([^)]*\)\s*=>)/)) {
                  contextStart = i;
                  break;
                }
                if (line.includes('<' + 'script')) {
                  contextStart = i + 1;
                  break;
                }
              }
              
              // Go forwards to find function end (matching braces)
              let braceCount = 0;
              let started = false;
              for (let i = contextStart; i < htmlLines2.length; i++) {
                const line = htmlLines2[i];
                const openBraces = (line.match(/{/g) || []).length;
                const closeBraces = (line.match(/}/g) || []).length;
                
                if (openBraces > 0) started = true;
                braceCount += openBraces - closeBraces;
                
                if (started && braceCount === 0 && closeBraces > 0) {
                  contextEnd = i;
                  break;
                }
                
                if (line.includes('<' + '/script>')) {
                  contextEnd = i - 1;
                  break;
                }
              }
            } else if (inStyle || contextType === 'style_block') {
              // Find the full CSS rule
              detectedType = 'css_rule';
              
              // Go backwards to find selector
              for (let i = targetLine - 2; i >= 0; i--) {
                const line = htmlLines2[i];
                if (line.match(/^\s*[.#]?[\w-]+.*{/)) {
                  contextStart = i;
                  break;
                }
                if (line.includes('<' + 'style')) {
                  contextStart = i + 1;
                  break;
                }
              }
              
              // Go forwards to find rule end
              let braceCount = 0;
              for (let i = contextStart; i < htmlLines2.length; i++) {
                const line = htmlLines2[i];
                braceCount += (line.match(/{/g) || []).length;
                braceCount -= (line.match(/}/g) || []).length;
                
                if (braceCount === 0 && i > contextStart) {
                  contextEnd = i;
                  break;
                }
                
                if (line.includes('<' + '/style>')) {
                  contextEnd = i - 1;
                  break;
                }
              }
            } else {
              // HTML section - find the enclosing element
              detectedType = 'html_element';
              
              // Go backwards to find opening tag
              for (let i = targetLine - 2; i >= 0; i--) {
                const line = htmlLines2[i];
                if (line.match(/<(div|section|nav|header|footer|main|article|form)/)) {
                  contextStart = i;
                  break;
                }
              }
              
              // Go forwards to find closing tag (simplified - just take next 20 lines)
              contextEnd = Math.min(htmlLines2.length - 1, contextStart + 20);
            }
            
            // Add some padding
            const paddedStart = Math.max(0, contextStart - 2);
            const paddedEnd = Math.min(htmlLines2.length - 1, contextEnd + 2);
            
            const contextLines3 = htmlLines2.slice(paddedStart, paddedEnd + 1);
            const formattedContext = contextLines3
              .map((line, i) => {
                const lineNum = paddedStart + i + 1;
                const marker = lineNum === targetLine ? ' ' : '  ';
                return `${marker}${lineNum.toString().padStart(5, ' ')} | ${line}`;
              })
              .join('\n');
            
            return JSON.stringify({
              success: true,
              line_number: targetLine,
              detected_type: detectedType,
              context_range: `${paddedStart + 1}-${paddedEnd + 1}`,
              total_lines: contextLines3.length,
              context: formattedContext,
              hint: 'Use update_html with exact text from this context to make changes.'
            });
          
          case 'search_html':
            //  Search HTML for specific content and return snippets with line numbers
            if (!generatedHTML || generatedHTML.trim() === '') {
              return JSON.stringify({ 
                success: false, 
                message: 'No HTML currently in preview. Generate a page first using generate_html.',
                matches: []
              });
            }
            
            if (!toolInput.search_term) {
              return JSON.stringify({
                success: false,
                error: 'search_term parameter is required',
                hint: 'Provide the text you want to search for in the HTML'
              });
            }
            
            const searchTerm = toolInput.search_term;
            const contextLines = toolInput.context_lines || 3;
            const htmlLines = generatedHTML.split('\n');
            const matches = [];
            
            htmlLines.forEach((line, index) => {
              if (line.includes(searchTerm)) {
                const lineNum = index + 1; // 1-indexed
                const startContext = Math.max(0, index - contextLines);
                const endContext = Math.min(htmlLines.length - 1, index + contextLines);
                
                const snippet = htmlLines.slice(startContext, endContext + 1)
                  .map((l, i) => {
                    const actualLineNum = startContext + i + 1;
                    const prefix = actualLineNum === lineNum ? ' ' : '  ';
                    return `${prefix}${actualLineNum.toString().padStart(5, ' ')} | ${l}`;
                  })
                  .join('\n');
                
                matches.push({
                  line_number: lineNum,
                  snippet: snippet,
                  matched_text: line.trim()
                });
              }
            });
            
            return JSON.stringify({
              success: true,
              search_term: searchTerm,
              total_matches: matches.length,
              matches: matches,
              total_lines: htmlLines.length,
              hint: matches.length > 0 
                ? 'Use get_html_section with line numbers to retrieve the full section you want to modify'
                : 'No matches found. Try a different search term or check the spelling.'
            });
          
          case 'get_html_section':
            //  Get a specific section of HTML by line range or markers
            if (!generatedHTML || generatedHTML.trim() === '') {
              return JSON.stringify({ 
                success: false, 
                message: 'No HTML currently in preview.',
                section_content: null
              });
            }
            
            const htmlLines3 = generatedHTML.split('\n');
            let startIdx = 0;
            let endIdx = htmlLines3.length - 1;
            
            // Use line numbers if provided
            if (toolInput.start_line && toolInput.end_line) {
              startIdx = Math.max(0, toolInput.start_line - 1); // Convert to 0-indexed
              endIdx = Math.min(htmlLines3.length - 1, toolInput.end_line - 1);
            }
            // Use markers if provided
            else if (toolInput.start_marker || toolInput.end_marker) {
              if (toolInput.start_marker) {
                const foundStart = htmlLines3.findIndex(line => line.includes(toolInput.start_marker));
                if (foundStart !== -1) startIdx = foundStart;
              }
              if (toolInput.end_marker) {
                const foundEnd = htmlLines3.findIndex(line => line.includes(toolInput.end_marker));
                if (foundEnd !== -1) endIdx = foundEnd;
              }
            }
            
            // Add context if requested
            if (toolInput.include_context) {
              startIdx = Math.max(0, startIdx - 5);
              endIdx = Math.min(htmlLines3.length - 1, endIdx + 5);
            }
            
            const sectionLines = htmlLines3.slice(startIdx, endIdx + 1);
            const sectionWithLineNumbers = sectionLines
              .map((line, i) => `${(startIdx + i + 1).toString().padStart(5, ' ')} | ${line}`)
              .join('\n');
            
            return JSON.stringify({
              success: true,
              start_line: startIdx + 1,
              end_line: endIdx + 1,
              total_lines: sectionLines.length,
              section_content: sectionLines.join('\n'),
              section_with_line_numbers: sectionWithLineNumbers,
              hint: 'Use update_html with exact text from section_content to make changes'
            });
          
          case 'get_current_html':
            //  Return the FULL HTML from the preview (use sparingly)
            if (!generatedHTML || generatedHTML.trim() === '') {
              return JSON.stringify({ 
                success: false, 
                message: 'No HTML currently in preview. You should generate a new page from scratch using generate_html with a complete HTML document.',
                html_content: null
              });
            }
            
            const currentHTMLResult = { 
              success: true, 
              message: ' Full HTML retrieved (' + (generatedHTML.length / 1024).toFixed(1) + ' KB). For better performance, use search_html + get_html_section for targeted edits.',
              html_content: generatedHTML,
              size_kb: (generatedHTML.length / 1024).toFixed(2),
              total_lines: generatedHTML.split('\n').length,
              instructions: 'To update: 1) Modify the html_content above, 2) Call generate_html with {html_content: "modified HTML here", project_name: "name"}'
            };
            
            return JSON.stringify(currentHTMLResult);
          
          case 'update_html':
            //  FAST incremental HTML updates using search/replace
            
            if (!toolInput.edits || !Array.isArray(toolInput.edits) || toolInput.edits.length === 0) {
              return JSON.stringify({
                success: false,
                error: 'edits parameter is required and must be a non-empty array',
                hint: 'Provide an array of edits using LINE-BASED format: [{start_line: 100, end_line: 105, new_string: "replacement code", description: "what changed"}]. Use find_code_locations or get_html_section first to get the exact line numbers.'
              });
            }
            
            if (!generatedHTML || generatedHTML.trim() === '') {
              return JSON.stringify({
                success: false,
                error: 'No existing HTML to update. Use generate_html to create a new page first.',
                hint: 'update_html is for incremental changes to existing HTML. For new pages, use generate_html.'
              });
            }
            
            // Save current HTML as previous version
            previousWorkingHTML = generatedHTML;
            
            let modifiedHTML = generatedHTML;
            const appliedEdits = [];
            const failedEdits = [];
            
            //  CAPTURE PRE-EXISTING CSS ERRORS before applying any edits
            // This allows us to only report NEW errors introduced by the current edits
            const preExistingCSSValidation = validateCSS(generatedHTML);
            const preExistingCSSErrors = preExistingCSSValidation.errors || [];
            const preExistingHTMLValidation = validateHTML(generatedHTML);
            const preExistingHTMLErrors = preExistingHTMLValidation.errors || [];
            
            // Sort line-based edits by line number (ascending) to process top-to-bottom
            // This allows us to track line offset correctly
            const editsWithIndex = toolInput.edits.map((edit, idx) => ({ ...edit, originalIndex: idx }));
            const sortedEdits = [...editsWithIndex].sort((a, b) => {
              const aIsLine = a.start_line !== undefined;
              const bIsLine = b.start_line !== undefined;
              if (aIsLine && bIsLine) return a.start_line - b.start_line;
              if (aIsLine) return -1; // Line-based edits first
              if (bIsLine) return 1;
              return 0; // Keep original order for string-based
            });
            
            const lineBasedCount = sortedEdits.filter(e => e.start_line !== undefined).length;
            const stringBasedCount = sortedEdits.filter(e => e.old_string !== undefined).length;
            console.log(` Processing ${toolInput.edits.length} edits: ${lineBasedCount} line-based, ${stringBasedCount} string-based`);
            
            // Check for overlapping line-based edits (which can cause issues)
            const lineBasedEdits = sortedEdits.filter(e => e.start_line !== undefined);
            const overlappingEdits = [];
            for (let i = 0; i < lineBasedEdits.length - 1; i++) {
              const current = lineBasedEdits[i];
              const next = lineBasedEdits[i + 1];
              if (current.end_line >= next.start_line) {
                overlappingEdits.push({
                  edit1: current.originalIndex + 1,
                  edit1_range: `${current.start_line}-${current.end_line}`,
                  edit2: next.originalIndex + 1,
                  edit2_range: `${next.start_line}-${next.end_line}`
                });
              }
            }
            
            // REJECT overlapping edits - they cause CSS corruption and other issues
            if (overlappingEdits.length > 0) {
              return JSON.stringify({
                success: false,
                error: 'OVERLAPPING EDITS DETECTED - these would corrupt the code!',
                overlapping_edits: overlappingEdits,
                hint: 'Line ranges overlap: when Edit 1 modifies lines, Edit 2 tries to modify the same or adjacent lines. FIX: Combine overlapping edits into a single edit, OR use non-overlapping line ranges. For example, if you need to edit lines 100-120 and 110-130, combine them into one edit for lines 100-130.',
                recovery: 'Resubmit with non-overlapping line ranges or combine the overlapping edits into one.'
              });
            }
            
            if (lineBasedCount > 1) {
              console.log(` Line-based edits will be auto-adjusted for sequential changes`);
              // Log the order they'll be processed
              lineBasedEdits.forEach((e, i) => {
                console.log(`   ${i + 1}. Lines ${e.start_line}-${e.end_line} (original edit #${e.originalIndex + 1})`);
              });
            }
            
            // Track cumulative line offset for adjusting subsequent edits
            let lineOffset = 0;
            
            // Apply each edit sequentially
            for (let i = 0; i < sortedEdits.length; i++) {
              const edit = sortedEdits[i];
              const originalEditNumber = edit.originalIndex + 1;
              
              // Determine edit mode: LINE-BASED or STRING-BASED
              const isLineBased = edit.start_line !== undefined && edit.end_line !== undefined;
              const isStringBased = edit.old_string !== undefined;
              
              if (!isLineBased && !isStringBased) {
                failedEdits.push({
                  edit_number: originalEditNumber,
                  description: edit.description,
                  error: 'Missing required parameters. Use LINE-BASED mode: provide start_line + end_line + new_string',
                  hint: 'Call find_code_locations or get_html_section first to get line numbers, then use {start_line, end_line, new_string}.'
                });
                continue;
              }
              
              // Validate new_string exists and is not undefined/null
              if (edit.new_string === undefined || edit.new_string === null) {
                failedEdits.push({
                  edit_number: originalEditNumber,
                  description: edit.description,
                  error: 'new_string is required but was undefined or null. The AI response may have been truncated.',
                  hint: 'This usually happens when the AI response gets cut off. Try the request again.'
                });
                continue;
              }
              
              // Warn if new_string is empty (deleting content)
              if (edit.new_string === '') {
                console.warn(` Edit #${originalEditNumber}: new_string is empty - this will DELETE the matched content!`);
              }
              
              //  PRE-VALIDATE CSS CONTENT in new_string
              // Check for common CSS issues BEFORE applying the edit
              const newStr = edit.new_string;
              
              // Check for JavaScript template literals ${...} in HTML (common AI mistake)
              // Template literals don't work in plain HTML - they only work in JavaScript template strings
              const templateLiteralInHTML = newStr.match(/\$\{[^}]+\}/g);
              if (templateLiteralInHTML && templateLiteralInHTML.length > 0) {
                // Check if it's inside a style attribute (most problematic)
                const templateInStyle = newStr.match(/style\s*=\s*"[^"]*\$\{[^}]+\}[^"]*"/gi);
                if (templateInStyle && templateInStyle.length > 0) {
                  failedEdits.push({
                    edit_number: originalEditNumber,
                    description: edit.description,
                    error: `TEMPLATE LITERAL IN INLINE STYLE: Found ${templateInStyle[0].substring(0, 60)}...`,
                    hint: 'Template literals like ${variable} do NOT work in plain HTML! Use JavaScript string concatenation: \'style="color: \' + variable + \'"\' or set style via JS: element.style.color = variable',
                    fix_required: 'Replace ${...} with JavaScript string concatenation or use element.style.property = value'
                  });
                  continue;
                }
                // Template literal in other HTML attributes
                failedEdits.push({
                  edit_number: originalEditNumber,
                  description: edit.description,
                  error: `TEMPLATE LITERAL SYNTAX IN HTML: Found ${templateLiteralInHTML.slice(0, 3).join(', ')}${templateLiteralInHTML.length > 3 ? '...' : ''}`,
                  hint: 'Template literals ${...} only work in JavaScript backtick strings, NOT in plain HTML! Use string concatenation: \'<div>\' + variable + \'</div>\'',
                  fix_required: 'Replace ${variable} with JavaScript string concatenation using + operator'
                });
                continue;
              }
              
              // Check for inline style with curly braces (common AI mistake)
              const inlineStyleWithBraces = newStr.match(/style\s*=\s*"[^"]*[{}][^"]*"/gi);
              if (inlineStyleWithBraces && inlineStyleWithBraces.length > 0) {
                failedEdits.push({
                  edit_number: originalEditNumber,
                  description: edit.description,
                  error: `CSS SYNTAX ERROR: Inline style contains curly braces. Found: ${inlineStyleWithBraces[0].substring(0, 60)}...`,
                  hint: 'Inline styles must NOT have curly braces or selectors. WRONG: style=".btn { color: red; }"  RIGHT: style="color: red;"',
                  fix_required: 'Remove { } and any CSS selectors from inline style attributes'
                });
                continue;
              }
              
              // Check if new_string contains CSS (has style tag or CSS-like patterns)

    /* ===== STOP BUTTON ENHANCEMENTS ===== */
    #stopGenerationBtn {
      display: none;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: #EF4444;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 150ms;
      margin-left: 8px;
      box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
      animation: pulse-stop 2s ease-in-out infinite;
      position: relative;
    }
    
    #stopGenerationBtn:hover {
      background: #DC2626;
      box-shadow: 0 4px 8px rgba(239, 68, 68, 0.4);
      transform: translateY(-1px);
    }
    
    #stopGenerationBtn:active {
      transform: translateY(0);
    }
    
    @keyframes pulse-stop {
      0%, 100% {
        box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
      }
      50% {
        box-shadow: 0 4px 12px rgba(239, 68, 68, 0.6);
      }
    }
    
    #stopGenerationBtn i {
      width: 16px;
      height: 16px;
    }
              const hasStyleTag = newStr.includes('<style') || newStr.includes('</style>');
              const hasCSSPatterns = /[.#]?[a-z][a-z0-9_-]*\s*\{[^}]*\}/i.test(newStr);
              
              if (hasStyleTag || hasCSSPatterns) {
                // Extract just the CSS-like content for brace checking
                let cssContent = newStr;
                // If it has style tags, extract content between them
                const styleMatch = newStr.match(/<style[^>]*>([\s\S]*?)<\/style>/gi);
                if (styleMatch) {
                  cssContent = styleMatch.map(m => m.replace(/<style[^>]*>/i, '').replace(/<\/style>/i, '')).join('\n');
                }
                
                // Count braces in the CSS content
                const openBraces = (cssContent.match(/{/g) || []).length;
                const closeBraces = (cssContent.match(/}/g) || []).length;
                
                if (openBraces !== closeBraces) {
                  const diff = openBraces - closeBraces;
                  failedEdits.push({
                    edit_number: originalEditNumber,
                    description: edit.description,
                    error: `CSS BRACE MISMATCH in new_string: ${openBraces} opening '{' vs ${closeBraces} closing '}' (${diff > 0 ? 'missing ' + diff + ' closing' : 'extra ' + Math.abs(diff) + ' closing'} brace(s))`,
                    hint: 'Your replacement CSS has unbalanced braces. Count your { and } to ensure they match.',
                    new_string_preview: newStr.substring(0, 200) + (newStr.length > 200 ? '...' : ''),
                    fix_required: diff > 0 ? `Add ${diff} closing '}' brace(s)` : `Remove ${Math.abs(diff)} extra '}' brace(s)`
                  });
                  continue;
                }
              }
              
              // ===== LINE-BASED EDITING =====
              if (isLineBased) {
                const lines = modifiedHTML.split('\n');
                
                // Adjust line numbers based on previous edits
                const adjustedStartLine = edit.start_line + lineOffset;
                const adjustedEndLine = edit.end_line + lineOffset;
                const startIdx = adjustedStartLine - 1; // Convert to 0-indexed
                const endIdx = adjustedEndLine - 1;
                
                console.log(`\n LINE-BASED EDIT #${originalEditNumber}:`);
                console.log(`   Original range: lines ${edit.start_line}-${edit.end_line}`);
                console.log(`   Current offset: ${lineOffset >= 0 ? '+' : ''}${lineOffset}`);
                console.log(`   Adjusted range: lines ${adjustedStartLine}-${adjustedEndLine} (0-indexed: ${startIdx}-${endIdx})`);
                console.log(`   File has ${lines.length} lines`);
                
                // Validation
                if (startIdx < 0 || endIdx >= lines.length || startIdx > endIdx) {
                  console.error(`    INVALID RANGE! startIdx=${startIdx}, endIdx=${endIdx}, lines.length=${lines.length}`);
                  failedEdits.push({
                    edit_number: originalEditNumber,
                    description: edit.description,
                    error: `Invalid line range: start_line=${edit.start_line}, end_line=${edit.end_line} (adjusted to ${adjustedStartLine}-${adjustedEndLine} after offset ${lineOffset}). File has ${lines.length} lines.`,
                    hint: 'Check line numbers from get_html_section or find_code_locations results. Note: Line numbers are auto-adjusted for sequential edits.'
                  });
                  continue;
                }
                
                // Extract old content for logging
                const oldLines = lines.slice(startIdx, endIdx + 1);
                const oldContent = oldLines.join('\n');
                
                // Log what we're replacing
                console.log(`   Replacing ${oldLines.length} lines:`);
                console.log(`   FIRST LINE BEING REPLACED (line ${adjustedStartLine}): "${lines[startIdx].substring(0, 80)}${lines[startIdx].length > 80 ? '...' : ''}"`);
                console.log(`   LAST LINE BEING REPLACED (line ${adjustedEndLine}): "${lines[endIdx].substring(0, 80)}${lines[endIdx].length > 80 ? '...' : ''}"`);
                
                // Replace the lines
                const newLines = edit.new_string.split('\n');
                const oldLineCount = endIdx - startIdx + 1;
                const newLineCount = newLines.length;
                
                console.log(`   New content has ${newLineCount} lines (delta: ${newLineCount - oldLineCount >= 0 ? '+' : ''}${newLineCount - oldLineCount})`);
                
                lines.splice(startIdx, oldLineCount, ...newLines);
                modifiedHTML = lines.join('\n');
                
                // Update line offset for subsequent edits
                const lineDelta = newLineCount - oldLineCount;
                lineOffset += lineDelta;
                
                appliedEdits.push({
                  edit_number: originalEditNumber,
                  description: edit.description,
                  mode: 'LINE-BASED',
                  original_lines: `${edit.start_line}-${edit.end_line}`,
                  adjusted_lines: `${adjustedStartLine}-${adjustedEndLine}`,
                  old_line_count: oldLineCount,
                  new_line_count: newLineCount,
                  line_delta: lineDelta,
                  cumulative_offset: lineOffset,
                  replaced_content_preview: oldContent.substring(0, 300) + (oldContent.length > 300 ? '...[truncated]' : ''),
                  new_content_preview: edit.new_string.substring(0, 300) + (edit.new_string.length > 300 ? '...[truncated]' : ''),
                  verification: {
                    before: oldContent.substring(0, 150),
                    after: edit.new_string.substring(0, 150)
                  }
                });
                continue;
              }
              
              // ===== STRING-BASED EDITING =====
              // Check if old_string exists in current HTML
              const occurrences = modifiedHTML.split(edit.old_string).length - 1;
              
              if (occurrences === 0) {
                // Try to find similar text to help debug
                const searchSnippet = edit.old_string.substring(0, 50);
                const lines = modifiedHTML.split('\n');
                let nearestMatch = null;
                let bestMatchScore = 0;
                
                // Look for lines that contain some of the keywords
                for (let lineIdx = 0; lineIdx < lines.length; lineIdx++) {
                  const line = lines[lineIdx];
                  const keywords = searchSnippet.split(/\s+/).filter(w => w.length > 3);
                  let matchScore = 0;
                  keywords.forEach(kw => {
                    if (line.includes(kw)) matchScore++;
                  });
                  if (matchScore > bestMatchScore) {
                    bestMatchScore = matchScore;
                    nearestMatch = {
                      line_number: lineIdx + 1,
                      content: line.trim().substring(0, 100)
                    };
                  }
                }
                
                //  WHITESPACE DETECTION: Check if text matches but whitespace differs
                const normalizedOldString = edit.old_string.replace(/\s+/g, ' ').trim();
                const normalizedHTML = modifiedHTML.replace(/\s+/g, ' ').trim();
                const hasWhitespaceIssue = normalizedHTML.includes(normalizedOldString);
                
                const hintMessage = hasWhitespaceIssue
                  ? ` WHITESPACE MISMATCH detected at line ${nearestMatch?.line_number || '?'}. SWITCH TO LINE-BASED MODE: Call get_html_section(${nearestMatch?.line_number || '?'}, ${(nearestMatch?.line_number || 0) + 10}) to get line numbers, then use {start_line, end_line, new_string} format instead.`
                  : nearestMatch 
                    ? `Found similar text at line ${nearestMatch.line_number}. SWITCH TO LINE-BASED MODE: Call get_html_section to get the line numbers, then use {start_line, end_line, new_string} format.`
                    : 'The text may not exist. Call find_code_locations to locate the right section, then use LINE-BASED mode with {start_line, end_line, new_string}.';
                
                failedEdits.push({
                  edit_number: originalEditNumber,
                  description: edit.description,
                  error: hasWhitespaceIssue ? 'String-based edit failed: whitespace mismatch. Use LINE-BASED mode instead.' : 'String-based edit failed: text not found. Use LINE-BASED mode instead.',
                  searched_for: edit.old_string.substring(0, 100) + (edit.old_string.length > 100 ? '...' : ''),
                  nearest_match: nearestMatch,
                  whitespace_issue: hasWhitespaceIssue,
                  hint: hintMessage,
                  recommended_action: 'Switch to LINE-BASED mode: use {start_line, end_line, new_string} format'
                });
                continue;
              }
              
              // Apply the replacement
              const beforeSnippet = modifiedHTML.substring(
                Math.max(0, modifiedHTML.indexOf(edit.old_string) - 50),
                modifiedHTML.indexOf(edit.old_string) + edit.old_string.length + 50
              );
              
              modifiedHTML = modifiedHTML.replace(edit.old_string, edit.new_string);
              
              const afterSnippet = modifiedHTML.substring(
                Math.max(0, modifiedHTML.indexOf(edit.new_string) - 50),
                modifiedHTML.indexOf(edit.new_string) + edit.new_string.length + 50
              );
              
              appliedEdits.push({
                edit_number: originalEditNumber,
                description: edit.description,
                mode: 'STRING-BASED',
                occurrences: occurrences,
                verification: {
                  before: beforeSnippet.substring(0, 150),
                  after: afterSnippet.substring(0, 150)
                }
              });
            }
            
            // Update the preview with modified HTML
            generatedHTML = modifiedHTML;
            
            // Validate the modified HTML
            const updateValidation = validateHTML(modifiedHTML);
            
            // Filter to only NEW errors (not pre-existing ones)
            const newHTMLErrors = (updateValidation.errors || []).filter(err => !preExistingHTMLErrors.includes(err));
            
            // Check if validation failed with NEW errors and warn user
            if (newHTMLErrors.length > 0) {
              console.error(' HTML VALIDATION FAILED after update_html (NEW errors):');
              newHTMLErrors.forEach((err, i) => {
                console.error(`   ${i + 1}. ${err}`);
              });
              
              // Add warning to chat - user can undo if needed
              setTimeout(() => {
                addMessageToChat('system error', 
                  ` Warning: The HTML may have syntax issues after this edit:\n${newHTMLErrors.join('\n')}\n\nClick "Undo" if the preview looks broken.`
                );
              }, 200);
            }
            
            //  CSS VALIDATION - Check for CSS syntax issues after update
            const cssValidation = validateCSS(modifiedHTML);
            
            // Filter to only NEW CSS errors (not pre-existing ones)
            const newCSSErrors = (cssValidation.errors || []).filter(err => !preExistingCSSErrors.includes(err));
            
            if (newCSSErrors.length > 0) {
              console.error(' CSS VALIDATION ISSUES after update_html (NEW errors):');
              newCSSErrors.forEach((err, i) => {
                console.error(`   ${i + 1}. ${err}`);
              });
              
              // Add CSS warning to chat
              setTimeout(() => {
                addMessageToChat('system error', 
                  ` CSS Issues Detected:\n${newCSSErrors.join('\n')}\n\nThese may cause styling problems.`
                );
              }, 250);
            }
            
            // Log pre-existing issues separately (for debugging, not shown to user as errors from this edit)
            if (preExistingCSSErrors.length > 0) {
              console.warn(' Pre-existing CSS issues (not caused by this edit):');
              preExistingCSSErrors.forEach((err, i) => {
                console.warn(`   ${i + 1}. ${err}`);
              });
            }
            
            if (cssValidation.warnings && cssValidation.warnings.length > 0) {
              console.warn(' CSS WARNINGS after update_html:');
              cssValidation.warnings.forEach((warn, i) => {
                console.warn(`   ${i + 1}. ${warn}`);
              });
            }
            
            // Update preview iframe
            const previewFrame = document.getElementById('previewFrame');
            const loadingIndicator = document.getElementById('previewLoading');
            
            loadingIndicator.classList.remove('hidden');
            previewFrame.classList.remove('loaded');
            
            setTimeout(() => {
              // Inject API configuration into the HTML (same as generate_html)
              const projectIdValue = currentProjectId ? "'" + currentProjectId + "'" : 'null';
              const apiConfigScript = '<' + 'script>\n' +
                '  // AUTO-INJECTED API HELPERS - Use these functions to interact with your database\n' +
                '  window.API_CONFIG = {\n' +
                '    API_BASE: \'dev-url\',\n' +
                '    PROJECT_ID: ' + projectIdValue + '\n' +
                '  };\n' +
                '  \n' +
                '  // Auto-discover PROJECT_ID from existing tables\n' +
                '  window.discoverProjectId = async function() {\n' +
                '    if (window.API_CONFIG.PROJECT_ID) {\n' +
                '      return window.API_CONFIG.PROJECT_ID;\n' +
                '    } else {\n' +
                '      // Need to discover it - query the database for existing tables\n' +
                '      try {\n' +
                '        console.log(\' Auto-discovering PROJECT_ID from database tables...\');\n' +
                '        const response = await fetch(window.API_CONFIG.API_BASE + \'/api/tables\');\n' +
                '        const data = await response.json();\n' +
                '        if (data.success && data.tables && data.tables.length > 0) {\n' +
                '          const firstTable = data.tables[0].name;\n' +
                '          const match = firstTable.match(/^(prj_\\\\d+_[a-z0-9]+)_/);\n' +
                '          if (match) {\n' +
                '            window.API_CONFIG.PROJECT_ID = match[1];\n' +
                '            console.log(\' Auto-discovered PROJECT_ID:\', window.API_CONFIG.PROJECT_ID);\n' +
                '            return window.API_CONFIG.PROJECT_ID;\n' +
                '          }\n' +
                '        }\n' +
                '      } catch (err) {\n' +
                '        console.error(\' Failed to discover PROJECT_ID:\', err);\n' +
                '      }\n' +
                '      return null;\n' +
                '    }\n' +
                '  };\n' +
                '  \n' +
                '  // Save data to your table (non-blocking - returns immediately)\n' +
                '  // BATCH SUPPORT: Pass array of objects to insert multiple records in one call\n' +
                '  // Example: saveToProjectTable("users", [{id:"1",name:"John"}, {id:"2",name:"Jane"}])\n' +
                '  window.saveToProjectTable = async function(tableName, data) {\n' +
                '    if (!window.API_CONFIG.PROJECT_ID) await window.discoverProjectId();\n' +
                '    const fullTableName = window.API_CONFIG.PROJECT_ID ? window.API_CONFIG.PROJECT_ID + \'_\' + tableName : tableName;\n' +
                '    // Start save in background with 120 second timeout\n' +
                '    const controller = new AbortController();\n' +
                '    const timeoutId = setTimeout(() => controller.abort(), 120000);\n' +
                '    const savePromise = fetch(window.API_CONFIG.API_BASE + \'/api/table/insert\', {\n' +
                '      method: \'POST\',\n' +
                '      headers: { \'Content-Type\': \'application/json\' },\n' +
                '      body: JSON.stringify({ table_name: fullTableName, data: data }),\n' +
                '      signal: controller.signal\n' +
                '    }).then(r => r.json()).catch(err => {\n' +
                '      clearTimeout(timeoutId);\n' +
                '      console.error(\'Background save failed:\', err);\n' +
                '      return { success: false, error: err.message };\n' +
                '    }).finally(() => clearTimeout(timeoutId));\n' +
                '    return { success: true, note: \'Save started in background\' };\n' +
                '  };\n' +
                '  \n' +
                '  // Update data in your table (non-blocking - returns immediately)\n' +
                '  // BATCH SUPPORT: Pass array with {data, where_clause} objects for multiple updates\n' +
                '  // Single: updateProjectTable("users", {status:"active"}, "id=\'1\'")\n' +
                '  // Batch: updateProjectTable("users", [{data:{status:"active"},where_clause:"id=\'1\'"}, {data:{status:"inactive"},where_clause:"id=\'2\'"}])\n' +
                '  window.updateProjectTable = async function(tableName, data, whereClause) {\n' +
                '    await window.discoverProjectId();\n' +
                '    const fullTableName = window.API_CONFIG.PROJECT_ID ? window.API_CONFIG.PROJECT_ID + \'_\' + tableName : tableName;\n' +
                '    // Detect batch mode: if data is array with {data, where_clause} structure\n' +
                '    const isBatch = Array.isArray(data) && data.length > 0 && data[0].data !== undefined;\n' +
                '    const payload = isBatch \n' +
                '      ? { table_name: fullTableName, updates: data }\n' +
                '      : { table_name: fullTableName, data: data, where_clause: whereClause };\n' +
                '    // Start update in background with 120 second timeout\n' +
                '    const controller = new AbortController();\n' +
                '    const timeoutId = setTimeout(() => controller.abort(), 120000);\n' +
                '    const updatePromise = fetch(window.API_CONFIG.API_BASE + \'/api/table/update\', {\n' +
                '      method: \'POST\',\n' +
                '      headers: { \'Content-Type\': \'application/json\' },\n' +
                '      body: JSON.stringify(payload),\n' +
                '      signal: controller.signal\n' +
                '    }).then(r => r.json()).catch(err => {\n' +
                '      clearTimeout(timeoutId);\n' +
                '      console.error(\'Background update failed:\', err);\n' +
                '      return { success: false, error: err.message };\n' +
                '    }).finally(() => clearTimeout(timeoutId));\n' +
                '    return { success: true, note: isBatch ? `Batch update of ${data.length} records started` : \'Update started in background\' };\n' +
                '  };\n' +
                '  \n' +
                '  // Delete data from your table (non-blocking - returns immediately)\n' +
                '  // BATCH SUPPORT: Pass array of WHERE clauses OR use IN clause for multiple deletes\n' +
                '  // Single: deleteFromProjectTable("users", "id=\'1\'")\n' +
                '  // Batch: deleteFromProjectTable("users", ["id=\'1\'", "id=\'2\'", "id=\'3\'"])\n' +
                '  // Best: deleteFromProjectTable("users", "id IN (\'1\', \'2\', \'3\')")\n' +
                '  window.deleteFromProjectTable = async function(tableName, whereClause) {\n' +
                '    await window.discoverProjectId();\n' +
                '    const fullTableName = window.API_CONFIG.PROJECT_ID ? window.API_CONFIG.PROJECT_ID + \'_\' + tableName : tableName;\n' +
                '    // Detect batch mode: if whereClause is an array\n' +
                '    const isBatch = Array.isArray(whereClause);\n' +
                '    const payload = isBatch\n' +
                '      ? { table_name: fullTableName, where_clauses: whereClause }\n' +
                '      : { table_name: fullTableName, where_clause: whereClause };\n' +
                '    // Start delete in background with 120 second timeout\n' +
                '    const controller = new AbortController();\n' +
                '    const timeoutId = setTimeout(() => controller.abort(), 120000);\n' +
                '    const deletePromise = fetch(window.API_CONFIG.API_BASE + \'/api/table/delete\', {\n' +
                '      method: \'POST\',\n' +
                '      headers: { \'Content-Type\': \'application/json\' },\n' +
                '      body: JSON.stringify(payload),\n' +
                '      signal: controller.signal\n' +
                '    }).then(r => r.json()).catch(err => {\n' +
                '      clearTimeout(timeoutId);\n' +
                '      console.error(\'Background delete failed:\', err);\n' +
                '      return { success: false, error: err.message };\n' +
                '    }).finally(() => clearTimeout(timeoutId));\n' +
                '    return { success: true, note: isBatch ? `Batch delete of ${whereClause.length} conditions started` : \'Delete started in background\' };\n' +
                '  };\n' +
                '  \n' +
                '  // Query data from your table (blocking - waits for results)\n' +
                '  window.queryProjectTable = async function(tableName, whereClause = null, limit = 100) {\n' +
                '    // Input validation\n' +
                '    if (!tableName || typeof tableName !== \'string\' || tableName.trim() === \'\') {\n' +
                '      console.error(\'queryProjectTable: tableName is required and must be a non-empty string\');\n' +
                '      return { success: false, error: \'tableName is required\', data: [], count: 0 };\n' +
                '    }\n' +
                '    \n' +
                '    if (!window.API_CONFIG.PROJECT_ID) await window.discoverProjectId();\n' +
                '    const fullTableName = window.API_CONFIG.PROJECT_ID ? window.API_CONFIG.PROJECT_ID + \'_\' + tableName : tableName;\n' +
                '    \n' +
                '    // Smart parsing: separate WHERE clause from ORDER BY\n' +
                '    let actualWhereClause = whereClause;\n' +
                '    let orderBy = null;\n' +
                '    if (whereClause && typeof whereClause === \'string\') {\n' +
                '      const orderByMatch = whereClause.match(/ORDER\\s+BY\\s+(.+?)$/i);\n' +
                '      if (orderByMatch) {\n' +
                '        orderBy = orderByMatch[1].trim();\n' +
                '        actualWhereClause = whereClause.substring(0, orderByMatch.index).trim() || null;\n' +
                '      }\n' +
                '    }\n' +
                '    \n' +
                '    try {\n' +
                '      const requestBody = { table_name: fullTableName, limit: limit };\n' +
                '      if (actualWhereClause) requestBody.where_clause = actualWhereClause;\n' +
                '      if (orderBy) requestBody.order_by = orderBy;\n' +
                '      \n' +
                '      // Add 120 second timeout for query operations\n' +
                '      const controller = new AbortController();\n' +
                '      const timeoutId = setTimeout(() => controller.abort(), 120000);\n' +
                '      \n' +
                '      const response = await fetch(window.API_CONFIG.API_BASE + \'/api/table/query\', {\n' +
                '        method: \'POST\',\n' +
                '        headers: { \'Content-Type\': \'application/json\' },\n' +
                '        body: JSON.stringify(requestBody),\n' +
                '        signal: controller.signal\n' +
                '      });\n' +
                '      \n' +
                '      clearTimeout(timeoutId);\n' +
                '      \n' +
                '      if (!response.ok) {\n' +
                '        const errorText = await response.text();\n' +
                '        console.error(\'Query API error:\', response.status, errorText);\n' +
                '        return { success: false, error: \'API error: \' + response.status, data: [], count: 0 };\n' +
                '      }\n' +
                '      \n' +
                '      const result = await response.json();\n' +
                '      return result || { success: false, error: \'Empty response\', data: [], count: 0 };\n' +
                '    } catch (err) {\n' +
                '      console.error(\'Query failed:\', err);\n' +
                '      return { success: false, error: err.message || \'Unknown error\', data: [], count: 0 };\n' +
                '    }\n' +
                '  };\n' +
                '  \n' +
                '  // CONSOLE LOG CAPTURE - Send console messages to parent window\n' +
                '  (function() {\n' +
                '    const originalConsole = {\n' +
                '      log: console.log,\n' +
                '      error: console.error,\n' +
                '      warn: console.warn,\n' +
                '      info: console.info\n' +
                '    };\n' +
                '    \n' +
                '    function sendToParent(level, args) {\n' +
                '      try {\n' +
                '        // Serialize args safely for postMessage\n' +
                '        const serializedArgs = args.map(arg => {\n' +
                '          if (arg === null) return \'null\';\n' +
                '          if (arg === undefined) return \'undefined\';\n' +
                '          if (typeof arg === \'string\') return arg;\n' +
                '          if (typeof arg === \'number\') return String(arg);\n' +
                '          if (typeof arg === \'boolean\') return String(arg);\n' +
                '          if (arg instanceof Error) return arg.message + \'\\n\' + (arg.stack || \'\');\n' +
                '          if (typeof arg === \'object\') {\n' +
                '            try {\n' +
                '              return JSON.stringify(arg, null, 2);\n' +
                '            } catch (e) {\n' +
                '              return \'[Object (circular or non-serializable)]\';\n' +
                '            }\n' +
                '          }\n' +
                '          return String(arg);\n' +
                '        });\n' +
                '        \n' +
                '        const message = serializedArgs.join(\' \');\n' +
                '        \n' +
                '        window.parent.postMessage({\n' +
                '          type: \'CONSOLE_LOG\',\n' +
                '          level: level,\n' +
                '          message: message,\n' +
                '          args: serializedArgs\n' +
                '        }, \'*\');\n' +
                '      } catch (e) {\n' +
                '        // Silently fail if parent messaging doesn\'t work\n' +
                '        originalConsole.error(\'Console capture failed:\', e);\n' +
                '      }\n' +
                '    }\n' +
                '    \n' +
                '    console.log = function(...args) {\n' +
                '      sendToParent(\'log\', args);\n' +
                '      originalConsole.log.apply(console, args);\n' +
                '    };\n' +
                '    \n' +
                '    console.error = function(...args) {\n' +
                '      sendToParent(\'error\', args);\n' +
                '      originalConsole.error.apply(console, args);\n' +
                '    };\n' +
                '    \n' +
                '    console.warn = function(...args) {\n' +
                '      sendToParent(\'warn\', args);\n' +
                '      originalConsole.warn.apply(console, args);\n' +
                '    };\n' +
                '    \n' +
                '    console.info = function(...args) {\n' +
                '      sendToParent(\'info\', args);\n' +
                '      originalConsole.info.apply(console, args);\n' +
                '    };\n' +
                '  })();\n' +
                '<' + '/script>';
              
              // Try to inject before </head>, if not found try other locations
              let htmlWithAPI = modifiedHTML;
              if (modifiedHTML.includes('</head>')) {
                htmlWithAPI = modifiedHTML.replace('</head>', apiConfigScript + '\n</head>');
              } else if (modifiedHTML.includes('<head>')) {
                htmlWithAPI = modifiedHTML.replace('<head>', '<head>' + apiConfigScript);
              } else if (modifiedHTML.includes('<html>')) {
                htmlWithAPI = modifiedHTML.replace('<html>', '<html>' + apiConfigScript);
              } else {
                // Fallback: prepend to the HTML
                htmlWithAPI = apiConfigScript + '\n' + modifiedHTML;
              }
              
              // Use srcdoc for more reliable inline HTML rendering (same as generate_html)
              previewFrame.srcdoc = wrapHTMLWithConsoleCapture(htmlWithAPI);
              
              // Add timeout to handle stuck loading
              const loadTimeout = setTimeout(() => {
                loadingIndicator.classList.add('hidden');
                previewFrame.classList.add('loaded');
              }, 5000); // 5 second timeout
              
              previewFrame.onload = () => {
                clearTimeout(loadTimeout);
                loadingIndicator.classList.add('hidden');
                previewFrame.classList.add('loaded');
              };
              
              previewFrame.onerror = () => {
                clearTimeout(loadTimeout);
                loadingIndicator.classList.add('hidden');
              };
            }, 100);
            
            // Update code view with the modified HTML
            updateCodeView(modifiedHTML);
            
            // Update version buttons after a short delay to ensure DOM is ready
            setTimeout(() => {
              updateChatVersionButtons();
            }, 150);
            
            // Save to version history
            const lastVersion = versionHistory[versionHistory.length - 1];
            const alreadySaved = lastVersion && lastVersion.html === modifiedHTML;
            
            if (!alreadySaved) {
              const userMessages = chatConversationHistory.filter(m => m.role === 'user');
              const messageForCurrentHTML = userMessages[versionHistory.length] || userMessages[userMessages.length - 1] || { content: 'Incremental Update' };
              const messageContent = typeof messageForCurrentHTML.content === 'string' 
                ? messageForCurrentHTML.content 
                : 'Incremental Update';
              
              console.log(' Saving version #' + (versionHistory.length + 1));
              console.log('   HTML size: ' + (modifiedHTML.length / 1024).toFixed(1) + ' KB');
              console.log('   Changes: ' + appliedEdits.length + ' edits applied');
              
              saveVersion(modifiedHTML, messageContent, '', false);
            }
            
            // Auto-save to BigQuery after update_html (creates new version entry)
            // This ensures every iteration is saved with a unique cache_id
            console.log(`\n === UPDATE_HTML AUTO-SAVE CHECK ===`);
            console.log(`   currentProjectId: ${currentProjectId || 'NOT SET'}`);
            console.log(`   appliedEdits.length: ${appliedEdits.length}`);
            console.log(`   allProjects count: ${allProjects?.length || 0}`);
            console.log(`   Condition result: ${!!(currentProjectId && appliedEdits.length > 0)}`);
            
            if (currentProjectId && appliedEdits.length > 0) {
              const projectNameForSave = allProjects.find(p => p.project_id === currentProjectId)?.project_name || 'App Builder Project';
              const uniqueCacheId = `${projectNameForSave.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}`;
              
              console.log(` === AUTO-SAVE AFTER UPDATE_HTML ===`);
              console.log(`   Project: ${projectNameForSave}`);
              console.log(`   Cache ID: ${uniqueCacheId}`);
              console.log(`   Applied edits: ${appliedEdits.length}`);
              console.log(`   Modified HTML size: ${(modifiedHTML.length / 1024).toFixed(2)} KB`);
              
              try {
                const versionBeforeIncrement = currentVersionNumber;
                currentVersionNumber++; // Increment before save
                console.log(`   Version: ${versionBeforeIncrement}  ${currentVersionNumber} (incremented for update_html save)`);
                console.log(`   Calling saveToBigQuery...`);
                await saveToBigQuery(projectNameForSave, modifiedHTML, uniqueCacheId, currentVersionNumber);
                console.log(` Update_html auto-save completed`);
                console.log(`   Saved to: ${currentProjectId}_html_cache`);
              } catch (saveError) {
                console.error(' Update_html auto-save failed:', saveError.message);
                console.error('   Full error:', saveError);
                currentVersionNumber--; // Revert version increment
              }
              console.log(`=================================\n`);
            } else {
              console.log(`  AUTO-SAVE SKIPPED - Reasons:`);
              if (!currentProjectId) {
                console.log('    No project selected (currentProjectId is null/undefined)');
              }
              if (appliedEdits.length === 0) {
                console.log('    No edits were applied (appliedEdits.length = 0)');
              }
              console.log(`=================================\n`);
            }
            
            console.log('\n === UPDATE_HTML COMPLETE ===');
            console.log(` Applied: ${appliedEdits.length} edits`);
            console.log(` Failed: ${failedEdits.length} edits`);
            console.log(` Final HTML size: ${(modifiedHTML.length / 1024).toFixed(2)} KB`);
            if (lineOffset !== 0) {
              console.log(` Final line offset: ${lineOffset > 0 ? '+' : ''}${lineOffset} lines (from sequential edits)`);
            }
            console.log('================================\n');
            
            // Enable undo button so user can revert if the edit broke something
            if (appliedEdits.length > 0 && previousWorkingHTML) {
              const undoBtn = document.getElementById('btnUndo');
              if (undoBtn) {
                undoBtn.disabled = false;
                undoBtn.title = 'Undo last edit (revert to previous version)';
              }
            }
            
            // Store edit details for diff viewer
            const editDetails = {
              appliedEdits: appliedEdits.map((edit) => {
                const originalEdit = toolInput.edits[edit.edit_number - 1];
                return {
                  ...edit,
                  old_string: originalEdit.old_string || `[Lines ${originalEdit.start_line}-${originalEdit.end_line}]`,
                  new_string: originalEdit.new_string,
                  start_line: originalEdit.start_line,
                  end_line: originalEdit.end_line
                };
              }),
              failedEdits: failedEdits
            };
            
            // Show diff viewer with edit details
            if (appliedEdits.length > 0) {
              showDiffViewer(editDetails);
            } else if (toolInput.edits.length > 0) {
              // ALL EDITS FAILED - Show prominent warning to user
              addMessageToChat('system error', ` CRITICAL: No changes were applied! All ${toolInput.edits.length} edit(s) failed. The edit targets didn't match the actual HTML. Use find_code_locations to get correct line numbers.`);
            }
            
            // CRITICAL: If NO edits were applied, this is a FAILURE not success!
            const allEditsFailed = appliedEdits.length === 0 && toolInput.edits.length > 0;
            
            // Include old content in response so AI can verify correct lines were edited
            const appliedDetails = appliedEdits.map(edit => ({
              edit_number: edit.edit_number,
              description: edit.description,
              mode: edit.mode,
              lines: edit.mode === 'LINE-BASED' ? edit.original_lines : undefined,
              replaced_content_preview: edit.verification?.before || '[string-based]',
              new_content_preview: edit.verification?.after || '[string-based]'
            }));
            
            //  POST-UPDATE CONSOLE ERROR CHECK
            // Wait for preview to render and check for any errors (including async data loading)
            await new Promise(resolve => setTimeout(resolve, 800)); // Initial wait for JS execution
            
            let postUpdateErrors = getConsoleLogs(false, 50).filter(l => l.level === 'error');
            
            // If no errors yet, wait a bit longer for async operations (API calls, data loading)
            if (postUpdateErrors.length === 0) {
              await new Promise(resolve => setTimeout(resolve, 1200)); // Wait for async operations
              postUpdateErrors = getConsoleLogs(false, 50).filter(l => l.level === 'error');
            }
            
            const hasNewErrors = postUpdateErrors.length > 0;
            
            if (hasNewErrors) {
              console.warn(` POST-UPDATE ERROR CHECK: Found ${postUpdateErrors.length} console error(s) after applying changes!`);
              postUpdateErrors.forEach((err, i) => {
                console.warn(`   ${i + 1}. ${err.message}`);
              });
            } else {
              console.log(' POST-UPDATE ERROR CHECK: No console errors detected - changes look clean!');
            }
            
            // Build error report for AI
            const consoleErrorReport = hasNewErrors ? {
              has_errors: true,
              error_count: postUpdateErrors.length,
              errors: postUpdateErrors.slice(0, 10).map(e => e.message), // Limit to 10
              action_required: ' CRITICAL: Your changes introduced console errors! You MUST fix these before proceeding. Review the errors above and call update_html again to fix them.'
            } : {
              has_errors: false,
              message: ' No console errors detected. Changes applied cleanly.'
            };
            
            //  Build CSS validation report for AI
            const hasCSSErrors = !cssValidation.valid && cssValidation.errors && cssValidation.errors.length > 0;
            const hasCSSWarnings = cssValidation.warnings && cssValidation.warnings.length > 0;
            const cssReport = (hasCSSErrors || hasCSSWarnings) ? {
              has_issues: hasCSSErrors,
              errors: hasCSSErrors ? cssValidation.errors : undefined,
              warnings: hasCSSWarnings ? cssValidation.warnings : undefined,
              action_required: hasCSSErrors ? ' CSS ISSUES DETECTED! Review the CSS errors above and fix them to ensure proper styling.' : undefined
            } : {
              has_issues: false,
              message: ' CSS validation passed. No syntax issues detected.'
            };
            
            // Generate verification token for mandatory verification step
            // Format: "lines:start-end|timestamp" where start-end is the affected line range
            const affectedStartLine = appliedEdits.length > 0 
              ? Math.min(...appliedEdits.map(e => parseInt((e.original_lines || e.lines || '1-1').split('-')[0])))
              : 1;
            const affectedEndLine = appliedEdits.length > 0
              ? Math.max(...appliedEdits.map(e => {
                  const lines = e.original_lines || e.lines || '1-1';
                  const endLine = parseInt(lines.split('-')[1] || lines.split('-')[0]);
                  const delta = e.line_delta || 0;
                  return endLine + Math.max(0, delta) + 10; // Include some buffer
                }))
              : 50;
            const verificationToken = `lines:${affectedStartLine}-${affectedEndLine}|${Date.now()}`;
            
            // Extract key snippets from new content for verification suggestions
            const verificationSuggestions = appliedEdits.slice(0, 3).map(edit => {
              const originalEdit = toolInput.edits[edit.edit_number - 1];
              const newStr = originalEdit?.new_string || '';
              // Extract distinctive parts: function names, class names, IDs, or first meaningful line
              const classMatch = newStr.match(/class="([^"]+)"/);
              const idMatch = newStr.match(/id="([^"]+)"/);
              const funcMatch = newStr.match(/function\s+(\w+)/);
              const textMatch = newStr.match(/>([^<]{10,50})</);
              return classMatch?.[0] || idMatch?.[0] || funcMatch?.[0] || textMatch?.[1]?.trim() || newStr.substring(0, 50);
            }).filter(s => s && s.length > 5);
            
            return JSON.stringify({
              success: !allEditsFailed && !hasNewErrors, // FALSE if edits failed OR introduced errors
              applied_edits: appliedEdits.length,
              failed_edits: failedEdits.length,
              total_edits: toolInput.edits.length,
              applied_details: appliedDetails.length > 0 ? appliedDetails : undefined,
              line_offset_applied: lineOffset !== 0 ? lineOffset : undefined,
              line_offset_warning: Math.abs(lineOffset) >= 5 ? ` LINE NUMBERS SHIFTED by ${lineOffset >= 0 ? '+' : ''}${lineOffset} lines! If you need to make more edits, call find_code_locations or get_html_section FIRST to get updated line numbers. Old line numbers are now INVALID.` : undefined,
              failed_details: failedEdits.length > 0 ? failedEdits : undefined,
              html_size_kb: (modifiedHTML.length / 1024).toFixed(2),
              console_check: consoleErrorReport, // Console error check results
              css_validation: cssReport, // CSS validation results - ALWAYS check this!
              //  VERIFICATION SYSTEM - Mandatory verification after successful edits
              verification_required: appliedEdits.length > 0 ? {
                token: verificationToken,
                mandatory: true,
                instruction: ' MANDATORY: You MUST call verify_edit with this token to PROVE your changes were inserted. Without verification, you CANNOT claim success.',
                suggested_snippets: verificationSuggestions,
                how_to_verify: 'Call verify_edit({ verification_token: "' + verificationToken + '", expected_snippets: [' + verificationSuggestions.slice(0, 2).map(s => '"' + s.replace(/"/g, '\\"').substring(0, 40) + '"').join(', ') + '] })'
              } : undefined,
              message: allEditsFailed 
                ? ` CRITICAL: ALL ${toolInput.edits.length} edit(s) FAILED! No changes were made to the HTML. The old_string values don't match the actual HTML. Use find_code_locations to see the actual code structure.`
                : hasNewErrors
                  ? ` Applied ${appliedEdits.length}/${toolInput.edits.length} edits BUT ${postUpdateErrors.length} CONSOLE ERROR(S) DETECTED! Your changes broke something. See console_check.errors and FIX IMMEDIATELY.`
                  : hasCSSErrors
                    ? ` Applied ${appliedEdits.length}/${toolInput.edits.length} edits BUT CSS ISSUES DETECTED! See css_validation.errors and fix the styling problems.`
                    : ` Applied ${appliedEdits.length}/${toolInput.edits.length} edits.  VERIFICATION REQUIRED: Call verify_edit with the verification_token to CONFIRM changes were inserted.`,
              warning: allEditsFailed ? 'NO CHANGES WERE APPLIED TO THE PREVIEW. You must fix your old_string values.' : (hasNewErrors ? ' YOUR CHANGES INTRODUCED ERRORS! Fix them immediately before doing anything else.' : (hasCSSErrors ? ' CSS ISSUES DETECTED! Fix styling problems before proceeding.' : undefined)),
              _verification_note: appliedEdits.length > 0 ? ' CRITICAL: Call verify_edit with verification_required.token to PROVE your changes exist in the code. Do NOT claim success without verification!' : undefined
            });
          
          case 'generate_html':
            // Log EVERYTHING about this generate_html call
            console.log(' === GENERATE_HTML TOOL CALL ===');
            console.log(' Full tool input object:', toolInput);
            console.log(' Tool input keys:', Object.keys(toolInput));
            console.log(' Tool input as JSON:', JSON.stringify(toolInput, null, 2));
            console.log(' html_content present?', !!toolInput.html_content);
            console.log(' html_content type:', typeof toolInput.html_content);
            console.log(' html_content length:', toolInput.html_content?.length || 0);
            console.log(' project_name present?', !!toolInput.project_name);
            console.log(' project_name value:', toolInput.project_name);
            
            if (toolInput.html_content) {
              console.log(' html_content IS PROVIDED');
              console.log('   Preview (first 500 chars):', toolInput.html_content.substring(0, 500));
              console.log('   Preview (last 200 chars):', toolInput.html_content.substring(toolInput.html_content.length - 200));
              console.log('   Contains DOCTYPE?', toolInput.html_content.includes('<!DOCTYPE'));
              console.log('   Contains <html>?', toolInput.html_content.includes('<html'));
              console.log('   Contains </html>?', toolInput.html_content.includes('</html>'));
            } else {
              console.log(' html_content IS MISSING!');
            }
            console.log('===================================');
            
            // Check if html_content was provided
            if (!toolInput.html_content) {
              console.error(' CRITICAL: AI did not provide html_content parameter!');
              console.error(' Tool input received:', JSON.stringify(toolInput, null, 2));
              console.error(' Investigating why html_content is missing...');
              
              // Check if we have existing HTML that could be used
              if (generatedHTML && generatedHTML.trim() !== '') {
                console.error(' WORKAROUND ATTEMPT: We have existing HTML in the system');
                console.error('   Existing HTML size:', (generatedHTML.length / 1024).toFixed(2), 'KB');
                console.error('   This indicates Claude should have received the HTML in the message but did not include it in the tool call');
                
                // Return a clear error that forces Claude to retry with the HTML
                return JSON.stringify({
                  success: false,
                  error: 'MISSING html_content parameter! You MUST provide the complete HTML in html_content parameter.',
                  hint: 'The current HTML was provided in your input message between ---CURRENT HTML--- markers. Modify it, then pass the COMPLETE modified HTML to html_content parameter.',
                  current_html_size_kb: (generatedHTML.length / 1024).toFixed(1),
                  required_action: 'Call generate_html again with BOTH parameters: html_content (plain HTML string) and project_name (a string name)',
                  reminder: 'Both parameters are REQUIRED. html_content must be PLAIN HTML.'
                });
              } else {
                console.error(' No existing HTML found. This should be a new page request.');
                return JSON.stringify({
                  success: false,
                  error: 'html_content parameter is REQUIRED. You must provide a complete HTML document starting with <!DOCTYPE html>.',
                  hint: 'For new pages: Create a complete HTML document and pass it in the html_content parameter.',
                  example: '{ html_content: "<!DOCTYPE html><html>...</html>", project_name: "My Project" }'
                });
              }
            }
            
            // Normalize HTML to guarantee UTF-8 charset and prevent encoding issues
            const rawHTML = toolInput.html_content;
            const newHTML = ensureUTF8Meta(rawHTML);
            
            // Log what we received
            console.log(' Received HTML from AI:', newHTML ? newHTML.substring(0, 200) + '...' : 'EMPTY');
            console.log(' HTML length:', newHTML?.length || 0, 'characters');
            
            // Validate the HTML before applying
            const generateValidation = validateHTML(newHTML);
            console.log(' Validation result:', generateValidation);
            
            // If validation has critical errors (not just warnings), handle it
            if (!generateValidation.valid && generateValidation.errors.length > 0) {
              console.warn(' HTML validation failed:', generateValidation.errors);
              console.log(' Problematic HTML:', newHTML?.substring(0, 500));
              
              // If this is a retry, let the error handler manage it
              if (!isRetrying) {
                await handleHTMLError(new Error('HTML validation failed'), newHTML);
              }
              
              return JSON.stringify({ 
                success: false, 
                message: 'HTML validation failed', 
                errors: generateValidation.errors,
                retry_count: errorRetryCount
              });
            }
            
            // If it's a snippet (has warnings but valid=true), we accept it but need full page
            if (generateValidation.warnings && generateValidation.warnings.length > 0 && generateValidation.warnings[0].includes('snippet')) {
              console.log(' AI generated a snippet instead of full document. This may cause issues.');
              // Accept it anyway - AI should learn from the error
            }
            
            // CRITICAL: Save current version to history BEFORE applying new HTML
            if (generatedHTML && generatedHTML.trim() !== '') {
              previousWorkingHTML = generatedHTML;
              
              // Check if we've already saved this exact HTML
              const lastVersion = versionHistory[versionHistory.length - 1];
              const alreadySaved = lastVersion && lastVersion.html === generatedHTML;
              
              if (!alreadySaved) {
                // Save current version with its creation message
                // Count how many user messages we have to determine which message created current HTML
                const userMessages = chatConversationHistory.filter(m => m.role === 'user');
                const messageForCurrentHTML = userMessages[versionHistory.length] || userMessages[userMessages.length - 1] || { content: 'Initial Version' };
                
                // Ensure content is a string
                const messageContent = typeof messageForCurrentHTML.content === 'string' 
                  ? messageForCurrentHTML.content 
                  : 'Version Update';
                
                console.log(' Saving version #' + (versionHistory.length + 1));
                console.log('   HTML size: ' + (generatedHTML.length / 1024).toFixed(1) + ' KB');
                console.log('   Message: "' + messageContent.substring(0, 60) + '"');
                
                // Save to localStorage only - BigQuery save happens via auto-save below
                saveVersion(generatedHTML, messageContent, '', false);
              }
            }
            
            // Now apply the new HTML
            console.log(' Applying new HTML (' + (newHTML.length / 1024).toFixed(1) + ' KB)');
            generatedHTML = newHTML;
            
            // Update version buttons after a short delay to ensure DOM is ready
            setTimeout(() => {
              updateChatVersionButtons();
              console.log(` Updated buttons. Versions: ${versionHistory.length}, Current: ${currentVersionIndex + 1}`);
            }, 150);
            
            // Reset error counter on successful generation
            errorRetryCount = 0;
            isRetrying = false;
            
            // Update preview
            const preview = document.getElementById('previewFrame');
            const loading = document.getElementById('previewLoading');
            
            loading.classList.remove('hidden');
            preview.classList.remove('loaded');
            
            setTimeout(() => {
              // Inject API configuration into the HTML so it can communicate with the backend
              const projectIdValue = currentProjectId ? "'" + currentProjectId + "'" : 'null';
              const apiConfigScript = '<' + 'script>\n' +
                '  // AUTO-INJECTED API HELPERS - Use these functions to interact with your database\n' +
                '  window.API_CONFIG = {\n' +
                '    API_BASE: \'dev url',\n' +
                '    PROJECT_ID: ' + projectIdValue + '\n' +
                '  };\n' +
                '  \n' +
                '  // Auto-discover PROJECT_ID from existing tables\n' +
                '  window.discoverProjectId = async function() {\n' +
                '    if (window.API_CONFIG.PROJECT_ID) {\n' +
                '      return window.API_CONFIG.PROJECT_ID;\n' +
                '    } else {\n' +
                '      // Need to discover it - query the database for existing tables\n' +
                '      try {\n' +
                '        console.log(\' Auto-discovering PROJECT_ID from database tables...\');\n' +
                '        const response = await fetch(window.API_CONFIG.API_BASE + \'/api/tables\');\n' +
                '        const data = await response.json();\n' +
                '        if (data.success && data.tables && data.tables.length > 0) {\n' +
                '          const firstTable = data.tables[0].name;\n' +
                '          const match = firstTable.match(/^(prj_\\\\d+_[a-z0-9]+)_/);\n' +
                '          if (match) {\n' +
                '            window.API_CONFIG.PROJECT_ID = match[1];\n' +
                '            console.log(\' Auto-discovered PROJECT_ID:\', window.API_CONFIG.PROJECT_ID);\n' +
                '            return window.API_CONFIG.PROJECT_ID;\n' +
                '          }\n' +
                '        }\n' +
                '      } catch (err) {\n' +
                '        console.error(\' Failed to discover PROJECT_ID:\', err);\n' +
                '      }\n' +
                '      return null;\n' +
                '    }\n' +
                '  };\n' +
                '  \n' +
                '  // Save data to your table (non-blocking - returns immediately)\n' +
                '  // BATCH SUPPORT: Pass array of objects to insert multiple records in one call\n' +
                '  // Example: saveToProjectTable("users", [{id:"1",name:"John"}, {id:"2",name:"Jane"}])\n' +
                '  window.saveToProjectTable = async function(tableName, data) {\n' +
                '    if (!window.API_CONFIG.PROJECT_ID) await window.discoverProjectId();\n' +
                '    const fullTableName = window.API_CONFIG.PROJECT_ID ? window.API_CONFIG.PROJECT_ID + \'_\' + tableName : tableName;\n' +
                '    // Start save in background with 120 second timeout\n' +
                '    const controller = new AbortController();\n' +
                '    const timeoutId = setTimeout(() => controller.abort(), 120000);\n' +
                '    const savePromise = fetch(window.API_CONFIG.API_BASE + \'/api/table/insert\', {\n' +
                '      method: \'POST\',\n' +
                '      headers: { \'Content-Type\': \'application/json\' },\n' +
                '      body: JSON.stringify({ table_name: fullTableName, data: data }),\n' +
                '      signal: controller.signal\n' +
                '    }).then(r => r.json()).catch(err => {\n' +
                '      clearTimeout(timeoutId);\n' +
                '      console.error(\'Background save failed:\', err);\n' +
                '      return { success: false, error: err.message };\n' +
                '    }).finally(() => clearTimeout(timeoutId));\n' +
                '    // Return immediately with optimistic success\n' +
                '    return { success: true, _promise: savePromise };\n' +
                '  };\n' +
                '  \n' +
                '  // Load data from your table\n' +
                '  window.queryProjectTable = async function(tableName, whereClause = null, limit = 100) {\n' +
                '    // Input validation\n' +
                '    if (!tableName || typeof tableName !== \'string\' || tableName.trim() === \'\') {\n' +
                '      console.error(\'queryProjectTable: tableName is required and must be a non-empty string\');\n' +
                '      return { success: false, error: \'tableName is required\', data: [], count: 0 };\n' +
                '    }\n' +
                '    \n' +
                '    if (!window.API_CONFIG.PROJECT_ID) await window.discoverProjectId();\n' +
                '    const fullTableName = window.API_CONFIG.PROJECT_ID ? window.API_CONFIG.PROJECT_ID + \'_\' + tableName : tableName;\n' +
                '    \n' +
                '    // Smart parsing: separate WHERE clause from ORDER BY\n' +
                '    let actualWhereClause = whereClause;\n' +
                '    let orderBy = null;\n' +
                '    if (whereClause && typeof whereClause === \'string\') {\n' +
                '      const orderByMatch = whereClause.match(/ORDER\\s+BY\\s+(.+?)$/i);\n' +
                '      if (orderByMatch) {\n' +
                '        orderBy = orderByMatch[1].trim();\n' +
                '        actualWhereClause = whereClause.substring(0, orderByMatch.index).trim() || null;\n' +
                '      }\n' +
                '    }\n' +
                '    \n' +
                '    try {\n' +
                '      const requestBody = { table_name: fullTableName, limit: limit };\n' +
                '      if (actualWhereClause) requestBody.where_clause = actualWhereClause;\n' +
                '      if (orderBy) requestBody.order_by = orderBy;\n' +
                '      \n' +
                '      // Add 120 second timeout for query operations\n' +
                '      const controller = new AbortController();\n' +
                '      const timeoutId = setTimeout(() => controller.abort(), 120000);\n' +
                '      \n' +
                '      const response = await fetch(window.API_CONFIG.API_BASE + \'/api/table/query\', {\n' +
                '        method: \'POST\',\n' +
                '        headers: { \'Content-Type\': \'application/json\' },\n' +
                '        body: JSON.stringify(requestBody),\n' +
                '        signal: controller.signal\n' +
                '      });\n' +
                '      \n' +
                '      clearTimeout(timeoutId);\n' +
                '      \n' +
                '      if (!response.ok) {\n' +
                '        const errorText = await response.text();\n' +
                '        console.error(\'Query API error:\', response.status, errorText);\n' +
                '        return { success: false, error: \'API error: \' + response.status, data: [], count: 0 };\n' +
                '      }\n' +
                '      \n' +
                '      const result = await response.json();\n' +
                '      return result || { success: false, error: \'Empty response\', data: [], count: 0 };\n' +
                '    } catch (err) {\n' +
                '      console.error(\'Query failed:\', err);\n' +
                '      return { success: false, error: err.message || \'Unknown error\', data: [], count: 0 };\n' +
                '    }\n' +
                '  };\n' +
                '  \n' +
                '  // Update existing data (non-blocking - returns immediately)\n' +
                '  window.updateProjectTable = async function(tableName, data, whereClause) {\n' +
                '    if (!window.API_CONFIG.PROJECT_ID) await window.discoverProjectId();\n' +
                '    const fullTableName = window.API_CONFIG.PROJECT_ID ? window.API_CONFIG.PROJECT_ID + \'_\' + tableName : tableName;\n' +
                '    // Start update in background with 120 second timeout\n' +
                '    const controller = new AbortController();\n' +
                '    const timeoutId = setTimeout(() => controller.abort(), 120000);\n' +
                '    const updatePromise = fetch(window.API_CONFIG.API_BASE + \'/api/table/update\', {\n' +
                '      method: \'POST\',\n' +
                '      headers: { \'Content-Type\': \'application/json\' },\n' +
                '      body: JSON.stringify({ table_name: fullTableName, data: data, where_clause: whereClause }),\n' +
                '      signal: controller.signal\n' +
                '    }).then(r => r.json()).catch(err => {\n' +
                '      clearTimeout(timeoutId);\n' +
                '      console.error(\'Background update failed:\', err);\n' +
                '      return { success: false, error: err.message };\n' +
                '    }).finally(() => clearTimeout(timeoutId));\n' +
                '    // Return immediately with optimistic success\n' +
                '    return { success: true, _promise: updatePromise };\n' +
                '  };\n' +
                '  \n' +
                '  // Delete data (non-blocking - returns immediately)\n' +
                '  window.deleteFromProjectTable = async function(tableName, whereClause) {\n' +
                '    if (!window.API_CONFIG.PROJECT_ID) await window.discoverProjectId();\n' +
                '    const fullTableName = window.API_CONFIG.PROJECT_ID ? window.API_CONFIG.PROJECT_ID + \'_\' + tableName : tableName;\n' +
                '    // Start delete in background with 120 second timeout\n' +
                '    const controller = new AbortController();\n' +
                '    const timeoutId = setTimeout(() => controller.abort(), 120000);\n' +
                '    const deletePromise = fetch(window.API_CONFIG.API_BASE + \'/api/table/delete\', {\n' +
                '      method: \'POST\',\n' +
                '      headers: { \'Content-Type\': \'application/json\' },\n' +
                '      body: JSON.stringify({ table_name: fullTableName, where_clause: whereClause }),\n' +
                '      signal: controller.signal\n' +
                '    }).then(r => r.json()).catch(err => {\n' +
                '      clearTimeout(timeoutId);\n' +
                '      console.error(\'Background delete failed:\', err);\n' +
                '      return { success: false, error: err.message };\n' +
                '    }).finally(() => clearTimeout(timeoutId));\n' +
                '    // Return immediately with optimistic success\n' +
                '    return { success: true, _promise: deletePromise };\n' +
                '  };\n' +
                '  \n' +
                '  console.log(\' Database API helpers loaded. Use saveToProjectTable(), queryProjectTable(), updateProjectTable(), deleteFromProjectTable()\');\n' +
                '  \n' +
                '  // CONSOLE LOG CAPTURE - Send console messages to parent window\n' +
                '  (function() {\n' +
                '    const originalConsole = {\n' +
                '      log: console.log,\n' +
                '      error: console.error,\n' +
                '      warn: console.warn,\n' +
                '      info: console.info\n' +
                '    };\n' +
                '    \n' +
                '    function sendToParent(level, args) {\n' +
                '      try {\n' +
                '        // Serialize args safely for postMessage\n' +
                '        const serializedArgs = args.map(arg => {\n' +
                '          if (arg === null) return \'null\';\n' +
                '          if (arg === undefined) return \'undefined\';\n' +
                '          if (typeof arg === \'string\') return arg;\n' +
                '          if (typeof arg === \'number\') return String(arg);\n' +
                '          if (typeof arg === \'boolean\') return String(arg);\n' +
                '          if (arg instanceof Error) return arg.message + \'\\n\' + (arg.stack || \'\');\n' +
                '          if (typeof arg === \'object\') {\n' +
                '            try {\n' +
                '              return JSON.stringify(arg, null, 2);\n' +
                '            } catch (e) {\n' +
                '              return \'[Object (circular or non-serializable)]\';\n' +
                '            }\n' +
                '          }\n' +
                '          return String(arg);\n' +
                '        });\n' +
                '        \n' +
                '        const message = serializedArgs.join(\' \');\n' +
                '        \n' +
                '        window.parent.postMessage({\n' +
                '          type: \'CONSOLE_LOG\',\n' +
                '          level: level,\n' +
                '          message: message,\n' +
                '          args: serializedArgs\n' +
                '        }, \'*\');\n' +
                '      } catch (e) {\n' +
                '        // Silently fail if parent messaging doesn\'t work\n' +
                '        originalConsole.error(\'Console capture failed:\', e);\n' +
                '      }\n' +
                '    }\n' +
                '    \n' +
                '    console.log = function(...args) {\n' +
                '      sendToParent(\'log\', args);\n' +
                '      originalConsole.log.apply(console, args);\n' +
                '    };\n' +
                '    \n' +
                '    console.error = function(...args) {\n' +
                '      sendToParent(\'error\', args);\n' +
                '      originalConsole.error.apply(console, args);\n' +
                '    };\n' +
                '    \n' +
                '    console.warn = function(...args) {\n' +
                '      sendToParent(\'warn\', args);\n' +
                '      originalConsole.warn.apply(console, args);\n' +
                '    };\n' +
                '    \n' +
                '    console.info = function(...args) {\n' +
                '      sendToParent(\'info\', args);\n' +
                '      originalConsole.info.apply(console, args);\n' +
                '    };\n' +
                '  })();\n' +
                '<' + '/script>';
              
              // No longer replacing PROJECT_ID - the generated app auto-discovers it
              // Just inject the config script for helper functions
              let htmlWithConfig = generatedHTML;
              
              // Inject the config script right after <head> tag
              if (htmlWithConfig.includes('<head>')) {
                htmlWithConfig = htmlWithConfig.replace('<head>', '<head>' + apiConfigScript);
              } else if (htmlWithConfig.includes('<html>')) {
                htmlWithConfig = htmlWithConfig.replace('<html>', '<html>' + apiConfigScript);
              }
              
              console.log(' Injected auto-discovery helpers - PROJECT_ID will be discovered from tables');
              
              preview.srcdoc = wrapHTMLWithConsoleCapture(htmlWithConfig);
              preview.onload = () => {
                loading.classList.add('hidden');
                preview.classList.add('loaded');
                console.log(' Preview loaded with API helpers');
              };
              
              // Also handle error in iframe
              preview.onerror = () => {
                console.error(' Preview iframe failed to load');
                loading.classList.add('hidden');
                handleHTMLError(new Error('Preview failed to load'), generatedHTML);
              };
            }, 50);
            
            // Update code view
            updateCodeView(generatedHTML);
            
            // Auto-save to BigQuery - ALWAYS save when HTML is generated
            const projectNameForSave = toolInput.project_name || allProjects[0]?.project_name || 'App Builder Project';
            const uniqueCacheId = `${projectNameForSave.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}`;
            console.log(` === AUTO-SAVE TO BIGQUERY ===`);
            console.log(`   Project Name: ${projectNameForSave}`);
            console.log(`   Cache ID: ${uniqueCacheId}`);
            console.log(`   Current Project ID: ${currentProjectId || 'NONE - WILL SAVE TO GLOBAL TABLE!'}`);
            console.log(`   HTML Size: ${(generatedHTML.length / 1024).toFixed(2)} KB`);
            try {
              const versionBeforeIncrement = currentVersionNumber;
              currentVersionNumber++; // Increment before save
              console.log(`   Version Number: ${versionBeforeIncrement}  ${currentVersionNumber} (incremented for generate_html save)`);
              await saveToBigQuery(projectNameForSave, generatedHTML, uniqueCacheId, currentVersionNumber);
              console.log(` AUTO-SAVE COMPLETED SUCCESSFULLY`);
              console.log(`   Saved to: ${currentProjectId ? currentProjectId + '_html_cache' : 'dashboard_html_cache (global)'}`);
            } catch (saveError) {
              console.error(' AUTO-SAVE FAILED:', saveError);
              console.error('   Error message:', saveError.message);
              console.error('   This means HTML will NOT persist on page reload!');
              currentVersionNumber--; // Revert version increment
              // Continue anyway - don't block the preview update
            }
            console.log(`=================================\n`);
            
            //  POST-GENERATE CONSOLE ERROR CHECK
            // Wait for preview to render and check for any errors (including async data loading)
            await new Promise(resolve => setTimeout(resolve, 800)); // Initial wait for JS execution
            
            let postGenerateErrors = getConsoleLogs(false, 50).filter(l => l.level === 'error');
            
            // If no errors yet, wait longer for async operations (API calls, data loading)
            if (postGenerateErrors.length === 0) {
              await new Promise(resolve => setTimeout(resolve, 1200)); // Wait for async operations
              postGenerateErrors = getConsoleLogs(false, 50).filter(l => l.level === 'error');
            }
            
            const generateHasErrors = postGenerateErrors.length > 0;
            
            if (generateHasErrors) {
              console.warn(` POST-GENERATE ERROR CHECK: Found ${postGenerateErrors.length} console error(s)!`);
              postGenerateErrors.forEach((err, i) => {
                console.warn(`   ${i + 1}. ${err.message}`);
              });
            } else {
              console.log(' POST-GENERATE ERROR CHECK: No console errors - generated code is clean!');
            }
            
            // Build error report for AI
            const generateConsoleReport = generateHasErrors ? {
              has_errors: true,
              error_count: postGenerateErrors.length,
              errors: postGenerateErrors.slice(0, 10).map(e => e.message),
              action_required: ' CRITICAL: The generated HTML has console errors! You MUST fix these immediately by calling update_html.'
            } : {
              has_errors: false,
              message: ' No console errors detected. Generated code is clean.'
            };
            
            return JSON.stringify({ 
              success: !generateHasErrors,
              message: generateHasErrors 
                ? `HTML generated BUT ${postGenerateErrors.length} CONSOLE ERROR(S) DETECTED! Your generated code has bugs. See console_check.errors and FIX IMMEDIATELY using update_html.`
                : 'HTML generated and preview updated.  No console errors.',
              console_check: generateConsoleReport
            });
          
          case 'query_database':
            try {
              // If currentProjectId exists and table doesn't have prefix, add it
              let queryTableName = toolInput.table_name;
              if (currentProjectId && !queryTableName.startsWith(currentProjectId + '_')) {
                queryTableName = `${currentProjectId}_${queryTableName}`;
                console.log(` Querying project table: ${queryTableName}`);
              }
              
              const queryResponse = await fetch(`${API_BASE}/api/table/query`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  ...toolInput,
                  table_name: queryTableName
                })
              });
              
              if (!queryResponse.ok) {
                const errorText = await queryResponse.text();
                return JSON.stringify({
                  success: false,
                  error: `API returned ${queryResponse.status}: ${errorText.substring(0, 200)}`
                });
              }
              
              const queryData = await queryResponse.json();
              return JSON.stringify(queryData);
            } catch (err) {
              return JSON.stringify({
                success: false,
                error: `Failed to query database: ${err.message}`
              });
            }
          
          case 'list_tables':
            try {
              const tablesResponse = await fetch(`${API_BASE}/api/tables`);
              
              if (!tablesResponse.ok) {
                const errorText = await tablesResponse.text();
                return JSON.stringify({
                  success: false,
                  error: `API returned ${tablesResponse.status}: ${errorText.substring(0, 200)}`
                });
              }
              
              const tablesData = await tablesResponse.json();
              return JSON.stringify(tablesData);
            } catch (err) {
              return JSON.stringify({
                success: false,
                error: `Failed to list tables: ${err.message}`
              });
            }
          
          case 'get_project_context':
            // Get current project information and all its tables with schemas
            const contextInfo = {
              project_id: currentProjectId,
              project_name: allProjects.find(p => p.project_id === currentProjectId)?.project_name || 'Unknown',
              tables: [],
              helper_functions_available: {
                save: 'window.saveToProjectTable(tableName, dataObject) - Returns immediately for optimistic UI',
                load: 'window.queryProjectTable(tableName, whereClause, limit) - Returns {success, data} where data is an array',
                update: 'window.updateProjectTable(tableName, updates, whereClause) - Returns immediately',
                delete: 'window.deleteFromProjectTable(tableName, whereClause) - Returns immediately'
              },
              important_notes: [
                'Use EXACT table names from "name" field below - do not modify',
                'Helper functions are auto-injected - just call them in generated HTML',
                'Schema information is already provided below - DO NOT query every table unnecessarily',
                'Only call query_database if you need to see ACTUAL DATA samples (not for schema - you already have it)',
                'CRITICAL: queryProjectTable returns {success: bool, data: array} - always check response.success and loop through response.data',
                'ALWAYS call load functions on page initialization: document.addEventListener("DOMContentLoaded", loadFunction)'
              ],
              load_pattern_reminder: 'const response = await window.queryProjectTable("tableName"); if (response.success && response.data) { response.data.forEach(item => { /* render item */ }); }'
            };
            
            if (currentProjectId) {
              // Get all tables for this project
              const projectTablesResponse = await fetch(`${API_BASE}/api/project/tables?project_id=${currentProjectId}`);
              if (projectTablesResponse.ok) {
                const projectTablesData = await projectTablesResponse.json();
                const tables = projectTablesData.tables || [];
                
                // BATCH OPTIMIZATION: Get all schemas in a single query using IN clause
                if (tables.length > 0) {
                  try {
                    const tableNames = tables.map(t => `'${t.name}'`).join(', ');
                    const batchSchemaSQL = `SELECT table_name, column_name, data_type FROM \`gcp-trtools-dev.digital_connection.INFORMATION_SCHEMA.COLUMNS\` WHERE table_name IN (${tableNames}) ORDER BY table_name, ordinal_position`;
                    
                    console.log(` BATCH: Fetching schemas for ${tables.length} tables in one query`);
                    const schemaResponse = await fetch(`${API_BASE}/api/query`, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ sql: batchSchemaSQL })
                    });
                    
                    if (schemaResponse.ok) {
                      const allSchemaData = await schemaResponse.json();
                      const schemaByTable = {};
                      
                      // Group columns by table name
                      (allSchemaData.data || []).forEach(col => {
                        if (!schemaByTable[col.table_name]) {
                          schemaByTable[col.table_name] = [];
                        }
                        schemaByTable[col.table_name].push({
                          column_name: col.column_name,
                          data_type: col.data_type
                        });
                      });
                      
                      // Now build context info for each table using the batched results
                      for (const table of tables) {
                        const columns = schemaByTable[table.name] || [];
                        const columnNames = columns.map(c => c.column_name);
                        const sampleColumns = columnNames.slice(0, 2).map(c => `${c}: value`).join(', ');
                        
                        const loadExample = columnNames.length > 0
                          ? `const response = await window.queryProjectTable('${table.display_name}'); if (response.success && response.data) { response.data.forEach(item => { console.log(item.${columnNames[0]}); }); }`
                          : `const response = await window.queryProjectTable('${table.display_name}'); if (response.success) { /* use response.data */ }`;
                        
                        contextInfo.tables.push({
                          name: table.display_name, // Without prefix
                          full_name: table.name, // With prefix
                          columns: columns,
                          row_count: table.row_count,
                          save_example: `await window.saveToProjectTable('${table.display_name}', {${sampleColumns}})`,
                          load_example: loadExample,
                          load_on_init_example: `document.addEventListener('DOMContentLoaded', async () => { const response = await window.queryProjectTable('${table.display_name}'); if (response.success && response.data) { /* render response.data array */ } });`
                        });
                      }
                    }
                  } catch (err) {
                    console.warn('Could not fetch schemas (batch):', err.message);
                  }
                }
              }
            }
            
            // Add workflow guidance to the result
            const hasNoTables = !contextInfo.tables || contextInfo.tables.length === 0;
            if (hasNoTables) {
              contextInfo._workflow = {
                next_step: 'create_schema',
                next_tool: 'create_table',
                reason: 'No tables exist yet. If user wants to save/persist data, create a table first.',
                conditional: 'Only proceed with create_table if user request includes: save, persist, store, track, remember, database'
              };
            } else {
              contextInfo._workflow = {
                next_step: 'use_existing_schema',
                next_tool: 'generate_html',
                reason: 'Tables already exist. Use them in HTML generation.',
                available_tables: contextInfo.tables.map(t => t.name)
              };
            }
            
            return JSON.stringify(contextInfo, null, 2);
          
          case 'check_table_schema':
            // Get schema for a specific table
            const checkTableName = toolInput.table_name;
            const fullCheckTableName = currentProjectId && !checkTableName.startsWith(currentProjectId + '_')
              ? `${currentProjectId}_${checkTableName}`
              : checkTableName;
            
            try {
              const schemaCheckSQL = `SELECT column_name, data_type, is_nullable FROM \`gcp-trtools-dev.digital_connection.INFORMATION_SCHEMA.COLUMNS\` WHERE table_name = '${fullCheckTableName}' ORDER BY ordinal_position`;
              const schemaCheckResponse = await fetch(`${API_BASE}/api/query`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sql: schemaCheckSQL })
              });
              
              if (schemaCheckResponse.ok) {
                const schemaCheckData = await schemaCheckResponse.json();
                
                if (schemaCheckData.data && schemaCheckData.data.length > 0) {
                  const columns = schemaCheckData.data;
                  
                  // Categorize columns by type for better guidance
                  const timestampCols = columns.filter(c => c.data_type === 'TIMESTAMP').map(c => c.column_name);
                  const requiredCols = columns.filter(c => c.is_nullable === 'NO' && c.data_type !== 'TIMESTAMP').map(c => c.column_name);
                  const optionalCols = columns.filter(c => c.is_nullable === 'YES' && c.data_type !== 'TIMESTAMP').map(c => c.column_name);
                  
                  // Group columns by data type for validation guidance
                  const columnsByType = {
                    STRING: columns.filter(c => c.data_type === 'STRING').map(c => c.column_name),
                    INT64: columns.filter(c => c.data_type === 'INT64').map(c => c.column_name),
                    FLOAT64: columns.filter(c => c.data_type === 'FLOAT64').map(c => c.column_name),
                    BOOL: columns.filter(c => c.data_type === 'BOOL').map(c => c.column_name),
                    TIMESTAMP: columns.filter(c => c.data_type === 'TIMESTAMP').map(c => c.column_name),
                    DATE: columns.filter(c => c.data_type === 'DATE').map(c => c.column_name),
                    JSON: columns.filter(c => c.data_type === 'JSON').map(c => c.column_name)
                  };
                  
                  // Build field validation rules for each column
                  const fieldValidation = columns.map(c => {
                    const rules = { field: c.column_name, type: c.data_type, nullable: c.is_nullable === 'YES' };
                    switch(c.data_type) {
                      case 'STRING':
                        rules.accepts = 'text/string values';
                        rules.example = '"example text"';
                        rules.validation = 'typeof value === "string"';
                        break;
                      case 'INT64':
                        rules.accepts = 'whole numbers only (no decimals)';
                        rules.example = '42';
                        rules.validation = 'Number.isInteger(value)';
                        rules.convert = 'parseInt(value, 10)';
                        break;
                      case 'FLOAT64':
                        rules.accepts = 'decimal numbers';
                        rules.example = '3.14';
                        rules.validation = 'typeof value === "number" && !isNaN(value)';
                        rules.convert = 'parseFloat(value)';
                        break;
                      case 'BOOL':
                        rules.accepts = 'true or false only';
                        rules.example = 'true';
                        rules.validation = 'typeof value === "boolean"';
                        rules.convert = 'Boolean(value) or value === "true"';
                        break;
                      case 'TIMESTAMP':
                        rules.accepts = 'ISO 8601 datetime string';
                        rules.example = 'new Date().toISOString()';
                        rules.validation = '!isNaN(Date.parse(value))';
                        rules.note = 'Auto-populates - usually omit from save';
                        break;
                      case 'DATE':
                        rules.accepts = 'YYYY-MM-DD format string';
                        rules.example = '"2024-01-15"';
                        rules.validation = '/^\\d{4}-\\d{2}-\\d{2}$/.test(value)';
                        break;
                      case 'JSON':
                        rules.accepts = 'JSON string or object';
                        rules.example = 'JSON.stringify({key: "value"})';
                        rules.validation = 'typeof value === "object" || valid JSON string';
                        break;
                    }
                    return rules;
                  });
                  
                  // Build example save with only non-timestamp fields
                  const saveableColumns = [...requiredCols, ...optionalCols].slice(0, 3);
                  const sampleColumns = saveableColumns.map(c => `${c}: value`).join(', ');
                  
                  // Build the TYPE MAP string that AI must copy and follow
                  const typeMapLines = columns.map(c => {
                    let conversionNote = '';
                    switch(c.data_type) {
                      case 'STRING': conversionNote = 'use string value'; break;
                      case 'INT64': conversionNote = 'MUST use parseInt(value, 10)'; break;
                      case 'FLOAT64': conversionNote = 'MUST use parseFloat(value)'; break;
                      case 'BOOL': conversionNote = 'MUST use true/false literal, .checked for checkbox'; break;
                      case 'TIMESTAMP': conversionNote = 'OMIT or use new Date().toISOString()'; break;
                      case 'DATE': conversionNote = 'use "YYYY-MM-DD" string'; break;
                      default: conversionNote = `handle as ${c.data_type}`;
                    }
                    return `//   ${c.column_name}: ${c.data_type}  ${conversionNote}`;
                  }).join('\n');
                  
                  return JSON.stringify({
                    success: true,
                    "_MANDATORY_ACTION": "YOU MUST CREATE A TYPE MAP IN YOUR RESPONSE BEFORE WRITING ANY CRUD CODE!",
                    "_TYPE_MAP_TO_COPY": `\n// TYPE MAP FOR ${checkTableName} (COPY THIS AND FOLLOW IT EXACTLY!):\n${typeMapLines}`,
                    table_name: checkTableName,
                    full_table_name: fullCheckTableName,
                    columns: columns,
                    columns_by_type: columnsByType,
                    field_validation: fieldValidation,
                    timestamp_fields: timestampCols,
                    required_fields: requiredCols,
                    optional_fields: optionalCols,
                    "_COMMON_ERRORS": {
                      "INT64_error": "Value of type STRING cannot be assigned to field which has type INT64 - FIX: use parseInt()",
                      "FLOAT64_error": "Value of type STRING cannot be assigned to field which has type FLOAT64 - FIX: use parseFloat()",
                      "BOOL_error": "Value of type STRING cannot be assigned to field which has type BOOL - FIX: use .checked or === 'true'",
                      "TIMESTAMP_error": "Value of type STRING cannot be assigned to field which has type TIMESTAMP - FIX: use new Date().toISOString() or omit"
                    },
                    type_validation_rules: {
                      STRING: ' String values OK',
                      INT64: ' MUST parseInt(value, 10) - raw strings cause errors!',
                      FLOAT64: ' MUST parseFloat(value) - raw strings cause errors!',
                      BOOL: ' MUST use literal true/false - "true"/"false" strings cause errors!',
                      TIMESTAMP: ' MUST use new Date().toISOString() - plain strings cause errors!',
                      DATE: ' Do NOT put Date objects - use YYYY-MM-DD string format'
                    },
                    "_NEXT_STEP": "1. COPY the TYPE MAP above into your response. 2. When building save payload, reference the TYPE MAP and apply the correct conversion for EACH field!",
                    critical_reminder: ` STOP! Before writing save/update code: (1) Copy the TYPE MAP above, (2) For EACH field, use the exact conversion shown, (3) Form inputs are ALWAYS strings - you MUST convert INT64/FLOAT64/BOOL fields!`,
                    example_save: `await window.saveToProjectTable('${checkTableName}', {${sampleColumns}}) // DO NOT include: ${timestampCols.join(', ')}`,
                    example_load: `const response = await window.queryProjectTable('${checkTableName}'); if (response.success && response.data) { response.data.forEach(item => { /* Access: item.${columns[0]?.column_name || 'field'} */ }); }`,
                    load_reminder: 'IMPORTANT: queryProjectTable returns {success, data} - always check response.success and loop through response.data array',
                    _workflow: {
                      next_step: 'generate_app',
                      next_tool: 'generate_html',
                      reason: 'Schema verified. Now generate or update HTML to integrate with this table.',
                      integration_code: {
                        save_example: `await window.saveToProjectTable('${checkTableName}', {${sampleColumns}})`,
                        load_example: `const r = await window.queryProjectTable('${checkTableName}'); if (r.success && r.data) { r.data.forEach(item => { /* render item */ }); }`,
                        init_pattern: `document.addEventListener('DOMContentLoaded', async () => { const r = await window.queryProjectTable('${checkTableName}'); if (r.success && r.data) { /* render data */ } });`
                      }
                    }
                  }, null, 2);
                } else {
                  return JSON.stringify({
                    success: false,
                    error: `Table '${checkTableName}' not found. Create it first with create_table.`
                  });
                }
              }
            } catch (err) {
              return JSON.stringify({
                success: false,
                error: `Failed to check schema: ${err.message}`
              });
            }
            
            // Fallback if response wasn't OK
            return JSON.stringify({
              success: false,
              error: `Failed to check table schema for '${checkTableName}'`
            });
          
          case 'save_project':
            try {
              await saveToBigQuery(toolInput.project_name, generatedHTML, toolInput.cache_id, currentVersionNumber);
              return JSON.stringify({ success: true, message: 'Project saved' });
            } catch (err) {
              return JSON.stringify({
                success: false,
                error: `Failed to save project: ${err.message}`
              });
            }
          
          case 'load_project':
            try {
              const loadResponse = await fetch(`${API_BASE}/api/html/load`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ cache_id: toolInput.cache_id })
              });
              
              if (!loadResponse.ok) {
                const errorText = await loadResponse.text();
                return JSON.stringify({
                  success: false,
                  error: `API returned ${loadResponse.status}: ${errorText.substring(0, 200)}`
                });
              }
              
              const loadData = await loadResponse.json();
              
              if (!loadData.data || !loadData.data.html_content) {
                return JSON.stringify({
                  success: false,
                  error: 'No HTML content found in loaded project'
                });
              }
              
              // Check if HTML content is base64 encoded and decode it if needed
              let htmlContent = loadData.data.html_content;
              if (htmlContent) {
                const trimmed = htmlContent.trim();
                const looksLikeHTML = trimmed.startsWith('<!DOCTYPE') || trimmed.startsWith('<html') || trimmed.startsWith('<');
                
                if (!looksLikeHTML) {
                  try {
                    const decoded = atob(htmlContent);
                    const decodedTrimmed = decoded.trim();
                    
                    if (
                      decodedTrimmed.startsWith('<!DOCTYPE') ||
                      decodedTrimmed.startsWith('<html') ||
                      decodedTrimmed.startsWith('<')
                    ) {
                      console.log(' Decoded base64 HTML from loaded project');
                      htmlContent = decoded;
                    }
                  } catch (err) {
                    console.warn(' Failed to decode base64 HTML:', err.message);
                  }
                }
              }
              
              // Ensure loaded HTML is normalized and uses UTF-8 charset
              generatedHTML = ensureUTF8Meta(htmlContent);
              const previewFrame = document.getElementById('previewFrame');
              if (previewFrame) {
                previewFrame.srcdoc = wrapHTMLWithConsoleCapture(generatedHTML);
              }
              updateCodeView(generatedHTML);
              return JSON.stringify({ success: true, project: loadData.data.page_name });
            } catch (err) {
              return JSON.stringify({
                success: false,
                error: `Failed to load project: ${err.message}`
              });
            }
          
          case 'list_projects':
            try {
              const listResponse = await fetch(`${API_BASE}/api/html/list`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({})
              });
              
              if (!listResponse.ok) {
                const errorText = await listResponse.text();
                return JSON.stringify({
                  success: false,
                  error: `API returned ${listResponse.status}: ${errorText.substring(0, 200)}`
                });
              }
              
              const listData = await listResponse.json();
              return JSON.stringify(listData);
            } catch (err) {
              return JSON.stringify({
                success: false,
                error: `Failed to list projects: ${err.message}`
              });
            }
          
          case 'create_table':
            // VALIDATION: Ensure schema is provided and not empty
            if (!toolInput.schema || !Array.isArray(toolInput.schema) || toolInput.schema.length === 0) {
              return JSON.stringify({
                success: false,
                error: 'CRITICAL ERROR: schema parameter is required and must be a non-empty array. You must define columns with {name, type} for each column.',
                required_format: 'schema: [{name: "column1", type: "STRING"}, {name: "column2", type: "INT64"}]',
                example: 'For a game: schema: [{name: "player_name", type: "STRING"}, {name: "score", type: "INT64"}, {name: "timestamp", type: "TIMESTAMP"}]'
              });
            }
            
            // Show confirmation dialog to user
            const schemaPreview = toolInput.schema.map(col => 
              `  ${col.name}: ${col.type}${col.nullable === false ? ' (required)' : ''}`
            ).join('\n');
            
            const approved = await showTableCreationDialog(
              toolInput.table_name,
              schemaPreview,
              toolInput.schema
            );
            
            if (!approved) {
              return JSON.stringify({
                success: false,
                error: 'Table creation cancelled by user',
                message: 'User declined to create the table. You can try again with a different schema or table name.'
              });
            }
            
            // If currentProjectId exists, prefix table name with project ID
            let tableName = toolInput.table_name;
            if (currentProjectId && !tableName.startsWith(currentProjectId + '_')) {
              tableName = `${currentProjectId}_${tableName}`;
            }
            
            const createTableResponse = await fetch(`${API_BASE}/api/table/create`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                table_name: tableName,
                schema: toolInput.schema
              })
            });
            
            const createTableData = await createTableResponse.json();
            
            // Refresh database tables in background (don't block)
            if (createTableData.success) {
              loadDatabaseTables().catch(err => console.warn('Background table refresh failed:', err));
              
              // Add workflow guidance
              createTableData._workflow = {
                next_step: 'verify_schema',
                next_tool: 'check_table_schema',
                reason: 'Table created successfully. Verify the schema before using it in HTML.',
                required_params: {
                  table_name: toolInput.table_name
                }
              };
            }
            
            return JSON.stringify(createTableData);
          
          case 'modify_table_schema':
            // Add column to existing table with confirmation
            try {
              if (!toolInput.table_name || !toolInput.column_name || !toolInput.column_type) {
                return JSON.stringify({
                  success: false,
                  error: 'table_name, column_name, and column_type are required',
                  hint: 'Provide all required parameters to add a column to an existing table'
                });
              }
              
              // If currentProjectId exists, prefix table name with project ID
              let modifyTableName = toolInput.table_name;
              if (currentProjectId && !modifyTableName.startsWith(currentProjectId + '_')) {
                modifyTableName = `${currentProjectId}_${toolInput.table_name}`;
              }
              
              // Step 1: Call API without confirmed flag to get proposal
              const proposalResponse = await fetch(`${API_BASE}/api/table/add-column`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  table_name: modifyTableName,
                  column_name: toolInput.column_name,
                  column_type: toolInput.column_type,
                  default_value: toolInput.default_value,
                  confirmed: false
                })
              });
              
              if (!proposalResponse.ok) {
                return JSON.stringify({
                  success: false,
                  error: `API error: ${proposalResponse.status} ${proposalResponse.statusText}`
                });
              }
              
              const proposalData = await proposalResponse.json();
              
              // Step 2: If confirmation required, show dialog
              if (proposalData.requires_confirmation) {
                const userApproved = await showSchemaChangeConfirmation(proposalData, toolInput.reason);
                
                if (!userApproved) {
                  return JSON.stringify({
                    success: false,
                    error: 'Schema modification cancelled by user',
                    message: 'User declined to add the column. You can try again with different parameters.'
                  });
                }
                
                // Step 3: User approved, execute the change with confirmed=true
                const executeResponse = await fetch(`${API_BASE}/api/table/add-column`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    table_name: modifyTableName,
                    column_name: toolInput.column_name,
                    column_type: toolInput.column_type,
                    default_value: toolInput.default_value,
                    confirmed: true
                  })
                });
                
                if (!executeResponse.ok) {
                  return JSON.stringify({
                    success: false,
                    error: `Failed to add column: ${executeResponse.status} ${executeResponse.statusText}`
                  });
                }
                
                const executeData = await executeResponse.json();
                
                // Refresh database tables in background if successful
                if (executeData.success) {
                  loadDatabaseTables().catch(err => console.warn('Background table refresh failed:', err));
                }
                
                return JSON.stringify(executeData);
              }
              
              // If no confirmation needed (shouldn't happen with current implementation)
              return JSON.stringify(proposalData);
              
            } catch (error) {
              console.error('modify_table_schema error:', error);
              return JSON.stringify({
                success: false,
                error: `Failed to modify schema: ${error.message}`
              });
            }
          
          case 'get_console_logs':
            // Get console logs from the preview iframe
            console.log(' get_console_logs tool called');
            console.log('   Total logs captured:', capturedConsoleLogs.length);
            console.log('   clear_after_reading:', toolInput.clear_after_reading);
            console.log('   last_n:', toolInput.last_n);
            
            const allLogs = getConsoleLogs(
              toolInput.clear_after_reading || false,
              toolInput.last_n || null
            );
            
            // ONLY return ERROR logs (filter out everything else)
            const logs = allLogs.filter(l => l.level === 'error');
            
            console.log('   Retrieved', allLogs.length, 'total logs from iframe');
            console.log('   Returning', logs.length, 'ERROR logs to AI (filtered)');
            
            // Format ERROR logs for AI consumption
            const formattedLogs = logs.map((log, index) => {
              const time = new Date(log.timestamp).toLocaleTimeString();
              return `${index + 1}. [${time}]  ${log.message}`;
            }).join('\n');
            
            const logsResult = {
              success: true,
              total_errors: logs.length,
              returned_logs: logs.length,
              summary: logs.length === 0 
                ? 'No errors detected - app is working correctly' 
                : `${logs.length} ERROR(S) detected in preview`,
              formatted_logs: formattedLogs,
              raw_logs: logs,
              message: logs.length === 0 
                ? 'No console errors captured. The app is working correctly with no JavaScript errors.'
                : ` ${logs.length} ERROR(S) FOUND in the preview! These indicate broken functionality that needs to be fixed.`
            };
            
            console.log(' Returning', logs.length, 'error logs to AI');
            if (formattedLogs) {
              console.log('   Error logs:\n' + formattedLogs);
            } else {
              console.log('    No errors - app working correctly');
            }
            return JSON.stringify(logsResult);
          
          case 'execute_javascript':
            // Execute JavaScript in the preview iframe for testing
            console.log(' execute_javascript tool called');
            console.log('   Description:', toolInput.description || 'No description');
            console.log('   Code length:', toolInput.code?.length || 0, 'chars');
            console.log('   Code:', toolInput.code);
            
            if (!toolInput.code || typeof toolInput.code !== 'string') {
              return JSON.stringify({
                success: false,
                error: 'code parameter is required and must be a string'
              });
            }
            
            try {
              const previewFrame = document.getElementById('previewFrame');
              
              if (!previewFrame || !previewFrame.contentWindow) {
                return JSON.stringify({
                  success: false,
                  error: 'Preview iframe not found or not loaded. Generate HTML first.'
                });
              }
              
              // Clear console logs before execution so we can see fresh output
              const logCountBefore = capturedConsoleLogs.length;
              
              // Execute the code in the iframe context
              try {
                // Use a wrapper to capture return value and any errors
                const wrappedCode = `
                  (function() {
                    try {
                      const result = (function() { ${toolInput.code} })();
                      if (result !== undefined) {
                        console.log('[execute_javascript result]:', result);
                      }
                      return { success: true, returned: result };
                    } catch (err) {
                      console.error('[execute_javascript error]:', err.message);
                      console.error('[execute_javascript stack]:', err.stack);
                      return { success: false, error: err.message, stack: err.stack };
                    }
                  })();
                `;
                
                const executionResult = previewFrame.contentWindow.eval(wrappedCode);
                
                // Wait a moment for console logs to be captured
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const logCountAfter = capturedConsoleLogs.length;
                const newLogs = capturedConsoleLogs.slice(logCountBefore);
                
                const formattedNewLogs = newLogs.map(log => {
                  return `[${log.timestamp}] [${log.level.toUpperCase()}] ${log.message}`;
                }).join('\n');
                
                console.log(' JavaScript executed successfully');
                console.log('   New logs captured:', newLogs.length);
                
                return JSON.stringify({
                  success: true,
                  execution_success: executionResult?.success !== false,
                  returned_value: executionResult?.returned,
                  error: executionResult?.error,
                  new_logs_count: newLogs.length,
                  new_logs: newLogs,
                  formatted_logs: formattedNewLogs,
                  message: executionResult?.success === false 
                    ? `Code executed but threw error: ${executionResult.error}`
                    : `Code executed successfully. ${newLogs.length} new console log(s) captured.`
                });
                
              } catch (evalError) {
                console.error(' JavaScript execution failed:', evalError);
                return JSON.stringify({
                  success: false,
                  error: `Execution failed: ${evalError.message}`,
                  hint: 'The code may have syntax errors or reference undefined variables/functions.'
                });
              }
              
            } catch (error) {
              console.error(' execute_javascript tool error:', error);
              return JSON.stringify({
                success: false,
                error: error.message || 'Unknown error occurred'
              });
            }
          
          case 'create_todo_list':
            console.log(' create_todo_list tool called');
            console.log('   Todos:', toolInput.todos);
            
            if (!toolInput.todos || !Array.isArray(toolInput.todos)) {
              return JSON.stringify({
                success: false,
                error: 'todos parameter is required and must be an array'
              });
            }
            
            // Store todos globally for tracking
            window.currentTodoList = toolInput.todos;
            
            // Display the todo list in the chat
            displayTodoList(toolInput.todos);
            
            return JSON.stringify({
              success: true,
              message: `Created todo list with ${toolInput.todos.length} items`,
              todos: toolInput.todos
            });
          
          case 'update_todo':
            console.log(' update_todo tool called');
            console.log('   Todo ID:', toolInput.id);
            console.log('   New status:', toolInput.status);
            
            if (!toolInput.id) {
              return JSON.stringify({
                success: false,
                error: 'id parameter is required'
              });
            }
            
            if (!window.currentTodoList || !Array.isArray(window.currentTodoList)) {
              return JSON.stringify({
                success: false,
                error: 'No todo list exists. Create one first with create_todo_list.'
              });
            }
            
            // Find and update the todo
            const todoIndex = window.currentTodoList.findIndex(t => t.id === toolInput.id);
            if (todoIndex === -1) {
              return JSON.stringify({
                success: false,
                error: `Todo with id "${toolInput.id}" not found`
              });
            }
            
            // Update the todo
            if (toolInput.status) {
              window.currentTodoList[todoIndex].status = toolInput.status;
            }
            if (toolInput.task) {
              window.currentTodoList[todoIndex].task = toolInput.task;
            }
            
            // Refresh the display
            displayTodoList(window.currentTodoList);
            
            return JSON.stringify({
              success: true,
              message: `Updated todo "${toolInput.id}"`,
              updated_todo: window.currentTodoList[todoIndex]
            });
          
          case 'verify_edit':
            //  VERIFICATION TOOL - Reads back the code to confirm changes were actually made
            console.log(' verify_edit tool called');
            console.log('   Verification token:', toolInput.verification_token);
            console.log('   Expected snippets:', toolInput.expected_snippets);
            
            if (!toolInput.verification_token) {
              return JSON.stringify({
                success: false,
                error: 'verification_token is required. This token is returned by update_html after successful edits.',
                hint: 'After calling update_html, use the verification_token from its response to verify your changes.'
              });
            }
            
            if (!toolInput.expected_snippets || !Array.isArray(toolInput.expected_snippets) || toolInput.expected_snippets.length === 0) {
              return JSON.stringify({
                success: false,
                error: 'expected_snippets is required and must be a non-empty array of strings to verify.',
                hint: 'Provide key text snippets from your new_string that should appear in the modified code.'
              });
            }
            
            // Decode the verification token (format: "lines:start-end|timestamp")
            const tokenParts = toolInput.verification_token.split('|');
            const linesPart = tokenParts[0];
            const timestampPart = tokenParts[1] || '';
            
            const linesMatch = linesPart.match(/lines:(\d+)-(\d+)/);
            if (!linesMatch) {
              return JSON.stringify({
                success: false,
                error: 'Invalid verification_token format. Must be in format "lines:start-end|timestamp"',
                received_token: toolInput.verification_token
              });
            }
            
            const verifyStartLine = parseInt(linesMatch[1]);
            const verifyEndLine = parseInt(linesMatch[2]);
            
            // Get the HTML lines to verify
            if (!generatedHTML) {
              return JSON.stringify({
                success: false,
                verified: false,
                error: 'No HTML exists to verify. The preview may have been cleared.'
              });
            }
            
            const verifyHtmlLines = generatedHTML.split('\n');
            const verifyStartIdx = Math.max(0, verifyStartLine - 1);
            const verifyEndIdx = Math.min(verifyHtmlLines.length - 1, verifyEndLine - 1 + 20); // Include extra context
            const relevantCode = verifyHtmlLines.slice(verifyStartIdx, verifyEndIdx + 1).join('\n');
            
            // Check each expected snippet
            const verificationResults = [];
            let allVerified = true;
            
            for (const snippet of toolInput.expected_snippets) {
              const found = relevantCode.includes(snippet);
              verificationResults.push({
                snippet: snippet.substring(0, 100) + (snippet.length > 100 ? '...' : ''),
                found: found,
                status: found ? ' VERIFIED' : ' NOT FOUND'
              });
              if (!found) {
                allVerified = false;
              }
            }
            
            // Generate verification proof
            const verificationProof = {
              verified: allVerified,
              verification_id: `VRF-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
              timestamp: new Date().toISOString(),
              lines_checked: `${verifyStartLine}-${verifyEndLine}`,
              actual_lines_in_file: verifyHtmlLines.length,
              snippets_verified: verificationResults.filter(r => r.found).length,
              snippets_total: toolInput.expected_snippets.length,
              results: verificationResults
            };
            
            // Add code preview as proof
            verificationProof.code_preview = relevantCode.substring(0, 500) + (relevantCode.length > 500 ? '\n... [truncated]' : '');
            
            if (allVerified) {
              console.log(' VERIFICATION PASSED - All expected snippets found in the code');
              
              // Display verification badge in chat
              setTimeout(() => {
                const badge = document.createElement('div');
                badge.className = 'verification-badge';
                badge.innerHTML = `
                  <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: linear-gradient(135deg, #10B981 0%, #059669 100%); border-radius: 8px; color: white; font-size: 12px; margin: 8px 0;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                      <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                    <span><strong>VERIFIED</strong> - Changes confirmed in code (${verificationProof.verification_id})</span>
                  </div>
                `;
                const chatMessages = document.getElementById('chatMessages');
                if (chatMessages && chatMessages.lastElementChild) {
                  chatMessages.lastElementChild.appendChild(badge);
                }
              }, 100);
              
              return JSON.stringify({
                success: true,
                verified: true,
                verification_proof: verificationProof,
                message: ` VERIFICATION COMPLETE: All ${toolInput.expected_snippets.length} expected snippet(s) were found in lines ${verifyStartLine}-${verifyEndLine}. Your changes have been CONFIRMED as successfully inserted.`,
                certification: `This edit has been verified and certified. Verification ID: ${verificationProof.verification_id}`
              });
            } else {
              console.error(' VERIFICATION FAILED - Some expected snippets were NOT found');
              
              return JSON.stringify({
                success: false,
                verified: false,
                verification_proof: verificationProof,
                message: ` VERIFICATION FAILED: Only ${verificationResults.filter(r => r.found).length}/${toolInput.expected_snippets.length} expected snippets were found. Your changes may NOT have been applied correctly.`,
                action_required: 'Review the results below. The changes you thought you made may not exist in the code. Use find_code_locations to see the actual code and retry the update.',
                failed_snippets: verificationResults.filter(r => !r.found).map(r => r.snippet)
              });
            }
          
          case 'analyze_css_scope':
            //  CSS SCOPE ANALYSIS - Check what elements are affected by a selector
            console.log(' analyze_css_scope tool called');
            console.log('   Selector:', toolInput.selector);
            console.log('   Target description:', toolInput.target_description);
            console.log('   Proposed property:', toolInput.proposed_property || '(not specified)');
            
            if (!toolInput.selector) {
              return JSON.stringify({
                success: false,
                error: 'selector is required. Provide the CSS selector you plan to modify (e.g., ".btn", "#header")'
              });
            }
            
            if (!toolInput.target_description) {
              return JSON.stringify({
                success: false,
                error: 'target_description is required. Describe what specific element you intend to style.'
              });
            }
            
            try {
              const previewFrame = document.getElementById('previewFrame');
              if (!previewFrame || !previewFrame.contentWindow || !previewFrame.contentDocument) {
                return JSON.stringify({
                  success: false,
                  error: 'Preview not available. Generate or load HTML first.'
                });
              }
              
              const doc = previewFrame.contentDocument;
              const cssSelector = toolInput.selector;
              
              // Find all elements matching the selector
              let matchedElements;
              try {
                matchedElements = doc.querySelectorAll(cssSelector);
              } catch (selectorError) {
                return JSON.stringify({
                  success: false,
                  error: `Invalid CSS selector: ${cssSelector}`,
                  hint: 'Check selector syntax. Common issues: missing dots for classes, missing # for IDs'
                });
              }
              
              // Analyze each matched element
              const elementAnalysis = Array.from(matchedElements).map((el, idx) => {
                // Determine component/section by finding nearest parent with an ID or semantic class
                let componentContext = 'unknown';
                let parent = el.parentElement;
                const parentChain = [];
                while (parent && parent !== doc.body) {
                  if (parent.id) {
                    componentContext = `#${parent.id}`;
                    break;
                  }
                  if (parent.className) {
                    const classes = parent.className.split(' ').filter(c => 
                      c && !c.match(/^(flex|grid|hidden|block|inline|relative|absolute|p-|m-|w-|h-|text-|bg-|border-)/)
                    );
                    if (classes.length > 0) {
                      componentContext = `.${classes[0]}`;
                      break;
                    }
                  }
                  parentChain.push(parent.tagName.toLowerCase());
                  parent = parent.parentElement;
                }
                
                // Get current computed styles for the proposed property
                const computedStyle = previewFrame.contentWindow.getComputedStyle(el);
                const currentValue = toolInput.proposed_property 
                  ? computedStyle.getPropertyValue(toolInput.proposed_property) 
                  : '(no property specified)';
                
                return {
                  index: idx + 1,
                  tagName: el.tagName.toLowerCase(),
                  id: el.id || null,
                  classes: el.className || '(no classes)',
                  textPreview: (el.textContent || '').trim().substring(0, 40) || '(empty)',
                  component: componentContext,
                  parentChain: parentChain.slice(0, 3).join(' > ') || '(body)',
                  currentValue: currentValue
                };
              });
              
              // Analyze scope safety
              const uniqueComponents = [...new Set(elementAnalysis.map(e => e.component))];
              const isSingleComponent = uniqueComponents.length <= 1;
              const affectsMultipleSections = uniqueComponents.length > 1;
              
              // Determine safety level
              let safetyLevel, recommendation;
              if (matchedElements.length === 0) {
                safetyLevel = ' NO MATCH';
                recommendation = 'No elements match this selector. Check if the selector is correct.';
              } else if (matchedElements.length === 1) {
                safetyLevel = ' SAFE';
                recommendation = 'Only one element matches. Safe to modify this selector directly.';
              } else if (isSingleComponent) {
                safetyLevel = ' SAFE';
                recommendation = `Multiple elements (${matchedElements.length}) but all in the same component (${uniqueComponents[0]}). Safe to modify.`;
              } else {
                safetyLevel = ' DANGEROUS';
                recommendation = `This selector affects ${matchedElements.length} elements across ${uniqueComponents.length} DIFFERENT components: ${uniqueComponents.join(', ')}. DO NOT modify this selector directly! Instead, add a more specific selector.`;
              }
              
              // Generate specific selector suggestions if dangerous
              const selectorSuggestions = [];
              if (affectsMultipleSections && elementAnalysis.length > 0) {
                // Suggest scoped selectors based on components
                uniqueComponents.forEach(comp => {
                  if (comp !== 'unknown') {
                    selectorSuggestions.push(`${comp} ${cssSelector}`);
                  }
                });
                // Suggest adding a unique class
                selectorSuggestions.push(`${cssSelector}-${toolInput.target_description.replace(/\s+/g, '-').toLowerCase().substring(0, 20)}`);
              }
              
              console.log(` CSS Scope Analysis: ${matchedElements.length} elements, Safety: ${safetyLevel}`);
              
              return JSON.stringify({
                success: true,
                selector: cssSelector,
                target_description: toolInput.target_description,
                proposed_property: toolInput.proposed_property || '(not specified)',
                analysis: {
                  total_elements_affected: matchedElements.length,
                  unique_components: uniqueComponents,
                  components_count: uniqueComponents.length,
                  safety_level: safetyLevel,
                  recommendation: recommendation
                },
                elements: elementAnalysis.slice(0, 15), // Limit to first 15
                warning: affectsMultipleSections 
                  ? ` STOP! This selector affects UNRELATED components. Modifying "${cssSelector}" will change styles in: ${uniqueComponents.join(', ')}. You MUST use a more specific selector!`
                  : null,
                suggested_specific_selectors: selectorSuggestions.length > 0 ? selectorSuggestions : undefined,
                action: affectsMultipleSections
                  ? 'DO NOT modify this selector. Use one of the suggested_specific_selectors instead, or add a unique class to your target element.'
                  : 'Safe to proceed with modifying this selector.'
              });
              
            } catch (cssError) {
              console.error('CSS scope analysis error:', cssError);
              return JSON.stringify({
                success: false,
                error: cssError.message || 'Failed to analyze CSS scope'
              });
            }
          
          default:
            return JSON.stringify({ 
              success: false,
              error: `Unknown tool: ${toolName}` 
            });
        }
      } catch (error) {
        console.error(`Error in ${toolName}:`, error);
        return JSON.stringify({ 
          success: false,
          error: error.message || 'Unknown error occurred' 
        });
      }
    }
    
    // ===== CHAT HISTORY PERSISTENCE =====
    
    /**
     * Summarize loaded chat history for context injection into first API call
     * This creates a concise summary of what was discussed/built in previous sessions
     */
    function summarizeChatHistory(history) {
      if (!history || history.length === 0) return '';
      
      // Extract key information from conversation history
      const userRequests = [];
      const assistantActions = [];
      const toolsUsed = new Set();
      const tablesCreated = new Set();
      
      history.forEach(msg => {
        if (msg.role === 'user') {
          // Extract text content from user messages
          let textContent = '';
          if (typeof msg.content === 'string') {
            textContent = msg.content;
          } else if (Array.isArray(msg.content)) {
            const textBlock = msg.content.find(b => b.type === 'text');
            if (textBlock) textContent = textBlock.text;
          }
          
          // Skip tool results and very long HTML content
          if (textContent && 
              !textContent.includes('tool_result') && 
              !textContent.startsWith('---CURRENT HTML---') &&
              textContent.length < 2000) {
            // Extract the USER REQUEST part if present
            const requestMatch = textContent.match(/USER REQUEST:\s*(.+?)(?:\n|$)/);
            if (requestMatch) {
              userRequests.push(requestMatch[1].trim().substring(0, 200));
            } else if (!textContent.includes('MANDATORY WORKFLOW') && !textContent.includes('')) {
              // Add short user messages that aren't system prompts
              const shortContent = textContent.split('\n')[0].substring(0, 200);
              if (shortContent.length > 10) {
                userRequests.push(shortContent);
              }
            }
          }
        } else if (msg.role === 'assistant' && Array.isArray(msg.content)) {
          // Track tools used and text responses
          msg.content.forEach(block => {
            if (block.type === 'tool_use') {
              toolsUsed.add(block.name);
              
              // Track table creation
              if (block.name === 'create_table' && block.input?.table_name) {
                tablesCreated.add(block.input.table_name);
              }
            } else if (block.type === 'text' && block.text) {
              // Extract short summaries from assistant text
              const shortText = block.text.substring(0, 150);
              if (shortText.length > 20 && !shortText.includes('```') && !shortText.includes('tool_result')) {
                assistantActions.push(shortText);
              }
            }
          });
        }
      });
      
      // Build the summary
      let summary = '=== PREVIOUS SESSION CONTEXT ===\n';
      summary += 'This is a continuation of a previous conversation. Here\'s what was done:\n\n';
      
      if (userRequests.length > 0) {
        summary += ' USER REQUESTS FROM PREVIOUS SESSION:\n';
        // Keep last 5 unique requests
        const uniqueRequests = [...new Set(userRequests)].slice(-5);
        uniqueRequests.forEach((req, i) => {
          summary += `  ${i + 1}. ${req}\n`;
        });
        summary += '\n';
      }
      
      if (tablesCreated.size > 0) {
        summary += ' DATABASE TABLES CREATED:\n';
        tablesCreated.forEach(table => {
          summary += `  - ${table}\n`;
        });
        summary += '\n';
      }
      
      if (toolsUsed.size > 0) {
        summary += ' TOOLS PREVIOUSLY USED:\n';
        summary += `  ${[...toolsUsed].join(', ')}\n\n`;
      }
      
      if (assistantActions.length > 0) {
        summary += ' ASSISTANT ACTIONS:\n';
        // Keep last 3 actions
        assistantActions.slice(-3).forEach((action, i) => {
          summary += `  ${i + 1}. ${action}...\n`;
        });
        summary += '\n';
      }
      
      summary += '=== END PREVIOUS SESSION CONTEXT ===\n\n';
      summary += 'Continue from where we left off. The user\'s new request follows:\n\n';
      
      return summary;
    }
    
    /**
     * Generate summary from UI messages when conversation history is not available
     * This is a fallback for when the API conversation history wasn't saved properly
     */
    function generateUIMessagesSummary(uiMessages) {
      if (!uiMessages || uiMessages.length === 0) return '';
      
      const userMessages = uiMessages
        .filter(msg => msg.role === 'user' && msg.content)
        .map(msg => msg.content.substring(0, 200))
        .slice(-5); // Last 5 user messages
      
      if (userMessages.length === 0) return '';
      
      let summary = '=== PREVIOUS SESSION CONTEXT ===\n';
      summary += 'This is a continuation of a previous conversation. Here\'s what was discussed:\n\n';
      summary += ' RECENT USER REQUESTS:\n';
      userMessages.forEach((msg, i) => {
        summary += `  ${i + 1}. ${msg}${msg.length >= 200 ? '...' : ''}\n`;
      });
      summary += '\n=== END PREVIOUS SESSION CONTEXT ===\n\n';
      summary += 'Continue from where we left off. The user\'s new request follows:\n\n';
      
      return summary;
    }
    
    async function saveChatHistory() {
      if (!currentProjectId) {
        console.log('No project selected - chat history not saved');
        return;
      }
      
      // Don't save if both arrays are empty - avoid overwriting good data
      if (chatConversationHistory.length === 0 && chatUIMessages.length === 0) {
        return;
      }
      
      try {
        const tableName = `${currentProjectId}_chat_history`;
        const chatHistoryData = {
          project_session: 'default', // Single session per project
          conversation_history: JSON.stringify(chatConversationHistory),
          ui_messages: JSON.stringify(chatUIMessages),
          timestamp: new Date().toISOString()
        };
        
        // Check if chat history already exists
        const checkResponse = await fetch(`${API_BASE}/api/table/query`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            table_name: tableName,
            where_clause: "project_session = 'default'",
            limit: 1
          })
        });
        
        if (checkResponse.ok) {
          const checkData = await checkResponse.json();
          
          if (checkData.success && checkData.data && checkData.data.length > 0) {
            // Update existing chat history
            const updateResponse = await fetch(`${API_BASE}/api/table/update`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                table_name: tableName,
                data: {
                  conversation_history: chatHistoryData.conversation_history,
                  ui_messages: chatHistoryData.ui_messages,
                  timestamp: chatHistoryData.timestamp
                },
                where_clause: "project_session = 'default'"
              })
            });
            
            if (updateResponse.ok) {
              console.log(' Chat history updated successfully');
            } else {
              console.warn('Failed to update chat history:', updateResponse.status);
            }
          } else {
            // Insert new chat history
            const insertResponse = await fetch(`${API_BASE}/api/table/insert`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                table_name: tableName,
                data: chatHistoryData
              })
            });
            
            if (insertResponse.ok) {
              console.log(' Chat history saved successfully');
            } else {
              console.warn('Failed to insert chat history:', insertResponse.status);
            }
          }
        }
      } catch (error) {
        console.warn('Error saving chat history:', error);
      }
    }
    
    // Track chat history loading state to prevent race conditions
    let chatHistoryLoadingPromise = null;
    
    async function loadChatHistory(signal = null) {
      if (!currentProjectId) {
        console.log('No project selected - no chat history to load');
        return;
      }
      
      try {
        // Try to load from project's chat_history table
        const fetchOptions = {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            table_name: `${currentProjectId}_chat_history`,
            where_clause: "project_session = 'default'",
            limit: 1
          })
        };
        
        // Add abort signal if provided
        if (signal) {
          fetchOptions.signal = signal;
        }
        
        const response = await fetch(`${API_BASE}/api/table/query`, fetchOptions);
        
        if (!response.ok) {
          console.log('No chat history found for this project - starting fresh');
          const chatMessages = document.getElementById('chatMessages');
          if (chatMessages && chatMessages.innerHTML === '') {
            chatMessages.innerHTML = '<div class="chat-message assistant"><span>Ready to build. Ask me to create any web application.</span></div>';
          }
          return;
        }
        
        const result = await response.json();
        
        if (result.success && result.data && result.data.length > 0) {
          const chatData = result.data[0];
          
          // Restore conversation history
          if (chatData.conversation_history && chatData.conversation_history.trim() !== '' && chatData.conversation_history.trim() !== '[]') {
            try {
              const parsedHistory = JSON.parse(chatData.conversation_history);
              
              // Only use if it has actual content
              if (Array.isArray(parsedHistory) && parsedHistory.length > 0) {
                chatConversationHistory = parsedHistory;
                loadedChatHistory = [...parsedHistory];
                loadedChatHistorySummary = summarizeChatHistory(parsedHistory);
                needsHistorySummaryInjection = true;
                console.log(` Loaded ${chatConversationHistory.length} conversation messages`);
                console.log(` Summary generated (${loadedChatHistorySummary.length} chars):`, loadedChatHistorySummary.substring(0, 200) + '...');
                console.log(` needsHistorySummaryInjection set to:`, needsHistorySummaryInjection);
              } else {
                loadedChatHistory = [];
                loadedChatHistorySummary = '';
                needsHistorySummaryInjection = false;
              }
              
              // Scan loaded conversation to check if it contains full HTML
              conversationHasFullHTML = false; // Start with false
              for (let i = chatConversationHistory.length - 1; i >= 0; i--) {
                const msg = chatConversationHistory[i];
                if (msg.role === 'user') {
                  const textContent = typeof msg.content === 'string' 
                    ? msg.content 
                    : (Array.isArray(msg.content) ? msg.content.find(block => block.type === 'text')?.text : '');
                  
                  if (textContent && textContent.includes('---CURRENT HTML---')) {
                    conversationHasFullHTML = true;
                    break; // Found one, stop looking
                  }
                }
              }
            } catch (e) {
              console.warn('Failed to parse conversation history:', e);
              chatConversationHistory = [];
              loadedChatHistory = [];
              loadedChatHistorySummary = '';
              needsHistorySummaryInjection = false;
              conversationHasFullHTML = false;
            }
          }
          
          // Restore UI messages and rebuild chat UI
          if (chatData.ui_messages) {
            try {
              chatUIMessages = JSON.parse(chatData.ui_messages);
              console.log(` Loaded ${chatUIMessages.length} UI messages`);
              
              // Update currentVersionNumber from loaded messages to continue from where we left off
              let maxVersionFromHistory = 0;
              chatUIMessages.forEach(msg => {
                if (msg.versionNumber && typeof msg.versionNumber === 'number' && msg.versionNumber > maxVersionFromHistory) {
                  maxVersionFromHistory = msg.versionNumber;
                }
              });
              if (maxVersionFromHistory > currentVersionNumber) {
                console.log(` Updating currentVersionNumber from chat history: ${currentVersionNumber}  ${maxVersionFromHistory}`);
                currentVersionNumber = maxVersionFromHistory;
              }
              
              // Rebuild chat UI from saved messages
              const chatMessages = document.getElementById('chatMessages');
              if (!chatMessages) {
                console.error(' chatMessages element not found!');
                return;
              }
              
              console.log(' Clearing chat UI...');
              chatMessages.innerHTML = ''; // Clear first
              
              // Add welcome message
              chatMessages.innerHTML = '<div class="chat-message assistant"><span>Ready to build. Ask me to create any web application.</span></div>';
              console.log(' Added welcome message');
              
              // Add all saved messages
              console.log(` Adding ${chatUIMessages.length} messages to chat UI...`);
              chatUIMessages.forEach((msg, index) => {
                console.log(`  Adding message ${index + 1}:`, msg.role, msg.content?.substring(0, 50) + '...');
                addMessageToChat(msg.role, msg.content, msg.versionNumber, true, msg.imageData);
              });
              
              console.log(' Chat history restored successfully');
            } catch (e) {
              console.error(' Failed to parse UI messages:', e);
              chatUIMessages = [];
            }
          } else {
            console.log(' No UI messages in saved data');
            // No UI messages - show welcome
            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages && chatMessages.innerHTML === '') {
              chatMessages.innerHTML = '<div class="chat-message assistant"><span>Ready to build. Ask me to create any web application.</span></div>';
            }
          }
        } else {
          console.log('No chat history data found - starting fresh');
          // Add welcome message for new project
          const chatMessages = document.getElementById('chatMessages');
          if (chatMessages && chatMessages.innerHTML === '') {
            chatMessages.innerHTML = '<div class="chat-message assistant"><span>Ready to build. Ask me to create any web application.</span></div>';
          }
        }
      } catch (error) {
        console.warn('Error loading chat history:', error);
        // Show welcome message on error
        const chatMessages = document.getElementById('chatMessages');
        if (chatMessages && chatMessages.innerHTML === '') {
          chatMessages.innerHTML = '<div class="chat-message assistant"><span>Ready to build. Ask me to create any web application.</span></div>';
        }
      }
    }
    
    async function saveToBigQuery(projectName, htmlContent, cacheId, versionNumber) {
      console.log(`\n === SAVE TO BIGQUERY FUNCTION CALLED ===`);
      console.log(`   Function parameters:`);
      console.log(`     - projectName: "${projectName}"`);
      console.log(`     - cacheId: "${cacheId}"`);
      console.log(`     - versionNumber: ${versionNumber}`);
      console.log(`     - htmlContent length: ${htmlContent?.length || 0} chars`);
      console.log(`   Global state:`);
      console.log(`     - currentProjectId: ${currentProjectId || 'NOT SET'}`);
      console.log(`     - allProjects count: ${allProjects?.length || 0}`);
      
      try {
        let endpoint, requestBody;
        
        // If a project is selected, save to project's html_cache table
        if (currentProjectId) {
          endpoint = `${API_BASE}/api/project/html/save`;
          requestBody = {
            project_id: currentProjectId,
            cache_id: cacheId || projectName.toLowerCase().replace(/\s+/g, '-'),
            page_name: projectName,
            html_content: htmlContent,
            version: (versionNumber !== null && versionNumber !== undefined) ? versionNumber.toString() : undefined
          };
          console.log(` Using PROJECT-SPECIFIC save`);
          console.log(`   - Endpoint: ${endpoint}`);
          console.log(`   - Target table: ${currentProjectId}_html_cache`);
          console.log(`   - Request body keys: ${Object.keys(requestBody).join(', ')}`);
        } else {
          // Fallback to global dashboard_html_cache
          endpoint = `${API_BASE}/api/html/save`;
          requestBody = {
            cache_id: cacheId || projectName.toLowerCase().replace(/\s+/g, '-'),
            page_name: projectName,
            html_content: htmlContent,
            version: (versionNumber !== null && versionNumber !== undefined) ? versionNumber.toString() : undefined
          };
          console.warn(`  Using GLOBAL save (no project selected!)`);
          console.log(`   - Endpoint: ${endpoint}`);
          console.log(`   - Target table: dashboard_html_cache`);
          console.log(`   - Request body keys: ${Object.keys(requestBody).join(', ')}`);
        }
        
        console.log(` Sending POST request to ${endpoint}...`);
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });
        
        console.log(` Response received: ${response.status} ${response.statusText}`);
        
        if (response.ok) {
          const data = await response.json();
          lastSaveTime = new Date();
          const statusElement = document.querySelector('.project-status');
          if (statusElement) {
            statusElement.textContent = `Last saved: ${lastSaveTime.toLocaleTimeString()}`;
          }
          console.log(' Save to BigQuery SUCCESSFUL');
          console.log('   Response:', data);
          console.log(`   Actual cache_id created: ${data.cache_id}`);
          console.log(`   Table: ${currentProjectId ? currentProjectId + '_html_cache' : 'dashboard_html_cache'}`);
          console.log(`=========================================\n`);
          loadOverviewData(); // Refresh projects
          
          // Reload versions from database to update navigation
          if (currentProjectId) {
            await loadDBVersions();
          }
          
          return data; // Return data so callers can use the cache_id
        } else {
          // Throw error so caller can handle it
          const errorText = await response.text();
          console.error(' Save to BigQuery FAILED');
          console.error(`   Status: ${response.status} ${response.statusText}`);
          console.error('   Response body:', errorText.substring(0, 500));
          console.error(`=========================================\n`);
          throw new Error(`Save failed: ${response.status} - ${errorText.substring(0, 200)}`);
        }
      } catch (error) {
        console.error(' EXCEPTION in saveToBigQuery:');
        console.error('   Error type:', error.constructor.name);
        console.error('   Error message:', error.message);
        console.error('   Stack:', error.stack?.substring(0, 300));
        console.error(`=========================================\n`);
        throw error; // Re-throw so caller can handle it
      }
    }
    
    
    function updateCodeView(htmlContent) {
      const codeContent = document.getElementById('codeContent');
      
      // For large files (>50KB), use chunked rendering to prevent freezing
      if (htmlContent.length > 50000) {
        // Show loading indicator
        codeContent.innerHTML = '<code style="color: #666;">Loading code... (large file)</code>';
        
        // Chunk the escaping and rendering
        requestAnimationFrame(() => {
          const chunkSize = 10000; // Process 10KB at a time
          let escaped = '';
          
          for (let i = 0; i < htmlContent.length; i += chunkSize) {
            const chunk = htmlContent.slice(i, i + chunkSize);
            escaped += chunk
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;');
          }
          
          // Set the content once all chunks are processed
          codeContent.innerHTML = `<code>${escaped}</code>`;
        });
      } else {
        // Small files: render immediately
        const escapedHTML = htmlContent
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
        codeContent.innerHTML = `<code>${escapedHTML}</code>`;
      }
      
      // Exit edit mode if active
      if (codeContent.contentEditable === 'true') {
        codeContent.contentEditable = 'false';
        document.getElementById('editCodeBtn').style.display = 'inline-flex';
        document.getElementById('saveCodeBtn').style.display = 'none';
        document.getElementById('revertCodeBtn').style.display = 'none';
      }
    }
    
    // Store original HTML before editing
    let originalCodeBeforeEdit = null;
    
    function toggleCodeEdit() {
      const codeContent = document.getElementById('codeContent');
      const editBtn = document.getElementById('editCodeBtn');
      const saveBtn = document.getElementById('saveCodeBtn');
      const revertBtn = document.getElementById('revertCodeBtn');
      
      if (!generatedHTML || generatedHTML.trim() === '') {
        addMessageToChat('system', ' No code to edit. Generate some HTML first!');
        return;
      }
      
      // Store original HTML
      originalCodeBeforeEdit = generatedHTML;
      
      // Make content editable - set to plain text
      codeContent.contentEditable = 'plaintext-only';
      codeContent.focus();
      
      // Show save/revert buttons, hide edit button
      editBtn.style.display = 'none';
      saveBtn.style.display = 'inline-flex';
      revertBtn.style.display = 'inline-flex';
      
      addMessageToChat('system', ' Edit mode enabled. Make your changes and click Save.');
    }
    
    function revertCodeChanges() {
      const codeContent = document.getElementById('codeContent');
      const editBtn = document.getElementById('editCodeBtn');
      const saveBtn = document.getElementById('saveCodeBtn');
      const revertBtn = document.getElementById('revertCodeBtn');
      
      // Restore original HTML
      if (originalCodeBeforeEdit) {
        updateCodeView(originalCodeBeforeEdit);
      }
      
      // Exit edit mode
      codeContent.contentEditable = 'false';
      editBtn.style.display = 'inline-flex';
      saveBtn.style.display = 'none';
      revertBtn.style.display = 'none';
      
      addMessageToChat('system', ' Changes reverted.');
    }
    
    async function saveCodeChanges() {
      const codeContent = document.getElementById('codeContent');
      const editBtn = document.getElementById('editCodeBtn');
      const saveBtn = document.getElementById('saveCodeBtn');
      const revertBtn = document.getElementById('revertCodeBtn');
      
      // Get the edited text content and unescape HTML entities
      const editedText = codeContent.textContent || codeContent.innerText || '';
      
      // Update the global HTML variable (allow empty code)
      generatedHTML = editedText;
      
      // Update preview
      console.log(' Updating preview with manually edited code...');
      const preview = document.getElementById('previewFrame');
      const loading = document.getElementById('previewLoading');
      
      loading.classList.remove('hidden');
      preview.classList.remove('loaded');
      
      setTimeout(() => {
        preview.srcdoc = wrapHTMLWithConsoleCapture(generatedHTML);
        preview.onload = () => {
          loading.classList.add('hidden');
          preview.classList.add('loaded');
          console.log(' Preview updated with manual edits');
        };
      }, 50);
      
      // Update code view to refresh display
      updateCodeView(generatedHTML);
      
      // Exit edit mode
      codeContent.contentEditable = 'false';
      editBtn.style.display = 'inline-flex';
      saveBtn.style.display = 'none';
      revertBtn.style.display = 'none';
      
      // Save to version history
      const lastVersion = versionHistory[versionHistory.length - 1];
      const alreadySaved = lastVersion && lastVersion.html === generatedHTML;
      
      if (!alreadySaved) {
        versionHistory.push({
          html: generatedHTML,
          timestamp: Date.now(),
          description: 'Manual code edit'
        });
        currentVersionIndex = versionHistory.length - 1;
        updateChatVersionButtons();
      }
      
      // Auto-save to BigQuery
      try {
        const projectNameForSave = allProjects[0]?.project_name || 'App Builder Project';
        const uniqueCacheId = `${projectNameForSave.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}`;
        console.log(` Auto-saving manual edits to BigQuery...`);
        
        currentVersionNumber++;
        await saveToBigQuery(projectNameForSave, generatedHTML, uniqueCacheId, currentVersionNumber);
        console.log(` Manual edits saved to BigQuery (version ${currentVersionNumber})`);
        
        addMessageToChat('system', ' Code changes saved and preview updated!');
      } catch (saveError) {
        console.error(' Failed to save manual edits:', saveError);
        currentVersionNumber--;
        addMessageToChat('system', ' Code changes applied to preview (but database save failed)');
      }
    }
    
    // ===== DATA LOADING =====
    async function loadOverviewData() {
      try {
        const response = await fetch(`${API_BASE}/api/html/list`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({})
        });
        
        if (response.ok) {
          const data = await response.json();
          renderProjectsGrid(data.pages || []);
        }
      } catch (error) {
        console.error('Load overview error:', error);
      }
    }
    
    function renderProjectsGrid(projects) {
      const grid = document.getElementById('projectsGrid');
      
      if (projects.length === 0) {
        grid.innerHTML = `
          <div class="empty-state">
            <i data-lucide="folder-open"></i>
            <h3>No projects yet</h3>
            <p>Ask the AI to build something to get started!</p>
          </div>
        `;
      } else {
        grid.innerHTML = projects.map(project => `
          <div class="table-card" onclick="loadProjectById('${project.cache_id}')">
            <div class="card-icon">
              <i data-lucide="file-code"></i>
            </div>
            <h3>${project.page_name}</h3>
            <p class="row-count">Updated: ${new Date(project.last_updated).toLocaleDateString()}</p>
          </div>
        `).join('');
      }
      
      initLucideIcons();
    }
    
    async function loadDatabaseTables() {
      const grid = document.getElementById('tablesGrid');
      
      try {
        let tables = [];
        
        // Update page subtitle with dataset info
        const pageSubtitle = document.getElementById('databaseSubtitle');
        const sectionSubtitle = document.getElementById('databaseSectionSubtitle');
        
        // If a project is selected, load project-specific tables
        if (currentProjectId) {
          const projectTables = await getProjectTables();
          tables = projectTables;
          
          // Update subtitles to show project context
          const project = allProjects.find(p => p.project_id === currentProjectId);
          if (project) {
            if (pageSubtitle) {
              pageSubtitle.textContent = `Dataset: digital_connection | Project: ${project.project_name}`;
            }
            if (sectionSubtitle) {
              sectionSubtitle.textContent = `Dataset: digital_connection | Project: ${project.project_name} (${currentProjectId})`;
            }
          }
        } else {
          // Load all tables
          const response = await fetch(`${API_BASE}/api/tables`);
          const data = await response.json();
          tables = data.tables || [];
          
          // Reset subtitles to show only dataset
          if (pageSubtitle) {
            pageSubtitle.textContent = 'View and manage your BigQuery tables';
          }
          if (sectionSubtitle) {
            sectionSubtitle.textContent = 'Dataset: digital_connection (all tables)';
          }
        }
        
        if (tables.length > 0) {
          grid.innerHTML = tables.map(table => `
            <div class="table-card" onclick="viewTable('${table.name}')">
              <div class="card-icon">
                <i data-lucide="table"></i>
              </div>
              <h3>${table.display_name || table.name}</h3>
              <p class="row-count">${table.row_count || 0} rows</p>
            </div>
          `).join('');
        } else {
          const message = currentProjectId 
            ? `No tables in this project yet.<br><br>Click "Create Table" in the Database view to add tables.`
            : 'No tables found';
          
          grid.innerHTML = `
            <div class="empty-state">
              <i data-lucide="database"></i>
              <h3>${currentProjectId ? 'No tables yet' : 'No tables found'}</h3>
              ${currentProjectId ? '<p>Create tables for this project</p>' : ''}
            </div>
          `;
        }
        
        initLucideIcons();
      } catch (error) {
        console.error('Load tables error:', error);
      }
    }
    
    // ===== UTILITY FUNCTIONS =====
    function refreshPreview() {
      if (generatedHTML) {
        const preview = document.getElementById('previewFrame');
        // No PROJECT_ID replacement - the generated app auto-discovers it on load
        console.log(' Refreshing preview - PROJECT_ID will auto-discover from tables');
        preview.srcdoc = wrapHTMLWithConsoleCapture(generatedHTML);
        
        // Re-inject element selector if active after iframe loads
        if (elementSelectorActive) {
          preview.onload = function() {
            setTimeout(() => {
              injectElementSelectorIntoPreview();
            }, 100);
          };
        }
      }
    }
    
    function openInNewTab() {
      if (generatedHTML) {
        const win = window.open();
        win.document.write(generatedHTML);
        win.document.close();
      }
    }
    
    function toggleFullscreen() {
      const container = document.querySelector('.preview-container');
      if (!document.fullscreenElement) {
        container.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    }
    
    // ========================================
    // ELEMENT SELECTOR FEATURE
    // ========================================
    
    let elementSelectorActive = false;
    let selectedElementContext = null;
    
    function toggleElementSelector() {
      elementSelectorActive = !elementSelectorActive;
      const btn = document.getElementById('elementSelectorBtn');
      const hint = document.getElementById('elementSelectorHint');
      
      if (elementSelectorActive) {
        btn.classList.add('element-selector-active');
        hint.style.display = 'flex';
        injectElementSelectorIntoPreview();
        console.log(' Element selector activated');
      } else {
        btn.classList.remove('element-selector-active');
        hint.style.display = 'none';
        removeElementSelectorFromPreview();
        console.log(' Element selector deactivated');
      }
      
      // Re-initialize icons
      if (typeof lucide !== 'undefined') {
        lucide.createIcons();
      }
    }
    
    function injectElementSelectorIntoPreview() {
      const preview = document.getElementById('previewFrame');
      if (!preview || !preview.contentWindow || !preview.contentDocument) {
        console.warn('Preview iframe not ready for element selector');
        return;
      }
      
      try {
        const iframeDoc = preview.contentDocument;
        const iframeWin = preview.contentWindow;
        
        // Remove existing if any
        const existingStyles = iframeDoc.getElementById('element-selector-styles');
        const existingOverlay = iframeDoc.getElementById('element-selector-overlay');
        if (existingStyles) existingStyles.remove();
        if (existingOverlay) existingOverlay.remove();
        
        // Inject CSS styles for highlighting
        const style = iframeDoc.createElement('style');
        style.id = 'element-selector-styles';
        style.textContent = `
          .element-selector-highlight {
            outline: 2px solid #0053E2 !important;
            outline-offset: 2px !important;
            background-color: rgba(0, 83, 226, 0.05) !important;
            cursor: crosshair !important;
            transition: all 0.1s ease !important;
          }
          
          .element-selector-selected {
            outline: 3px solid #10B981 !important;
            outline-offset: 2px !important;
            background-color: rgba(16, 185, 129, 0.1) !important;
          }
          
          #element-selector-tooltip {
            position: fixed;
            z-index: 999999;
            background: linear-gradient(135deg, #001E60, #0053E2);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 12px;
            pointer-events: none;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 350px;
            word-wrap: break-word;
            opacity: 0;
            transform: translateY(5px);
            transition: opacity 0.15s ease, transform 0.15s ease;
          }
          
          #element-selector-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
          }
          
          #element-selector-tooltip .tooltip-tag {
            font-weight: bold;
            color: #FFC220;
            font-size: 13px;
          }
          
          #element-selector-tooltip .tooltip-id {
            color: #4DBDF5;
          }
          
          #element-selector-tooltip .tooltip-class {
            color: #10B981;
          }
          
          #element-selector-tooltip .tooltip-text {
            color: rgba(255, 255, 255, 0.8);
            font-size: 11px;
            margin-top: 4px;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
          }
          
          #element-selector-tooltip .tooltip-hint {
            color: rgba(255, 255, 255, 0.6);
            font-size: 10px;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
          }
          
          * {
            cursor: crosshair !important;
          }
        `;
        iframeDoc.head.appendChild(style);
        
        // Create tooltip element
        const tooltip = iframeDoc.createElement('div');
        tooltip.id = 'element-selector-tooltip';
        iframeDoc.body.appendChild(tooltip);
        
        // Store last hovered element
        iframeWin.__elementSelectorLastHovered = null;
        
        // Mouse move handler for highlighting
        iframeWin.__elementSelectorMouseMove = function(e) {
          const el = e.target;
          
          // Skip tooltip and already selected elements
          if (el.id === 'element-selector-tooltip' || el.classList.contains('element-selector-selected')) {
            return;
          }
          
          // Remove highlight from previous element
          if (iframeWin.__elementSelectorLastHovered && iframeWin.__elementSelectorLastHovered !== el) {
            iframeWin.__elementSelectorLastHovered.classList.remove('element-selector-highlight');
          }
          
          // Add highlight to current element
          el.classList.add('element-selector-highlight');
          iframeWin.__elementSelectorLastHovered = el;
          
          // Update tooltip content
          const tagName = el.tagName.toLowerCase();
          const id = el.id ? `#${el.id}` : '';
          const classes = el.className && typeof el.className === 'string' 
            ? el.className.split(' ').filter(c => c && !c.includes('element-selector')).map(c => `.${c}`).join('')
            : '';
          const textContent = el.textContent ? el.textContent.trim().substring(0, 50) : '';
          const textPreview = textContent ? (textContent.length > 50 ? textContent + '...' : textContent) : '';
          
          var tooltipHTML = '<div class="tooltip-tag">&lt;' + tagName + '&gt;</div>';
          if (id) tooltipHTML += '<div class="tooltip-id">' + id + '</div>';
          if (classes) tooltipHTML += '<div class="tooltip-class">' + classes + '</div>';
          if (textPreview) tooltipHTML += '<div class="tooltip-text">"' + textPreview + '"</div>';
          tooltipHTML += '<div class="tooltip-hint">Click to select this element</div>';
          tooltip.innerHTML = tooltipHTML;
          
          // Position tooltip near cursor
          const tooltipRect = tooltip.getBoundingClientRect();
          let left = e.clientX + 15;
          let top = e.clientY + 15;
          
          // Adjust if tooltip goes off screen
          if (left + tooltipRect.width > iframeWin.innerWidth - 10) {
            left = e.clientX - tooltipRect.width - 15;
          }
          if (top + tooltipRect.height > iframeWin.innerHeight - 10) {
            top = e.clientY - tooltipRect.height - 15;
          }
          
          tooltip.style.left = left + 'px';
          tooltip.style.top = top + 'px';
          tooltip.classList.add('visible');
        };
        
        // Mouse leave handler
        iframeWin.__elementSelectorMouseLeave = function(e) {
          if (iframeWin.__elementSelectorLastHovered) {
            iframeWin.__elementSelectorLastHovered.classList.remove('element-selector-highlight');
          }
          tooltip.classList.remove('visible');
        };
        
        // Click handler for selecting element
        iframeWin.__elementSelectorClick = function(e) {
          e.preventDefault();
          e.stopPropagation();
          
          const el = e.target;
          if (el.id === 'element-selector-tooltip') return;
          
          // Remove previous selection
          const prevSelected = iframeDoc.querySelector('.element-selector-selected');
          if (prevSelected) {
            prevSelected.classList.remove('element-selector-selected');
          }
          
          // Mark as selected
          el.classList.remove('element-selector-highlight');
          el.classList.add('element-selector-selected');
          
          // Gather element info
          const tagName = el.tagName.toLowerCase();
          const id = el.id || '';
          const classes = el.className && typeof el.className === 'string'
            ? el.className.split(' ').filter(c => c && !c.includes('element-selector')).join(' ')
            : '';
          const textContent = el.textContent ? el.textContent.trim().substring(0, 100) : '';
          
          // Get element path (CSS selector)
          let path = tagName;
          if (id) path += '#' + id;
          else if (classes) path += '.' + classes.split(' ')[0];
          
          // Get parent context
          const parentTag = el.parentElement ? el.parentElement.tagName.toLowerCase() : '';
          const parentId = el.parentElement && el.parentElement.id ? '#' + el.parentElement.id : '';
          const parentClass = el.parentElement && el.parentElement.className && typeof el.parentElement.className === 'string'
            ? '.' + el.parentElement.className.split(' ').filter(c => c)[0]
            : '';
          
          // Get computed styles (key ones)
          const computedStyle = iframeWin.getComputedStyle(el);
          const styles = {
            display: computedStyle.display,
            position: computedStyle.position,
            width: computedStyle.width,
            height: computedStyle.height
          };
          
          // Get inner HTML structure (limited)
          const childCount = el.children.length;
          const hasChildren = childCount > 0;
          
          // Send to parent window
          window.parent.postMessage({
            type: 'element-selected',
            data: {
              tagName,
              id,
              classes,
              textContent: textContent.substring(0, 100),
              path,
              parentContext: parentTag + parentId + parentClass,
              styles,
              childCount,
              outerHTMLPreview: el.outerHTML.substring(0, 500)
            }
          }, '*');
          
          return false;
        };
        
        // Attach event listeners
        iframeDoc.body.addEventListener('mousemove', iframeWin.__elementSelectorMouseMove, true);
        iframeDoc.body.addEventListener('mouseleave', iframeWin.__elementSelectorMouseLeave, true);
        iframeDoc.body.addEventListener('click', iframeWin.__elementSelectorClick, true);
        
      } catch (err) {
        console.error('Error injecting element selector:', err);
      }
    }
    
    function removeElementSelectorFromPreview() {
      const preview = document.getElementById('previewFrame');
      if (!preview || !preview.contentWindow || !preview.contentDocument) return;
      
      try {
        const iframeDoc = preview.contentDocument;
        const iframeWin = preview.contentWindow;
        
        // Remove styles
        const styles = iframeDoc.getElementById('element-selector-styles');
        if (styles) styles.remove();
        
        // Remove tooltip
        const tooltip = iframeDoc.getElementById('element-selector-tooltip');
        if (tooltip) tooltip.remove();
        
        // Remove highlights
        iframeDoc.querySelectorAll('.element-selector-highlight, .element-selector-selected').forEach(el => {
          el.classList.remove('element-selector-highlight', 'element-selector-selected');
        });
        
        // Remove event listeners
        if (iframeWin.__elementSelectorMouseMove) {
          iframeDoc.body.removeEventListener('mousemove', iframeWin.__elementSelectorMouseMove, true);
        }
        if (iframeWin.__elementSelectorMouseLeave) {
          iframeDoc.body.removeEventListener('mouseleave', iframeWin.__elementSelectorMouseLeave, true);
        }
        if (iframeWin.__elementSelectorClick) {
          iframeDoc.body.removeEventListener('click', iframeWin.__elementSelectorClick, true);
        }
        
      } catch (err) {
        console.error('Error removing element selector:', err);
      }
    }
    
    // Listen for messages from iframe
    window.addEventListener('message', function(event) {
      if (event.data && event.data.type === 'element-selected') {
        handleElementSelected(event.data.data);
      }
    });
    
    function handleElementSelected(elementData) {
      selectedElementContext = elementData;
      
      // Update the display
      const display = document.getElementById('selectedElementDisplay');
      const tagSpan = document.getElementById('selectedElementTag');
      const detailsSpan = document.getElementById('selectedElementDetails');
      const hint = document.getElementById('elementSelectorHint');
      
      // Build tag display
      let tagDisplay = '<' + elementData.tagName + '>';
      if (elementData.id) tagDisplay += '#' + elementData.id;
      else if (elementData.classes) tagDisplay += '.' + elementData.classes.split(' ')[0];
      
      // Build details
      let details = [];
      if (elementData.parentContext) details.push('in ' + elementData.parentContext);
      if (elementData.childCount > 0) details.push(elementData.childCount + ' children');
      if (elementData.textContent) {
        const preview = elementData.textContent.substring(0, 30);
        details.push('"' + preview + (elementData.textContent.length > 30 ? '...' : '') + '"');
      }
      
      tagSpan.textContent = tagDisplay;
      detailsSpan.textContent = details.join('  ') || 'Element selected';
      
      display.style.display = 'flex';
      hint.style.display = 'none';
      
      // Re-initialize icons
      if (typeof lucide !== 'undefined') {
        lucide.createIcons();
      }
      
      console.log(' Element selected:', elementData);
      
      // Auto-deactivate selector mode after selection
      if (elementSelectorActive) {
        toggleElementSelector();
      }
    }
    
    function clearSelectedElement() {
      selectedElementContext = null;
      
      const display = document.getElementById('selectedElementDisplay');
      display.style.display = 'none';
      
      // Remove selection in preview
      const preview = document.getElementById('previewFrame');
      if (preview && preview.contentDocument) {
        const selected = preview.contentDocument.querySelector('.element-selector-selected');
        if (selected) {
          selected.classList.remove('element-selector-selected');
        }
      }
      
      console.log(' Element selection cleared');
    }
    
    // ========================================
    // SMART MODIFICATION ANALYSIS
    // ========================================
    
    /**
     * Analyzes user's modification request with element context
     * Searches for redundancies, similar patterns, and asks for clarification if needed
     */
    async function analyzeElementModificationContext(userMessage, elementContext) {
      console.log(' Analyzing element modification context...');
      
      const analysis = {
        needsClarification: false,
        clarificationMessage: '',
        contextEnhancement: ''
      };
      
      try {
        // Get current HTML to analyze
        const currentHTML = generatedHTML || '';
        if (!currentHTML) {
          // No HTML to analyze yet
          return analysis;
        }
        
        // Extract key information from element context
        const elementInfo = {
          tagName: elementContext.tagName,
          id: elementContext.id || null,
          classes: elementContext.classes || null,
          textContent: elementContext.textContent || null
        };
        
        console.log('   Selected element:', elementInfo);
        
        //  Search for similar patterns in the codebase
        const redundancies = findSimilarPatterns(currentHTML, elementInfo);
        
        if (redundancies.length > 0) {
          console.log(`   Found ${redundancies.length} similar pattern(s) in codebase`);
          
          // Build clarification message
          let clarificationMsg = `###  Similar Elements Detected\n\n`;
          clarificationMsg += `I found **${redundancies.length} similar element(s)** in your app that match the one you selected:\n\n`;
          
          redundancies.forEach((item, index) => {
            clarificationMsg += `**${index + 1}.** \`${item.description}\`\n`;
            if (item.snippet) {
              clarificationMsg += `   \`\`\`html\n   ${item.snippet}\n   \`\`\`\n`;
            }
          });
          
          clarificationMsg += `\n** Clarification Needed:**\n\n`;
          clarificationMsg += `When you say "${userMessage}", do you want me to:\n\n`;
          clarificationMsg += `1. **Only modify the selected element** you clicked on?\n`;
          clarificationMsg += `2. **Apply changes to ALL similar elements** (${redundancies.length + 1} total)?\n`;
          clarificationMsg += `3. **Let me ask you for each one** individually?\n\n`;
          clarificationMsg += `Please reply with **1**, **2**, or **3**, or provide more specific instructions.`;
          
          analysis.needsClarification = true;
          analysis.clarificationMessage = clarificationMsg;
          
          return analysis;
        }
        
        //  Extract modification intent from message
        const modificationIntent = extractModificationIntent(userMessage);
        
        //  Check if this modification might affect other parts
        const affectedAreas = findPotentiallyAffectedAreas(currentHTML, elementInfo, modificationIntent);
        
        if (affectedAreas.length > 0) {
          console.log(`   Found ${affectedAreas.length} potentially affected area(s)`);
          
          let warningMsg = `###  Potential Impact Detected\n\n`;
          warningMsg += `The change you're requesting might affect these areas:\n\n`;
          
          affectedAreas.forEach((area, index) => {
            warningMsg += `**${index + 1}.** ${area.description}\n`;
            warningMsg += `   - Risk: ${area.risk}\n`;
            if (area.suggestion) {
              warningMsg += `   - Suggestion: ${area.suggestion}\n`;
            }
          });
          
          warningMsg += `\n**Should I proceed?**\n\n`;
          warningMsg += `Reply:\n`;
          warningMsg += `- **"yes"** to proceed with the changes\n`;
          warningMsg += `- **"no, only change X"** to be more specific\n`;
          warningMsg += `- **"tell me more"** for detailed explanation`;
          
          analysis.needsClarification = true;
          analysis.clarificationMessage = warningMsg;
          
          return analysis;
        }
        
        //  No clarification needed, enhance context with analysis
        analysis.contextEnhancement = `\n\n[MODIFICATION ANALYSIS]\n`;
        analysis.contextEnhancement += `Intent: ${modificationIntent.action} - ${modificationIntent.target}\n`;
        analysis.contextEnhancement += `Scope: Single element (no similar patterns found)\n`;
        analysis.contextEnhancement += `Impact: Low - change appears isolated\n`;
        analysis.contextEnhancement += `[END ANALYSIS]\n`;
        
        console.log('    Analysis complete - no clarification needed');
        
      } catch (error) {
        console.error(' Error in modification analysis:', error);
        // Don't block user if analysis fails - proceed normally
      }
      
      return analysis;
    }
    
    /**
     * Find similar patterns in HTML based on element characteristics
     */
    function findSimilarPatterns(html, elementInfo) {
      const similar = [];
      
      // Create a temporary div to parse HTML
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;
      
      // Search criteria (in order of specificity)
      let selector = '';
      
      if (elementInfo.id) {
        // If has ID, look for same tag+id pattern (shouldn't be multiple, but check)
        selector = `${elementInfo.tagName}#${elementInfo.id}`;
        const matches = tempDiv.querySelectorAll(selector);
        if (matches.length > 1) {
          for (let i = 0; i < matches.length; i++) {
            similar.push({
              description: `${elementInfo.tagName} with id="${elementInfo.id}" (occurrence ${i + 1})`,
              snippet: matches[i].outerHTML.substring(0, 100) + '...'
            });
          }
        }
      } else if (elementInfo.classes) {
        // Look for same tag+class combination
        const classes = elementInfo.classes.split(' ').filter(c => c.trim());
        selector = `${elementInfo.tagName}.${classes.join('.')}`;
        const matches = tempDiv.querySelectorAll(selector);
        if (matches.length > 1) {
          for (let i = 1; i < Math.min(matches.length, 6); i++) { // Show max 5 similar
            similar.push({
              description: `${elementInfo.tagName} with class="${elementInfo.classes}" (occurrence ${i + 1})`,
              snippet: matches[i].outerHTML.substring(0, 100) + '...'
            });
          }
        }
      } else if (elementInfo.textContent) {
        // Look for same tag with similar text content
        const allSameTags = tempDiv.querySelectorAll(elementInfo.tagName);
        const textToMatch = elementInfo.textContent.toLowerCase().trim();
        
        allSameTags.forEach((el, idx) => {
          const elText = el.textContent?.toLowerCase().trim() || '';
          if (elText === textToMatch && idx > 0 && similar.length < 5) {
            similar.push({
              description: `${elementInfo.tagName} with text "${elementInfo.textContent.substring(0, 30)}..."`,
              snippet: el.outerHTML.substring(0, 100) + '...'
            });
          }
        });
      }
      
      return similar;
    }
    
    /**
     * Extract what the user wants to do from their message
     */
    function extractModificationIntent(message) {
      const messageLower = message.toLowerCase();
      
      const intent = {
        action: 'modify',
        target: 'element',
        details: []
      };
      
      // Detect action
      if (messageLower.includes('change color') || messageLower.includes('make it') && messageLower.includes('color')) {
        intent.action = 'change color';
        intent.target = 'styling';
      } else if (messageLower.includes('change text') || messageLower.includes('update text') || messageLower.includes('rename')) {
        intent.action = 'change text';
        intent.target = 'content';
      } else if (messageLower.includes('resize') || messageLower.includes('make bigger') || messageLower.includes('make smaller')) {
        intent.action = 'resize';
        intent.target = 'dimensions';
      } else if (messageLower.includes('move') || messageLower.includes('position')) {
        intent.action = 'reposition';
        intent.target = 'layout';
      } else if (messageLower.includes('hide') || messageLower.includes('remove') || messageLower.includes('delete')) {
        intent.action = 'remove';
        intent.target = 'element';
      } else if (messageLower.includes('add') || messageLower.includes('insert')) {
        intent.action = 'add';
        intent.target = 'element';
      }
      
      return intent;
    }
    
    /**
     * Find areas that might be affected by this modification
     */
    function findPotentiallyAffectedAreas(html, elementInfo, intent) {
      const affected = [];
      
      // Check for CSS grid/flex layouts that might break
      if (intent.action === 'remove' && html.includes('display: grid') || html.includes('display: flex')) {
        affected.push({
          description: 'Grid/Flex layout structure',
          risk: 'Removing this element might break the layout flow',
          suggestion: 'Consider hiding with visibility:hidden instead'
        });
      }
      
      // Check for data bindings or event handlers
      if (elementInfo.id && (html.includes(`getElementById('${elementInfo.id}')`) || html.includes(`querySelector('#${elementInfo.id}')`))) {
        affected.push({
          description: 'JavaScript references to this element',
          risk: 'Code references this element by ID - changing/removing it might break functionality',
          suggestion: 'Update the JavaScript code as well'
        });
      }
      
      // Check for form elements
      if (['INPUT', 'SELECT', 'TEXTAREA', 'BUTTON'].includes(elementInfo.tagName) && html.includes('form')) {
        affected.push({
          description: 'Form functionality',
          risk: 'This is a form element - changes might affect form submission or validation',
          suggestion: 'Ensure form still works correctly after changes'
        });
      }
      
      return affected;
    }
    
    function getSelectedElementContextForAI() {
      if (!selectedElementContext) return '';
      
      const el = selectedElementContext;
      let context = '\n\n[SELECTED ELEMENT CONTEXT]\n';
      context += 'Element: <' + el.tagName + '>';
      if (el.id) context += ' id="' + el.id + '"';
      if (el.classes) context += ' class="' + el.classes + '"';
      context += '\n';
      if (el.parentContext) context += 'Parent: ' + el.parentContext + '\n';
      if (el.styles) {
        context += 'Layout: ' + el.styles.display + ', ' + el.styles.position + ', ' + el.styles.width + ' x ' + el.styles.height + '\n';
      }
      if (el.textContent) {
        context += 'Text: "' + el.textContent.substring(0, 100) + '"\n';
      }
      if (el.outerHTMLPreview) {
        context += 'HTML Preview:\n```html\n' + el.outerHTMLPreview + '\n```\n';
      }
      
      // Add mandatory workflow instructions for AI
      context += '\n MANDATORY WORKFLOW FOR THIS SELECTED ELEMENT:\n';
      context += '1. FIRST: Call find_code_locations("';
      if (el.id) {
        context += 'id=\\"' + el.id + '\\"';
      } else if (el.classes) {
        const firstClass = el.classes.split(' ').filter(c => c && !c.includes('element-selector'))[0];
        if (firstClass) {
          context += 'class=\\"' + firstClass + '\\"';
        } else {
          context += el.tagName.toLowerCase();
        }
      } else if (el.textContent && el.textContent.trim().length > 0) {
        context += el.textContent.substring(0, 30).replace(/"/g, '\\"');
      } else {
        context += el.tagName.toLowerCase();
      }
      context += '") to locate this element\n';
      context += '2. ANALYZE: Review the code context (with line numbers) to understand the implementation\n';
      context += '3. DETERMINE: Is the user request clear from their message + this context?\n';
      context += '   - If CLEAR (95% of cases)  Proceed to step 4 immediately\n';
      context += '   - If UNCLEAR (ambiguous intent)  Ask ONE specific clarifying question, then proceed\n';
      context += '4. EXECUTE: Call update_html using LINE-BASED mode with line numbers from step 1\n';
      context += '5. VERIFY: Check the result and fix any errors automatically\n';
      context += '\n DO NOT ask "Should I proceed?" or "Do you want me to change this?" - Just implement it!\n';
      context += '[END SELECTED ELEMENT]\n';
      
      return context;
    }
    
    // ========================================
    // MINIMAL MODE ELEMENT SELECTOR
    // ========================================
    
    let minimalElementSelectorActive = false;
    
    function toggleMinimalElementSelector() {
      minimalElementSelectorActive = !minimalElementSelectorActive;
      const btn = document.getElementById('minimalElementSelectorBtn');
      
      if (minimalElementSelectorActive) {
        btn.classList.add('active');
        injectElementSelectorIntoMinimalPreview();
        console.log(' Minimal element selector activated');
      } else {
        btn.classList.remove('active');
        removeElementSelectorFromMinimalPreview();
        console.log(' Minimal element selector deactivated');
      }
      
      // Re-initialize icons
      if (typeof lucide !== 'undefined') {
        lucide.createIcons();
      }
    }
    
    function injectElementSelectorIntoMinimalPreview() {
      const preview = document.getElementById('minimalPreviewFrame');
      if (!preview || !preview.contentWindow || !preview.contentDocument) {
        console.warn('Minimal preview iframe not ready for element selector');
        return;
      }
      
      try {
        const iframeDoc = preview.contentDocument;
        const iframeWin = preview.contentWindow;
        
        // Check if already injected
        if (iframeWin.__minimalElementSelectorInjected) {
          return;
        }
        
        // Add hover styles
        const style = iframeDoc.createElement('style');
        style.id = 'minimal-element-selector-styles';
        style.textContent = `
          .minimal-element-selector-highlight {
            outline: 2px solid #0053e2 !important;
            outline-offset: 2px !important;
            cursor: pointer !important;
            position: relative !important;
          }
          .minimal-element-selector-highlight::after {
            content: attr(data-selector-tag);
            position: absolute;
            top: -24px;
            left: 0;
            background: #0053e2;
            color: white;
            padding: 2px 8px;
            font-size: 11px;
            font-family: monospace;
            border-radius: 3px;
            pointer-events: none;
            z-index: 999999;
            white-space: nowrap;
          }
        `;
        iframeDoc.head.appendChild(style);
        
        // Mouse move handler for hovering
        const handleMouseMove = (e) => {
          if (!minimalElementSelectorActive) return;
          
          // Remove previous highlights
          const previousHighlights = iframeDoc.querySelectorAll('.minimal-element-selector-highlight');
          previousHighlights.forEach(el => {
            el.classList.remove('minimal-element-selector-highlight');
            el.removeAttribute('data-selector-tag');
          });
          
          // Highlight current element
          const element = e.target;
          if (element && element !== iframeDoc.body && element !== iframeDoc.documentElement) {
            element.classList.add('minimal-element-selector-highlight');
            const tag = element.tagName.toLowerCase();
            const id = element.id ? '#' + element.id : '';
            const classes = element.className ? '.' + element.className.split(' ').filter(c => c && c !== 'minimal-element-selector-highlight').join('.') : '';
            element.setAttribute('data-selector-tag', tag + id + classes);
          }
        };
        
        // Mouse leave handler
        const handleMouseLeave = () => {
          const highlights = iframeDoc.querySelectorAll('.minimal-element-selector-highlight');
          highlights.forEach(el => {
            el.classList.remove('minimal-element-selector-highlight');
            el.removeAttribute('data-selector-tag');
          });
        };
        
        // Click handler for selection
        const handleClick = (e) => {
          if (!minimalElementSelectorActive) return;
          
          e.preventDefault();
          e.stopPropagation();
          
          const element = e.target;
          if (element && element !== iframeDoc.body && element !== iframeDoc.documentElement) {
            selectMinimalElement(element);
          }
        };
        
        // Add event listeners
        iframeDoc.body.addEventListener('mousemove', handleMouseMove, true);
        iframeDoc.body.addEventListener('mouseleave', handleMouseLeave, true);
        iframeDoc.body.addEventListener('click', handleClick, true);
        
        // Store handlers for cleanup
        iframeWin.__minimalElementSelectorMouseMove = handleMouseMove;
        iframeWin.__minimalElementSelectorMouseLeave = handleMouseLeave;
        iframeWin.__minimalElementSelectorClick = handleClick;
        iframeWin.__minimalElementSelectorInjected = true;
        
      } catch (err) {
        console.error('Error injecting minimal element selector:', err);
      }
    }
    
    function removeElementSelectorFromMinimalPreview() {
      const preview = document.getElementById('minimalPreviewFrame');
      if (!preview || !preview.contentWindow || !preview.contentDocument) {
        return;
      }
      
      try {
        const iframeDoc = preview.contentDocument;
        const iframeWin = preview.contentWindow;
        
        // Remove styles
        const style = iframeDoc.getElementById('minimal-element-selector-styles');
        if (style) {
          style.remove();
        }
        
        // Remove highlights
        const highlights = iframeDoc.querySelectorAll('.minimal-element-selector-highlight');
        highlights.forEach(el => {
          el.classList.remove('minimal-element-selector-highlight');
          el.removeAttribute('data-selector-tag');
        });
        
        // Remove event listeners
        if (iframeWin.__minimalElementSelectorMouseMove) {
          iframeDoc.body.removeEventListener('mousemove', iframeWin.__minimalElementSelectorMouseMove, true);
        }
        if (iframeWin.__minimalElementSelectorMouseLeave) {
          iframeDoc.body.removeEventListener('mouseleave', iframeWin.__minimalElementSelectorMouseLeave, true);
        }
        if (iframeWin.__minimalElementSelectorClick) {
          iframeDoc.body.removeEventListener('click', iframeWin.__minimalElementSelectorClick, true);
        }
        
        iframeWin.__minimalElementSelectorInjected = false;
        
      } catch (err) {
        console.error('Error removing minimal element selector:', err);
      }
    }
    
    function selectMinimalElement(element) {
      // Capture element information (same as normal mode)
      const elementData = {
        tag: element.tagName.toLowerCase(),
        id: element.id || '',
        classes: element.className ? element.className.split(' ').filter(c => c && c !== 'minimal-element-selector-highlight') : [],
        attributes: {},
        textContent: element.textContent ? element.textContent.trim().substring(0, 200) : '',
        innerHTML: element.innerHTML ? element.innerHTML.substring(0, 500) : '',
        outerHTMLPreview: element.outerHTML ? element.outerHTML.substring(0, 500) : '',
        styles: {},
        parentContext: ''
      };
      
      // Get attributes
      for (let attr of element.attributes) {
        if (attr.name !== 'class' && attr.name !== 'id' && !attr.name.startsWith('data-selector')) {
          elementData.attributes[attr.name] = attr.value;
        }
      }
      
      // Get computed styles
      const computedStyles = element.ownerDocument.defaultView.getComputedStyle(element);
      elementData.styles = {
        display: computedStyles.display,
        position: computedStyles.position,
        width: computedStyles.width,
        height: computedStyles.height,
        backgroundColor: computedStyles.backgroundColor,
        color: computedStyles.color,
        fontSize: computedStyles.fontSize,
        padding: computedStyles.padding,
        margin: computedStyles.margin
      };
      
      // Get parent context
      if (element.parentElement) {
        const parent = element.parentElement;
        elementData.parentContext = parent.tagName.toLowerCase() + 
          (parent.id ? '#' + parent.id : '') +
          (parent.className ? '.' + parent.className.split(' ').join('.') : '');
      }
      
      // Store in shared context (same variable as normal mode)
      selectedElementContext = elementData;
      
      // Update button to show selection
      const btn = document.getElementById('minimalElementSelectorBtn');
      if (btn) {
        btn.classList.add('element-selected');
      }
      
      console.log(' Element selected in minimal mode:', elementData);
      
      // Auto-deactivate selector mode after selection
      if (minimalElementSelectorActive) {
        toggleMinimalElementSelector();
      }
    }
    
    function copyCode() {
      if (generatedHTML) {
        navigator.clipboard.writeText(generatedHTML);
        addMessageToChat('system', ' Code copied to clipboard!');
      }
    }
    
    function downloadCode() {
      if (generatedHTML) {
        const blob = new Blob([generatedHTML], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'generated-app.html';
        a.click();
        URL.revokeObjectURL(url);
        addMessageToChat('system', ' Downloaded as generated-app.html');
      }
    }
    
    function expandCode() {
      const codeView = document.getElementById('codeView');
      if (codeView.requestFullscreen) {
        codeView.requestFullscreen();
      }
    }
    
    // ========================================
    // PUBLISH FUNCTIONS
    // ========================================
    
    async function showPublishModal() {
      if (!generatedHTML || generatedHTML.trim() === '') {
        addMessageToChat('system', ' No app to share. Generate an app first.');
        return;
      }
      
      const modal = document.getElementById('publishModal');
      const appNameInput = document.getElementById('publishAppName');
      const publishModalForm = document.getElementById('publishModalForm');
      const publishSuccessContent = document.getElementById('publishSuccessContent');
      const publishErrorMessage = document.getElementById('publishErrorMessage');
      const publishBtn = document.getElementById('publishBtn');
      const publishBtnText = document.getElementById('publishBtnText');
      const publishModalActionText = document.getElementById('publishModalActionText');
      const publishModalDescriptionText = document.getElementById('publishModalDescriptionText');
      
      // Reset modal state
      publishModalForm.style.display = 'block';
      publishSuccessContent.style.display = 'none';
      publishErrorMessage.style.display = 'none';
      publishBtn.style.display = 'inline-flex';
      publishBtn.disabled = false; // Enable button
      
      // Reset button state
      const publishBtnSpinner = document.getElementById('publishBtnSpinner');
      publishBtnText.style.display = 'inline';
      publishBtnSpinner.style.display = 'none';
      
      // Auto-fill with current project name
      const appName = currentProjectName || 'My App';
      appNameInput.value = appName;
      
      // Set default text
      publishBtnText.textContent = 'Generate Link';
      if (publishModalActionText) publishModalActionText.textContent = 'Get Shareable Link';
      if (publishModalDescriptionText) publishModalDescriptionText.textContent = 'Get a shareable link that always shows the latest version of your app.';
      
      // Show modal with proper CSS classes
      modal.style.display = 'flex';
      setTimeout(() => {
        modal.classList.add('show');
      }, 10);
      lucide.createIcons();
    }
    
    function closePublishModal() {
      const modal = document.getElementById('publishModal');
      modal.classList.remove('show');
      setTimeout(() => {
        modal.style.display = 'none';
      }, 300);
    }
    
    // Helper function to inject version management widget into HTML before publishing
    function injectVersionWidget(html, sanitizedAppName) {
      // Split into smaller strings to avoid linter issues
      const widgetPart1 = '<!-- Version Management Widget --><div id="versionManagementWidget" style="position: fixed; bottom: 20px; right: 20px; z-index: 999999;">';
      const widgetPart2 = '<button id="versionWidgetBtn" onclick="toggleVersionPanel()" style="width: 56px; height: 56px; border-radius: 9999px; background: linear-gradient(135deg, #0053E2 0%, #001E60 100%); border: none; box-shadow: 0 4px 12px rgba(0, 83, 226, 0.4); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease;" title="Version Management">';
      const widgetPart3 = '<svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg></button></div>';
      const widgetPart4 = '<div id="versionPanel" style="position: fixed; top: 0; right: -400px; width: 400px; height: 100vh; background: white; box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3); z-index: 999998; transition: right 0.3s ease; overflow-y: auto;">';
      const widgetPart5 = '<div style="position: sticky; top: 0; background: #0053E2; padding: 24px;"><div style="display: flex; justify-content: space-between; margin-bottom: 8px;"><h2 style="margin: 0; color: white; font-size: 20px; font-weight: 600;">Version History</h2>';
      const widgetPart6 = '<button onclick="toggleVersionPanel()" style="background: rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 255, 255, 0.3); color: white; width: 32px; height: 32px; border-radius: 9999px; cursor: pointer;"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button></div>';
      const widgetPart7 = '<p style="margin: 0; color: rgba(255, 255, 255, 0.9); font-size: 13px;">Manage and restore previous versions</p></div><div id="versionListContent" style="padding: 24px;"><p style="text-align: center; color: #6B7280;">Loading...</p></div></div>';
      const widgetPart8 = '<div id="versionPanelOverlay" onclick="toggleVersionPanel()" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 999997; display: none;"></div>';
      
      const scriptPart1 = '<' + 'script>(function(){var app="' + sanitizedAppName + '";var api=window.location.origin;var open=false;var loaded=false;';
      const scriptPart2 = 'window.toggleVersionPanel=function(){open=!open;var p=document.getElementById("versionPanel");var o=document.getElementById("versionPanelOverlay");';
      const scriptPart3 = 'if(open){o.style.display="block";setTimeout(function(){p.style.right="0";o.style.opacity="1"},10);if(!loaded){loadVersionHistory();loaded=true}}else{p.style.right="-400px";o.style.opacity="0";setTimeout(function(){o.style.display="none"},300)}};';
      const scriptPart4 = 'function loadVersionHistory(){var c=document.getElementById("versionListContent");fetch(api+"/api/publish/versions/"+app).then(function(r){return r.json()}).then(function(d){';
      const scriptPart5 = 'if(d.success){if(d.versions.length===0){c.innerHTML="<p>No previous versions</p>"}else{var h="<div style=\\"padding:16px;background:#E8F5E9;border-radius:12px;margin-bottom:24px\\"><strong>Current Version</strong></div>";';
      const scriptPart6 = 'd.versions.forEach(function(v,i){var date=new Date(v.created_at);h+="<div style=\\"padding:16px;border:1px solid #ddd;border-radius:12px;margin-bottom:16px\\"><div><strong>Version "+(d.version_count-i)+"</strong><br><small>"+date.toLocaleString()+"</small></div>";';
      const scriptPart7 = 'h+="<div style=\\"display:flex;gap:8px;margin-top:8px\\"><button onclick=\\"viewVersion(\'"+v.url+"\')\\">View</button><button onclick=\\"restoreVersion(\'"+v.filename+"\')\\">Restore</button></div></div>"});c.innerHTML=h}}}).catch(function(e){c.innerHTML="<p>Error loading versions</p>"})};';
      const scriptPart8 = 'window.viewVersion=function(u){window.open(u,"_blank")};window.restoreVersion=function(f){if(!confirm("Restore this version?")){return}';
      const scriptPart9 = 'fetch(api+"/api/publish/restore",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({app_name:app,version_filename:f})}).then(function(r){return r.json()}).then(function(d){if(d.success){alert("Restored!");window.location.reload()}}).catch(function(e){alert("Error: "+e.message)})}})();<' + '/script>';
      
      const widgetCode = widgetPart1 + widgetPart2 + widgetPart3 + widgetPart4 + widgetPart5 + widgetPart6 + widgetPart7 + widgetPart8 + scriptPart1 + scriptPart2 + scriptPart3 + scriptPart4 + scriptPart5 + scriptPart6 + scriptPart7 + scriptPart8 + scriptPart9;

      // Find closing body tag and inject before it
      const bodyCloseIndex = html.lastIndexOf('</body>');
      if (bodyCloseIndex !== -1) {
        return html.slice(0, bodyCloseIndex) + widgetCode + html.slice(bodyCloseIndex);
      } else {
        return html + widgetCode;
      }
    }
    
    async function publishCurrentApp() {
      const publishBtn = document.getElementById('publishBtn');
      const publishBtnText = document.getElementById('publishBtnText');
      const publishBtnSpinner = document.getElementById('publishBtnSpinner');
      const publishErrorMessage = document.getElementById('publishErrorMessage');
      
      // Show loading state
      publishBtnText.style.display = 'none';
      publishBtnSpinner.textContent = 'Generating Link...';
      publishBtnSpinner.style.display = 'inline';
      publishBtn.disabled = true;
      publishErrorMessage.style.display = 'none';
      
      try {
        if (!currentProjectId) {
           throw new Error("Please create a project first before sharing.");
        }

        // Use page_name and version from the current version
        let pageName = null;
        let version = null;
        
        if (dbVersions && dbVersions.length > 0 && currentDBVersionIndex >= 0) {
          const currentVersion = dbVersions[currentDBVersionIndex];
          pageName = currentVersion.page_name;
          version = currentVersion.version;
        }
        
        if (!version || !currentProjectId) {
          throw new Error('No version found. Please save your work first.');
        }
        
        // Request a shortlink from the server
        // Always use "always_latest" so the link always shows the most recent version
        publishBtnSpinner.textContent = 'Creating shortlink...';
        const shortlinkResponse = await fetch(`${API_BASE}/api/shortlink/create`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            project_id: currentProjectId,
            always_latest: true  // Always point to the latest version
          })
        });
        
        const shortlinkData = await shortlinkResponse.json();
        
        if (!shortlinkResponse.ok || !shortlinkData.success) {
          throw new Error(shortlinkData.error || 'Failed to create shortlink');
        }
        
        const shareUrl = shortlinkData.url;
        
        // Show success state
        document.getElementById('publishModalForm').style.display = 'none';
        document.getElementById('publishSuccessContent').style.display = 'block';
        document.getElementById('publishedURL').value = shareUrl;
        publishBtn.style.display = 'none';
        
        const successMsg = ` Share link generated! This link will always show the latest version. (${shortlinkData.shortcode})`;
        addMessageToChat('system', successMsg);
        
        lucide.createIcons();
      } catch (error) {
        console.error('Error sharing app:', error);
        publishErrorMessage.textContent = `Error: ${error.message}`;
        publishErrorMessage.style.display = 'block';
        publishBtnText.style.display = 'inline';
        publishBtnSpinner.style.display = 'none';
        publishBtn.disabled = false;
      }
    }
    
    // Pagination state
    let allPublishedApps = [];
    let currentPage = 1;
    const APPS_PER_PAGE = 5;
    
    async function loadPublishedApps(resetPage = true) {
      const tbody = document.getElementById('publishedAppsTableBody');
      tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: var(--space-6); color: var(--text-secondary);"><i data-lucide="loader-2" style="animation: spin 1s linear infinite;"></i> Loading...</td></tr>';
      lucide.createIcons();
      
      try {
        const response = await fetch(`${API_BASE}/api/publish/list`);
        const data = await response.json();
        
        if (response.ok && data.success) {
          allPublishedApps = data.apps;
          if (resetPage) {
            currentPage = 1;
          }
          renderPublishedApps();
        } else {
          throw new Error(data.error || 'Failed to load published apps');
        }
      } catch (error) {
        console.error('Error loading published apps:', error);
        tbody.innerHTML = `<tr><td colspan="5" style="text-align: center; padding: var(--space-6); color: var(--error-red);">Error loading apps: ${error.message}</td></tr>`;
        document.getElementById('publishedAppsPagination').style.display = 'none';
      }
    }
    
    function renderPublishedApps() {
      const tbody = document.getElementById('publishedAppsTableBody');
      const pagination = document.getElementById('publishedAppsPagination');
      
      if (allPublishedApps.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: var(--space-6); color: var(--text-secondary);">No published apps yet</td></tr>';
        pagination.style.display = 'none';
        return;
      }
      
      // Calculate pagination
      const totalApps = allPublishedApps.length;
      const totalPages = Math.ceil(totalApps / APPS_PER_PAGE);
      const startIndex = (currentPage - 1) * APPS_PER_PAGE;
      const endIndex = Math.min(startIndex + APPS_PER_PAGE, totalApps);
      const appsToShow = allPublishedApps.slice(startIndex, endIndex);
      
      // Render apps
      tbody.innerHTML = appsToShow.map(app => {
        const publishedDate = app.published_date ? new Date(app.published_date).toLocaleString() : 'Unknown';
        return `
          <tr>
            <td><strong>${app.app_name}</strong></td>
            <td>${publishedDate}</td>
            <td>
              <a href="${app.url}" target="_blank" style="color: var(--primary-blue); text-decoration: none; font-family: monospace; font-size: 12px;">
                ${app.url}
              </a>
            </td>
            <td>${app.asset_count || 0} files</td>
            <td>
              <div style="display: flex; gap: var(--space-1);">
                <button class="btn-icon" onclick="window.open('${app.url}', '_blank')" title="View">
                  <i data-lucide="external-link"></i>
                </button>
                <button class="btn-icon" onclick="showAppVersionHistory('${app.sanitized_name}', '${app.app_name}')" title="Version History">
                  <i data-lucide="history"></i>
                </button>
                <button class="btn-icon" onclick="republishApp('${app.app_name}')" title="Republish">
                  <i data-lucide="refresh-cw"></i>
                </button>
                <button class="btn-icon" onclick="confirmUnpublishApp('${app.app_name}')" title="Delete" style="color: var(--error-red);">
                  <i data-lucide="trash-2"></i>
                </button>
              </div>
            </td>
          </tr>
        `;
      }).join('');
      
      // Update pagination UI
      if (totalApps > APPS_PER_PAGE) {
        pagination.style.display = 'flex';
        document.getElementById('paginationStart').textContent = startIndex + 1;
        document.getElementById('paginationEnd').textContent = endIndex;
        document.getElementById('paginationTotal').textContent = totalApps;
        
        const prevBtn = document.getElementById('prevPageBtn');
        const nextBtn = document.getElementById('nextPageBtn');
        
        prevBtn.disabled = currentPage === 1;
        nextBtn.disabled = currentPage === totalPages;
      } else {
        pagination.style.display = 'none';
      }
      
      lucide.createIcons();
    }
    
    function changePage(direction) {
      currentPage += direction;
      renderPublishedApps();
    }
    
    function republishApp(appName) {
      if (!generatedHTML || generatedHTML.trim() === '') {
        addMessageToChat('system', ' No app to republish. Generate an app first.');
        return;
      }
      
      if (confirm(`Republish "${appName}" with the current HTML?`)) {
        // Pre-fill the modal with the app name
        document.getElementById('publishAppName').value = appName;
        showPublishModal();
      }
    }
    
    function confirmUnpublishApp(appName) {
      if (confirm(`Are you sure you want to unpublish "${appName}"? This will delete all published files.`)) {
        unpublishApp(appName);
      }
    }
    
    async function unpublishApp(appName) {
      try {
        const response = await fetch(`${API_BASE}/api/publish/delete`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ app_name: appName })
        });
        
        const data = await response.json();
        
        if (response.ok && data.success) {
          addMessageToChat('system', ` ${data.message}`);
          
          // Check if we need to go back a page after deletion
          const willBeEmpty = ((currentPage - 1) * APPS_PER_PAGE) >= allPublishedApps.length - 1;
          if (willBeEmpty && currentPage > 1) {
            currentPage--;
          }
          
          await loadPublishedApps(false); // Refresh without resetting page
        } else {
          throw new Error(data.error || 'Failed to unpublish app');
        }
      } catch (error) {
        console.error('Error unpublishing app:', error);
        addMessageToChat('system', ` Error: ${error.message}`);
      }
    }
    
    function copyPublishedURL() {
      const urlInput = document.getElementById('publishedURL');
      urlInput.select();
      document.execCommand('copy');
      addMessageToChat('system', ' URL copied to clipboard!');
    }
    
    function openPublishedApp() {
      const url = document.getElementById('publishedURL').value;
      window.open(url, '_blank');
    }
    
    // ========================================
    // VERSION HISTORY FUNCTIONS
    // ========================================
    
    function showAppVersionHistory(sanitizedName, displayName) {
      // Set the current app for version history loading
      window.currentPublishedApp = {
        sanitized_name: sanitizedName,
        app_name: displayName
      };
      
      const modal = document.getElementById('versionHistoryModal');
      const content = document.getElementById('versionHistoryContent');
      
      // Show loading state
      content.innerHTML = `
        <div style="text-align: center; padding: var(--space-6); color: var(--text-secondary);">
          <i data-lucide="loader-2" style="animation: spin 1s linear infinite;"></i>
          <p style="margin-top: var(--space-2);">Loading versions for ${displayName}...</p>
        </div>
      `;
      
      modal.style.display = 'flex';
      setTimeout(() => {
        modal.classList.add('show');
      }, 10);
      lucide.createIcons();
      
      // Load versions
      loadPublishedVersionHistory();
    }
    
    function showVersionHistory() {
      if (!window.currentPublishedApp) {
        addMessageToChat('system', ' No published app found.');
        return;
      }
      
      const modal = document.getElementById('versionHistoryModal');
      const content = document.getElementById('versionHistoryContent');
      
      // Show loading state
      content.innerHTML = `
        <div style="text-align: center; padding: var(--space-6); color: var(--text-secondary);">
          <i data-lucide="loader-2" style="animation: spin 1s linear infinite;"></i>
          <p style="margin-top: var(--space-2);">Loading versions...</p>
        </div>
      `;
      
      modal.style.display = 'flex';
      setTimeout(() => {
        modal.classList.add('show');
      }, 10);
      lucide.createIcons();
      
      // Load versions
      loadPublishedVersionHistory();
    }
    
    function closeVersionHistoryModal() {
      const modal = document.getElementById('versionHistoryModal');
      modal.classList.remove('show');
      setTimeout(() => {
        modal.style.display = 'none';
      }, 300);
    }
    
    async function restoreVersionFromAdmin(versionFilename) {
      if (!window.currentPublishedApp) {
        addMessageToChat('system', ' No app selected.');
        return;
      }
      
      const appName = window.currentPublishedApp.sanitized_name;
      const displayName = window.currentPublishedApp.app_name;
      
      if (!confirm(`Are you sure you want to restore "${displayName}" to version:\n\n${versionFilename}\n\nThe current version will be archived.`)) {
        return;
      }
      
      try {
        const response = await fetch(`${API_BASE}/api/publish/restore`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            app_name: appName,
            version_filename: versionFilename
          })
        });
        
        const data = await response.json();
        
        if (response.ok && data.success) {
          addMessageToChat('system', ` Version restored successfully! "${displayName}" has been rolled back.`);
          
          // Reload the version history to show the updated list
          await loadPublishedVersionHistory();
          
          // Refresh the published apps list
          await loadPublishedApps();
        } else {
          throw new Error(data.error || 'Failed to restore version');
        }
      } catch (error) {
        console.error('Error restoring version:', error);
        addMessageToChat('system', ` Error restoring version: ${error.message}`);
      }
    }
    
    async function loadPublishedVersionHistory() {
      const content = document.getElementById('versionHistoryContent');
      
      try {
        if (!window.currentPublishedApp || !window.currentPublishedApp.sanitized_name) {
          content.innerHTML = `
            <div style="text-align: center; padding: var(--space-6); color: var(--text-secondary);">
              <i data-lucide="info" style="width: 48px; height: 48px; margin-bottom: var(--space-3);"></i>
              <h3 style="margin-bottom: var(--space-2); font-size: 16px;">No App Selected</h3>
              <p style="font-size: 14px; line-height: 1.6;">
                Please select a published app to view its version history.
              </p>
            </div>
          `;
          lucide.createIcons();
          return;
        }
        
        const appName = window.currentPublishedApp.sanitized_name;
        const response = await fetch(`${API_BASE}/api/publish/versions/${appName}`);
        const data = await response.json();
        
        if (response.ok && data.success) {
          if (data.versions.length === 0) {
            content.innerHTML = `
              <div style="text-align: center; padding: var(--space-6); color: var(--text-secondary);">
                <i data-lucide="history" style="width: 48px; height: 48px; margin-bottom: var(--space-3);"></i>
                <h3 style="margin-bottom: var(--space-2); font-size: 16px;">No Version History Yet</h3>
                <p style="font-size: 14px; line-height: 1.6;">
                  ${data.message || 'Versions will be created when you update this published app.'}
                </p>
              </div>
            `;
          } else {
            content.innerHTML = `
              <div style="padding: var(--space-3); background: rgba(0, 83, 226, 0.05); border-radius: 8px; margin-bottom: var(--space-3); border-left: 3px solid var(--primary-blue);">
                <p style="font-size: 13px; color: var(--text-primary); line-height: 1.5; margin: 0;">
                  <strong>${data.version_count} archived version${data.version_count === 1 ? '' : 's'}</strong><br>
                  Previous versions are automatically saved when you update your published app.
                </p>
              </div>
              
              <div style="display: flex; flex-direction: column; gap: var(--space-2);">
                ${data.versions.map((version, index) => {
                  const date = new Date(version.created_at);
                  const formattedDate = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                  const formattedTime = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                  
                  return `
                    <div style="padding: var(--space-3); border: 1px solid var(--border-gray); border-radius: 8px; background: white;">
                      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: var(--space-2);">
                        <div>
                          <div style="font-weight: 600; font-size: 14px; margin-bottom: 4px;">
                            Version ${data.version_count - index}
                          </div>
                          <div style="font-size: 12px; color: var(--text-secondary);">
                            ${formattedDate} at ${formattedTime}  ${version.size_kb} KB
                          </div>
                        </div>
                        <div style="display: flex; gap: var(--space-1);">
                          <button class="btn-icon" onclick="window.open('${version.url}', '_blank')" title="View this version">
                            <i data-lucide="external-link"></i>
                          </button>
                          <button class="btn-icon" onclick="restoreVersionFromAdmin('${version.filename}')" title="Restore this version" style="color: var(--primary-blue);">
                            <i data-lucide="rotate-ccw"></i>
                          </button>
                        </div>
                      </div>
                      <div style="font-size: 11px; color: var(--text-secondary); font-family: monospace; background: var(--surface-gray); padding: 4px 8px; border-radius: 4px; margin-bottom: var(--space-2);">
                        ${version.filename}
                      </div>
                    </div>
                  `;
                }).join('')}
              </div>
            `;
          }
          lucide.createIcons();
        } else {
          throw new Error(data.error || 'Failed to load version history');
        }
      } catch (error) {
        console.error('Error loading version history:', error);
        content.innerHTML = `
          <div style="text-align: center; padding: var(--space-6); color: var(--error-red);">
            <i data-lucide="alert-circle" style="width: 48px; height: 48px; margin-bottom: var(--space-3);"></i>
            <h3 style="margin-bottom: var(--space-2); font-size: 16px;">Error Loading Versions</h3>
            <p style="font-size: 14px;">${error.message}</p>
          </div>
        `;
        lucide.createIcons();
      }
    }
    
    // ========================================
    // SHARE FUNCTIONS
    // ========================================
    
    function showShareModal() {
      if (!generatedHTML || generatedHTML.trim() === '') {
        addMessageToChat('system', ' No app to share. Generate an app first.');
        return;
      }
      
      const modal = document.getElementById('shareModal');
      modal.style.display = 'flex';
      setTimeout(() => {
        modal.classList.add('show');
        checkPublishStatus();
      }, 10);
      lucide.createIcons();
    }
    
    function closeShareModal() {
      const modal = document.getElementById('shareModal');
      modal.classList.remove('show');
      setTimeout(() => {
        modal.style.display = 'none';
      }, 300);
    }
    
    async function checkPublishStatus() {
      const statusDiv = document.getElementById('sharePublishStatus');
      const publishedSection = document.getElementById('sharePublishedURLSection');
      const publishedURLInput = document.getElementById('sharePublishedURLInput');
      
      if (!currentProjectId) {
        publishedSection.style.display = 'none';
        statusDiv.innerHTML = '';
        return;
      }
      
      try {
        const response = await fetch(`${API_BASE}/api/publish/list`);
        const data = await response.json();
        
        if (response.ok && data.success) {
          // Match by project_id instead of by name
          const publishedApp = data.apps.find(app => app.project_id === currentProjectId);
          
          if (publishedApp) {
            // Show the prominent published URL section at the top
            publishedSection.style.display = 'block';
            publishedURLInput.value = publishedApp.url;
            
            // Also show status in the publish card
            statusDiv.innerHTML = `
              <div style="padding: var(--space-2); background: #E8F5E9; border-radius: 6px; margin-bottom: var(--space-2); font-size: 13px;">
                <div style="display: flex; align-items: center; gap: 8px;">
                  <i data-lucide="check-circle" style="width: 16px; height: 16px; color: var(--success-green);"></i>
                  <strong style="color: var(--success-green);">Already Published - Click to Republish</strong>
                </div>
              </div>
            `;
            lucide.createIcons();
          } else {
            publishedSection.style.display = 'none';
            statusDiv.innerHTML = '';
          }
        }
      } catch (error) {
        console.error('Error checking publish status:', error);
        publishedSection.style.display = 'none';
      }
    }
    
    function copyShareURL() {
      const urlInput = document.getElementById('sharePublishedURLInput');
      const url = urlInput.value;
      copyToClipboard(url);
    }
    
    function openShareURL() {
      const urlInput = document.getElementById('sharePublishedURLInput');
      const url = urlInput.value;
      window.open(url, '_blank');
    }
    
    function copyHTMLCode() {
      if (!generatedHTML) {
        addMessageToChat('system', ' No HTML to copy.');
        return;
      }
      
      navigator.clipboard.writeText(generatedHTML).then(() => {
        addMessageToChat('system', ' HTML code copied to clipboard!');
      }).catch(err => {
        console.error('Failed to copy:', err);
        addMessageToChat('system', ' Failed to copy HTML code.');
      });
    }
    
    function publishFromShare() {
      closeShareModal();
      setTimeout(() => showPublishModal(), 300);
    }
    
    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        addMessageToChat('system', ' URL copied to clipboard!');
      }).catch(err => {
        console.error('Failed to copy:', err);
        addMessageToChat('system', ' Failed to copy URL.');
      });
    }
    
    async function updatePublishStatusIndicator() {
      const indicator = document.getElementById('publishStatusIndicator');
      
      if (!currentProjectId) {
        indicator.style.display = 'none';
        return;
      }
      
      try {
        const response = await fetch(`${API_BASE}/api/publish/list`);
        const data = await response.json();
        
        if (response.ok && data.success) {
          // Match by project_id instead of by name
          const publishedApp = data.apps.find(app => app.project_id === currentProjectId);
          
          if (publishedApp) {
            indicator.style.display = 'flex';
            // Store the published info for use in share modal
            window.currentPublishedApp = publishedApp;
          } else {
            indicator.style.display = 'none';
            window.currentPublishedApp = null;
          }
        } else {
          indicator.style.display = 'none';
          window.currentPublishedApp = null;
        }
      } catch (error) {
        console.error('Error checking publish status:', error);
        indicator.style.display = 'none';
        window.currentPublishedApp = null;
      }
    }
    
    async function loadLatestProject(signal = null) {
      console.log(' Loading latest project on page refresh...');
      
      // Store project ID at start to detect if it changes during async operations
      const projectIdAtStart = currentProjectId;
      
      try {
        let loadData = null;
        
        // If a project is selected, use dbVersions array (already loaded by loadDBVersions)
        if (currentProjectId) {
          console.log(' Loading latest HTML from project cache:', currentProjectId);
          
          // Use dbVersions if already populated (avoids duplicate query)
          if (dbVersions && dbVersions.length > 0) {
            // dbVersions is sorted ascending, so last item is the latest
            const latestHTML = dbVersions[dbVersions.length - 1];
            console.log(' Using pre-loaded dbVersions data:', latestHTML.page_name);
            console.log(' Database record details:');
            console.log('   cache_id:', latestHTML.cache_id);
            console.log('   version:', latestHTML.version);
            console.log('   last_updated:', latestHTML.last_updated);
            console.log('   html_content length:', latestHTML.html_content?.length);
            
            loadData = { success: true, data: latestHTML };
          } else {
            // Fallback: query directly if dbVersions not available
            console.log(' dbVersions not available, querying directly...');
            try {
              const tableName = `${currentProjectId}_html_cache`;
              const fetchOptions = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  table_name: tableName,
                  where_clause: 'is_active = true',
                  order_by: 'last_updated DESC',
                  limit: 1
                })
              };
              
              // Add abort signal if provided
              if (signal) {
                fetchOptions.signal = signal;
              }
              
              const queryResponse = await fetch(`${API_BASE}/api/table/query`, fetchOptions);
              
              if (queryResponse.ok) {
                const queryData = await queryResponse.json();
                if (queryData.success && queryData.data && queryData.data.length > 0) {
                  const latestHTML = queryData.data[0];
                  console.log(' Found HTML in project cache:', latestHTML.page_name);
                  
                  // Check if HTML content is base64 encoded and decode it if needed
                  if (latestHTML.html_content) {
                    const trimmed = latestHTML.html_content.trim();
                    const looksLikeHTML = trimmed.startsWith('<!DOCTYPE') || trimmed.startsWith('<html') || trimmed.startsWith('<');
                    
                    if (!looksLikeHTML) {
                      try {
                        const decoded = atob(latestHTML.html_content);
                        const decodedTrimmed = decoded.trim();
                        
                        if (
                          decodedTrimmed.startsWith('<!DOCTYPE') ||
                          decodedTrimmed.startsWith('<html') ||
                          decodedTrimmed.startsWith('<')
                        ) {
                          console.log(' Decoded base64 HTML from database');
                          latestHTML.html_content = decoded;
                        }
                      } catch (err) {
                        console.warn(' Failed to decode base64 HTML:', err.message);
                      }
                    }
                  }
                  
                  loadData = { success: true, data: latestHTML };
                } else {
                  console.log(' No HTML in project cache, showing welcome screen');
                  showWelcomeScreen();
                  return;
                }
              } else {
                console.log(' Project cache table empty or not found, showing welcome screen');
                showWelcomeScreen();
                return;
              }
            } catch (error) {
              console.log(' Error loading from project cache:', error.message);
              showWelcomeScreen();
              return;
            }
          }
        } else {
          // No project selected - ALWAYS show welcome screen
          // Don't load from global cache - that's confusing for users
          console.log(' No project selected, showing welcome screen');
          showWelcomeScreen();
          return;
        }
        
        if (!loadData || !loadData.data) {
          console.log(' No cached HTML found, showing welcome screen');
          showWelcomeScreen();
          return;
        }
        
        console.log(' HTML content retrieved');
        console.log('   HTML size:', loadData.data.html_content?.length, 'characters');
        console.log('   DB version field:', loadData.data.version);
        
        generatedHTML = loadData.data.html_content;
        
        // Set currentVersionNumber from dbVersions (already loaded) or fallback
        if (currentProjectId) {
          if (dbVersions && dbVersions.length > 0) {
            // dbVersions is sorted ascending by version, so find max version from it
            let maxVersion = 0;
            for (const v of dbVersions) {
              const vNum = parseInt(v.version);
              if (!isNaN(vNum) && vNum > maxVersion) {
                maxVersion = vNum;
              }
            }
            currentVersionNumber = maxVersion > 0 ? maxVersion : 1;
            console.log(` Set currentVersionNumber from dbVersions: ${currentVersionNumber}`);
          } else {
            // Fallback to version from loaded entry
            const dbVersion = parseInt(loadData.data.version);
            currentVersionNumber = (!isNaN(dbVersion) && dbVersion > 0) ? dbVersion : 1;
            console.log(` Fallback to loaded entry version: ${currentVersionNumber}`);
          }
        } else {
          currentVersionNumber = 1;
          console.warn(' No project selected, starting from 1');
        }
        
        // Validate HTML content
        if (!generatedHTML || generatedHTML.trim() === '') {
          console.warn(' Empty HTML content received, showing welcome screen');
          showWelcomeScreen();
          return;
        }
        
        console.log(' HTML validated');
        
        // CRITICAL: Verify project hasn't changed during async load
        if (currentProjectId !== projectIdAtStart) {
          console.warn(' Project changed during loadLatestProject, aborting preview update');
          console.warn(`   Started with: ${projectIdAtStart}, now: ${currentProjectId}`);
          return;
        }
        
        // Update preview iframe
        console.log(' Updating preview...');
        const preview = document.getElementById('previewFrame');
        const loading = document.getElementById('previewLoading');
        
        // Small delay to ensure DOM is ready
        await new Promise(resolve => setTimeout(resolve, 100));
        
        preview.srcdoc = wrapHTMLWithConsoleCapture(generatedHTML);
        
        // Wait for iframe to load
        await new Promise((resolve) => {
          preview.onload = () => {
            loading.classList.add('hidden');
            preview.classList.add('loaded');
            console.log(' Preview loaded successfully');
            resolve();
          };
          
          // Fallback timeout in case onload doesn't fire
          setTimeout(() => {
            loading.classList.add('hidden');
            preview.classList.add('loaded');
            resolve();
          }, 2000);
        });
        
        // Update code view
        console.log(' Updating code view...');
        updateCodeView(generatedHTML);
        console.log(' Code view updated');
        
        // Update version display to show DB version
        console.log(' Updating version display...');
        updateVersionIndicators();
        console.log(' Version display updated');
        
        // Update project info UI
        console.log(' Updating project info...');
        const lastSaved = loadData.data.last_updated ? new Date(loadData.data.last_updated).toLocaleString() : 'Unknown';
        const statusElement = document.querySelector('.project-status');
        if (statusElement) {
          statusElement.textContent = `Last saved: ${lastSaved}`;
        }
        console.log(' Project info updated');
        
        // Notify user
        console.log(' ALL STEPS COMPLETE: Successfully loaded latest project:', loadData.data.page_name);
        addMessageToChat('system', `Loaded project: "${loadData.data.page_name}"`);
      } catch (error) {
        console.error(' Error loading latest project:', error);
        console.error('   Error details:', error.message);
        showWelcomeScreen();
        // Don't show error in chat if it's just that there are no projects
        if (!error.message.includes('No projects')) {
          addMessageToChat('system error', ` Could not load latest project: ${error.message}`);
        }
      }
    }
    
    /**
     * Custom confirmation dialog that works in sandboxed iframes
     * @param {string} message - The confirmation message
     * @param {boolean} isDangerous - Whether this is a dangerous action (uses red styling)
     * @returns {Promise<boolean>} - True if confirmed, false if cancelled
     */
    function showCustomConfirm(message, isDangerous = false) {
      return new Promise((resolve) => {
        // Create modal overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
          backdrop-filter: blur(4px);
        `;
        
        // Create modal content
        const modal = document.createElement('div');
        modal.style.cssText = `
          background: white;
          border-radius: 12px;
          padding: 24px;
          max-width: 500px;
          width: 90%;
          box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
          animation: modalSlideIn 200ms cubic-bezier(0.68, -0.55, 0.265, 1.55);
        `;
        
        // Add animation keyframes
        if (!document.getElementById('customConfirmStyles')) {
          const style = document.createElement('style');
          style.id = 'customConfirmStyles';
          style.textContent = `
            @keyframes modalSlideIn {
              from {
                transform: scale(0.9) translateY(-20px);
                opacity: 0;
              }
              to {
                transform: scale(1) translateY(0);
                opacity: 1;
              }
            }
          `;
          document.head.appendChild(style);
        }
        
        // Message text
        const messageEl = document.createElement('p');
        messageEl.style.cssText = `
          margin: 0 0 24px 0;
          color: #1f2937;
          font-size: 15px;
          line-height: 1.6;
          white-space: pre-wrap;
        `;
        messageEl.textContent = message;
        
        // Buttons container
        const buttonsDiv = document.createElement('div');
        buttonsDiv.style.cssText = `
          display: flex;
          gap: 12px;
          justify-content: flex-end;
        `;
        
        // Cancel button
        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.style.cssText = `
          padding: 10px 20px;
          border: 1px solid #d1d5db;
          background: white;
          color: #374151;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 500;
          cursor: pointer;
          transition: all 150ms;
        `;
        cancelBtn.onmouseover = () => {
          cancelBtn.style.background = '#f9fafb';
          cancelBtn.style.borderColor = '#9ca3af';
        };
        cancelBtn.onmouseout = () => {
          cancelBtn.style.background = 'white';
          cancelBtn.style.borderColor = '#d1d5db';
        };
        cancelBtn.onclick = () => {
          overlay.remove();
          resolve(false);
        };
        
        // Confirm button
        const confirmBtn = document.createElement('button');
        confirmBtn.textContent = isDangerous ? 'Delete' : 'OK';
        confirmBtn.style.cssText = `
          padding: 10px 20px;
          border: none;
          background: ${isDangerous ? '#ef4444' : '#0053e2'};
          color: white;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 500;
          cursor: pointer;
          transition: all 150ms;
        `;
        confirmBtn.onmouseover = () => {
          confirmBtn.style.background = isDangerous ? '#dc2626' : '#0041b8';
          confirmBtn.style.transform = 'translateY(-1px)';
          confirmBtn.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.15)';
        };
        confirmBtn.onmouseout = () => {
          confirmBtn.style.background = isDangerous ? '#ef4444' : '#0053e2';
          confirmBtn.style.transform = 'translateY(0)';
          confirmBtn.style.boxShadow = 'none';
        };
        confirmBtn.onclick = () => {
          overlay.remove();
          resolve(true);
        };
        
        // Assemble modal
        buttonsDiv.appendChild(cancelBtn);
        buttonsDiv.appendChild(confirmBtn);
        modal.appendChild(messageEl);
        modal.appendChild(buttonsDiv);
        overlay.appendChild(modal);
        
        // Add to document
        document.body.appendChild(overlay);
        
        // Focus confirm button
        confirmBtn.focus();
        
        // Handle escape key
        const handleEscape = (e) => {
          if (e.key === 'Escape') {
            overlay.remove();
            resolve(false);
            document.removeEventListener('keydown', handleEscape);
          }
        };
        document.addEventListener('keydown', handleEscape);
        
        // Handle click outside
        overlay.onclick = (e) => {
          if (e.target === overlay) {
            overlay.remove();
            resolve(false);
          }
        };
      });
    }
    
    function showWelcomeScreen() {
      const preview = document.getElementById('previewFrame');
      const loading = document.getElementById('previewLoading');
      
      // Hide version info when showing welcome screen
      const versionInfo = document.getElementById('versionInfo');
      if (versionInfo) {
        versionInfo.style.display = 'none';
      }
      
      // Clear version data
      dbVersions = [];
      currentDBVersionIndex = -1;
      
      generatedHTML = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Welcome</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      text-align: center;
      padding: 20px;
    }
    .container {
      max-width: 600px;
    }
    h1 {
      font-size: 48px;
      margin-bottom: 16px;
      font-weight: 700;
    }
    p {
      font-size: 20px;
      opacity: 0.9;
      line-height: 1.6;
    }

    /* ===== STOP BUTTON ENHANCEMENTS ===== */
    #stopGenerationBtn {
      display: none;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: #EF4444;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 150ms;
      margin-left: 8px;
      box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
      animation: pulse-stop 2s ease-in-out infinite;
      position: relative;
    }
    
    #stopGenerationBtn:hover {
      background: #DC2626;
      box-shadow: 0 4px 8px rgba(239, 68, 68, 0.4);
      transform: translateY(-1px);
    }
    
    #stopGenerationBtn:active {
      transform: translateY(0);
    }
    
    @keyframes pulse-stop {
      0%, 100% {
        box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
      }
      50% {
        box-shadow: 0 4px 12px rgba(239, 68, 68, 0.6);
      }
    }
    
    #stopGenerationBtn i {
      width: 16px;
      height: 16px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Welcome to App Builder</h1>
    <p>Ask the AI to build something in the chat, and your app will appear here!</p>
  </div>
</body>
</html>`;
      
      preview.srcdoc = wrapHTMLWithConsoleCapture(generatedHTML);
      preview.onload = () => {
        loading.classList.add('hidden');
        preview.classList.add('loaded');
      };
    }
    
    function loadProjectById(cacheId) {
      addMessageToChat('user', `Load project: ${cacheId}`);
      // AI will handle via chat
    }
    
    async function viewTable(tableName) {
      // Hide table list, show detail view
      document.getElementById('tableListView').style.display = 'none';
      document.getElementById('tableDetailView').style.display = 'block';
      document.getElementById('currentTableName').textContent = tableName;
      
      try {
        // Query table data
        const response = await fetch(`${API_BASE}/api/table/query`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            table_name: tableName,
            limit: 50
          })
        });
        
        if (!response.ok) throw new Error('Failed to load table data');
        
        const data = await response.json();
        renderTableData(data.data || [], tableName);
        
      } catch (error) {
        console.error('Error loading table:', error);
        document.getElementById('tableDetailBody').innerHTML = `
          <tr><td colspan="10" style="text-align: center; padding: var(--space-6); color: var(--error-red);">
            Error loading table data: ${error.message}
          </td></tr>
        `;
      }
      
      initLucideIcons();
    }
    
    function renderTableData(rows, tableName) {
      const tableHead = document.getElementById('tableDetailHead');
      const tableBody = document.getElementById('tableDetailBody');
      
      if (rows.length === 0) {
        tableHead.innerHTML = '';
        tableBody.innerHTML = `
          <tr><td colspan="10" style="text-align: center; padding: var(--space-6); color: var(--text-secondary);">
            No records found in ${tableName}
          </td></tr>
        `;
        document.getElementById('recordsInfo').textContent = '0 records found';
        return;
      }
      
      // Get column names from first row
      const columns = Object.keys(rows[0]);
      
      // Build table header
      tableHead.innerHTML = `
        <tr>
          <th><input type="checkbox" onclick="toggleAllCheckboxes(this)"></th>
          ${columns.map(col => `<th>${col}</th>`).join('')}
        </tr>
      `;
      
      // Build table body - add edit button as first cell
      tableBody.innerHTML = rows.map((row, index) => `
        <tr>
          <td onclick="event.stopPropagation()">
            <input type="checkbox" onchange="updateDeleteButton()">
            <button class="row-edit-btn" onclick="openEditModal(${index}, event); event.stopPropagation();" title="Edit row">
              <i data-lucide="pencil"></i>
            </button>
          </td>
          ${columns.map(col => {
            const value = row[col];
            const isId = col.toLowerCase().includes('id') || col.toLowerCase().includes('_id');
            return `<td class="${isId ? 'id-column' : ''}" onclick="openEditModal(${index}, event)">${value !== null && value !== undefined ? value : ''}</td>`;
          }).join('')}
        </tr>
      `).join('');
      
      initLucideIcons();
      
      document.getElementById('recordsInfo').textContent = `${rows.length} records found`;
      
      // Store rows data for editing
      window.currentTableRows = rows;
      
      // Reset delete button visibility
      updateDeleteButton();
    }
    
    let currentEditingRow = null;
    let currentEditingRowIndex = null;
    
    function openEditModal(rowIndex, event) {
      // Don't open modal if clicking checkbox
      if (event && event.target.tagName === 'INPUT') return;
      
      const row = window.currentTableRows[rowIndex];
      currentEditingRow = {...row};
      currentEditingRowIndex = rowIndex;
      
      const columns = Object.keys(row);
      const form = document.getElementById('editForm');
      
      // Build form fields
      form.innerHTML = columns.map(col => {
        const value = row[col];
        const isId = col.toLowerCase().includes('id') || col.toLowerCase().includes('_id');
        
        return `
          <div class="form-field">
            <label for="field_${col}">${col}</label>
            <input 
              type="text" 
              id="field_${col}" 
              name="${col}" 
              value="${value !== null && value !== undefined ? value : ''}"
              class="${isId ? 'id-field' : ''}"
              ${isId ? 'readonly' : ''}
            >
          </div>
        `;
      }).join('');
      
      // Show modal
      const modal = document.getElementById('editRowModal');
      modal.classList.add('show');
      
      initLucideIcons();
    }
    
    function closeEditModal() {
      const modal = document.getElementById('editRowModal');
      modal.classList.remove('show');
      currentEditingRow = null;
      currentEditingRowIndex = null;
    }
    
    async function saveRowEdit(event) {
      event.preventDefault();
      
      const form = document.getElementById('editForm');
      const formData = new FormData(form);
      const updates = {};
      
      // Collect changed fields
      for (const [key, value] of formData.entries()) {
        if (value !== currentEditingRow[key]) {
          updates[key] = value;
        }
      }
      
      if (Object.keys(updates).length === 0) {
        closeEditModal();
        return;
      }
      
      // Find the ID column for WHERE clause
      const idColumns = Object.keys(currentEditingRow).filter(col => 
        col.toLowerCase().includes('id') || col.toLowerCase() === 'id'
      );
      
      if (idColumns.length === 0) {
        addMessageToChat('system error', 'Unable to update: This table does not have an ID column.');
        return;
      }
      
      const idColumn = idColumns[0];
      const idValue = currentEditingRow[idColumn];
      const tableName = document.getElementById('currentTableName').textContent;
      
      try {
        const response = await fetch(`${API_BASE}/api/table/update`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            table_name: tableName,
            data: updates,
            where_clause: `${idColumn} = '${idValue}'`
          })
        });
        
        if (!response.ok) throw new Error('Failed to update row');
        
        // Close modal and refresh data
        closeEditModal();
        refreshTableData();
        
        addMessageToChat('system', ` Row updated successfully`);
      } catch (error) {
        console.error('Update error:', error);
        addMessageToChat('system error', 'Unable to update the record. Please try again.');
      }
    }
    
    function backToTableList() {
      document.getElementById('tableDetailView').style.display = 'none';
      document.getElementById('tableListView').style.display = 'block';
    }
    
    function refreshTableData() {
      const tableName = document.getElementById('currentTableName').textContent;
      if (tableName) {
        viewTable(tableName);
      }
    }
    
    function addNewRow() {
      alert('Add row functionality - coming soon');
    }
    
    function toggleAllCheckboxes(source) {
      const checkboxes = document.querySelectorAll('#tableDetailBody input[type="checkbox"]');
      checkboxes.forEach(cb => cb.checked = source.checked);
      updateDeleteButton();
    }
    
    function updateDeleteButton() {
      const checkboxes = document.querySelectorAll('#tableDetailBody input[type="checkbox"]:checked');
      const deleteBtn = document.getElementById('deleteRowsBtn');
      if (deleteBtn) {
        deleteBtn.style.display = checkboxes.length > 0 ? 'inline-flex' : 'none';
      }
    }
    
    async function deleteSelectedRows() {
      const checkboxes = document.querySelectorAll('#tableDetailBody input[type="checkbox"]:checked');
      
      if (checkboxes.length === 0) {
        addMessageToChat('system error', ' No rows selected');
        return;
      }
      
      // Use custom confirmation instead of browser confirm() due to sandbox restrictions
      const shouldDelete = await showCustomConfirm(`Delete ${checkboxes.length} row(s)?`);
      if (!shouldDelete) return;
      
      const tableName = document.getElementById('currentTableName').textContent;
      const rows = window.currentTableRows;
      
      if (!rows) return;
      
      // Get ID column for WHERE clause
      const idColumns = Object.keys(rows[0]).filter(col => 
        col.toLowerCase().includes('id') || col.toLowerCase() === 'id'
      );
      
      if (idColumns.length === 0) {
        addMessageToChat('system error', ' Cannot delete: No ID column found');
        return;
      }
      
      const idColumn = idColumns[0];
      
      // Collect IDs of selected rows
      const rowsToDelete = [];
      checkboxes.forEach((checkbox, index) => {
        const row = rows[index];
        if (row) {
          rowsToDelete.push(row[idColumn]);
        }
      });
      
      addMessageToChat('system', ` Deleting ${rowsToDelete.length} row(s)...`);
      
      try {
        // Delete each row
        for (const id of rowsToDelete) {
          const response = await fetch(`${API_BASE}/api/table/delete`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              table_name: tableName,
              where_clause: `${idColumn} = '${id}'`
            })
          });
          
          if (!response.ok) {
            throw new Error(`Failed to delete row ${id}`);
          }
        }
        
        addMessageToChat('system', ` Deleted ${rowsToDelete.length} row(s) successfully`);
        
        // Refresh table data
        refreshTableData();
      } catch (error) {
        console.error('Delete error:', error);
        addMessageToChat('system error', ` Failed to delete rows: ${error.message}`);
      }
    }
    
    async function deleteCurrentTable() {
      const tableName = document.getElementById('currentTableName').textContent;
      
      if (!tableName) return;
      
      // Use custom confirmation instead of browser confirm() due to sandbox restrictions
      const shouldDelete = await showCustomConfirm(` WARNING: This will permanently delete the table "${tableName}" and ALL its data.\n\nThis action cannot be undone!\n\nAre you sure?`, true);
      if (!shouldDelete) return;
      
      addMessageToChat('system', ` Deleting table "${tableName}"...`);
      
      try {
        // Drop the table using SQL
        const dropSQL = `DROP TABLE \`gcp-trtools-dev.digital_connection.${tableName}\``;
        
        const response = await fetch(`${API_BASE}/api/query`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sql: dropSQL
          })
        });
        
        if (!response.ok) {
          throw new Error(`Failed to delete table: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.success) {
          addMessageToChat('system', ` Table "${tableName}" deleted successfully`);
          
          // Go back to table list
          backToTableList();
          
          // Refresh table list
          await loadDatabaseTables();
        } else {
          throw new Error(data.error || 'Failed to delete table');
        }
      } catch (error) {
        console.error('Delete table error:', error);
        addMessageToChat('system error', ` Failed to delete table: ${error.message}`);
      }
    }
    
    // ===== PROJECT MANAGEMENT FUNCTIONS =====
    
    /**
     * Ensure project HTML cache table exists
     * Called on app load if a project is active
     * Only creates table if it doesn't exist (checks first with query)
     */
    async function ensureProjectTableExists(projectId) {
      if (!projectId) return;
      
      const tableName = `${projectId}_html_cache`;
      console.log(` Checking if table ${tableName} exists...`);
      
      try {
        // First, try to query the table to see if it exists
        const checkResponse = await fetch(`${API_BASE}/api/table/query`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            table_name: tableName,
            limit: 1
          })
        });
        
        const checkData = await checkResponse.json();
        
        // If table doesn't exist, create it (only for new projects)
        if (!checkResponse.ok || (checkData.error && checkData.error.includes('does not exist'))) {
          console.log(` HTML cache table not found, creating it...`);
          
          const createResponse = await fetch(`${API_BASE}/api/table/create`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              table_name: tableName,
              schema: [
                { name: 'cache_id', type: 'STRING', nullable: false },
                { name: 'page_name', type: 'STRING', nullable: false },
                { name: 'html_content', type: 'STRING', nullable: false },
                { name: 'created_timestamp', type: 'TIMESTAMP', nullable: true },
                { name: 'last_updated', type: 'TIMESTAMP', nullable: true },
                { name: 'version', type: 'STRING', nullable: true },
                { name: 'is_active', type: 'BOOL', nullable: true }
              ]
            })
          });
          
          if (createResponse.ok) {
            const createData = await createResponse.json();
            console.log(` Project HTML cache table created: ${tableName}`);
          } else {
            console.error(' Failed to create HTML cache table');
          }
        } else {
          console.log(` Table ${tableName} already exists`);
        }
      } catch (error) {
        console.error(' Error checking/creating project table:', error);
        // Don't block app loading if this fails
      }
    }
    
    /**
     * Open new project modal
     */
    function startNewProject() {
      const modal = document.getElementById('newProjectModal');
      modal.classList.add('show');
      
      // Clear form
      document.getElementById('newProjectForm').reset();
      
      // Focus on name input
      setTimeout(() => {
        document.getElementById('newProjectName').focus();
      }, 100);
      
      initLucideIcons();
    }
    
    /**
     * Show add column modal
     */
    function showAddColumnModal() {
      const tableName = document.getElementById('currentTableName').textContent;
      
      if (!tableName) {
        addMessageToChat('system error', ' Please select a table first');
        return;
      }
      
      const modal = document.getElementById('addColumnModal');
      modal.classList.add('show');
      
      // Clear form
      document.getElementById('addColumnForm').reset();
      
      // Focus on name input
      setTimeout(() => {
        document.getElementById('newColumnName').focus();
      }, 100);
      
      initLucideIcons();
    }
    
    /**
     * Close add column modal
     */
    function closeAddColumnModal() {
      const modal = document.getElementById('addColumnModal');
      modal.classList.remove('show');
    }
    
    /**
     * Add new column to current table
     */
    async function addNewColumn(event) {
      event.preventDefault();
      
      const tableName = document.getElementById('currentTableName').textContent;
      
      if (!tableName) {
        addMessageToChat('system error', ' No table selected');
        return;
      }
      
      const form = document.getElementById('addColumnForm');
      const formData = new FormData(form);
      const columnName = formData.get('column_name').trim().toLowerCase();
      const columnType = formData.get('column_type');
      let defaultValue = formData.get('default_value').trim();
      
      // Validate inputs
      if (!columnName || !columnType) {
        addMessageToChat('system error', ' Column name and type are required');
        return;
      }
      
      // Convert default value to appropriate type if provided
      if (defaultValue) {
        if (columnType === 'INT64' || columnType === 'FLOAT64') {
          defaultValue = parseFloat(defaultValue);
          if (isNaN(defaultValue)) {
            addMessageToChat('system error', ' Invalid number for default value');
            return;
          }
        } else if (columnType === 'BOOL') {
          defaultValue = defaultValue.toLowerCase() === 'true' || defaultValue === '1';
        }
      } else {
        defaultValue = null;
      }
      
      try {
        addMessageToChat('system', ` Adding column '${columnName}' to table '${tableName}'...`);
        
        const response = await fetch(`${API_BASE}/api/table/add-column`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            table_name: tableName,
            column_name: columnName,
            column_type: columnType,
            default_value: defaultValue
          })
        });
        
        const result = await response.json();
        
        if (result.success) {
          addMessageToChat('system', ` Column '${columnName}' (${columnType}) added successfully!`);
          closeAddColumnModal();
          
          // Reload table data to show new column
          await viewTable(tableName);
        } else {
          addMessageToChat('system error', ` Failed to add column: ${result.error || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('Error adding column:', error);
        addMessageToChat('system error', ` Error adding column: ${error.message}`);
      }
    }
    
    /**
     * Close new project modal
     */
    function closeNewProjectModal() {
      const modal = document.getElementById('newProjectModal');
      modal.classList.remove('show');
    }
    
    /**
     * Create new project
     */
    async function createNewProject(event) {
      event.preventDefault();
      
      const form = document.getElementById('newProjectForm');
      const formData = new FormData(form);
      const projectName = formData.get('project_name').trim();
      const description = formData.get('description').trim();
      
      if (!projectName) {
        addMessageToChat('system error', 'Project name is required');
        return;
      }
      
      // Close modal
      closeNewProjectModal();
      
      // Show creating message
      addMessageToChat('system', ` Creating project "${projectName}"...`);
      
      try {
        const response = await fetch(`${API_BASE}/api/project/create`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            project_name: projectName,
            description: description || null
          })
        });
        
        if (!response.ok) {
          throw new Error(`Failed to create project: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.success) {
          console.log(' Project created:', data);
          
          // Set as current project
          currentProjectId = data.project_id;
          localStorage.setItem('currentProjectId', currentProjectId);
          
          // Clear out old project UI/HTML
          console.log(' Clearing previous project HTML...');
          generatedHTML = '';
          versionHistory = [];
          currentVersionIndex = -1;
          currentVersionNumber = 0; // Will be set to 1 on first save (gets incremented before save)
          chatConversationHistory = [];
          chatUIMessages = [];
          loadedChatHistory = [];
          loadedChatHistorySummary = '';
          needsHistorySummaryInjection = false;
          conversationHasFullHTML = false; // Reset flag when clearing history
          
          // Clear database version cache
          dbVersions = [];
          currentDBVersionIndex = -1;
          
          // Clear preview iframe - show welcome screen
          const preview = document.getElementById('previewFrame');
          const loading = document.getElementById('previewLoading');
          if (preview && loading) {
            loading.classList.remove('hidden');
            preview.classList.remove('loaded');
            showWelcomeScreen();
          }
          
          // Clear code view
          updateCodeView('');
          
          // Clear chat messages when switching projects (fresh start for new project)
          const chatMessages = document.getElementById('chatMessages');
          if (chatMessages) {
            chatMessages.innerHTML = '';
            console.log(' Chat messages cleared for new project');
          }
          
          // Hide version info
          const versionInfo = document.getElementById('versionInfo');
          if (versionInfo) {
            versionInfo.style.display = 'none';
          }
          
          console.log(' Previous project UI cleared');
          
          // Set default design framework to Living Design 3.5 for new projects
          currentDesignFramework = 'living-design';
          console.log(' Default design framework set to: Living Design 3.5');
          
          // Update framework UI indicator (main chat)
          const displayElement = document.getElementById('selectedFrameworkDisplay');
          const labelElement = document.getElementById('selectedFrameworkLabel');
          if (displayElement && labelElement) {
            displayElement.style.display = 'flex';
            labelElement.textContent = 'Living Design 3.5';
          }
          
          // Update minimal mode framework indicator
          const minimalDisplayElement = document.getElementById('minimalFrameworkDisplay');
          const minimalLabelElement = document.getElementById('minimalFrameworkLabel');
          if (minimalDisplayElement && minimalLabelElement) {
            minimalLabelElement.textContent = 'Living Design 3.5';
          }
          
          // Update radio button selection
          const radioButton = document.querySelector('input[name="designFramework"][value="living-design"]');
          if (radioButton) {
            radioButton.checked = true;
          }
          
          // Ensure chat history table exists for this new project
          await ensureProjectChatHistoryTable(currentProjectId);
          
          // Reload projects list
          await loadProjects();
          
          // Update project selector
          updateProjectSelector();
          
          // Switch to database view to show the project's tables
          switchMainTab('cloud');
          switchCloudNav('database');
          
          // Refresh database tables
          await loadDatabaseTables();
          
          addMessageToChat('system', ` Project "${projectName}" created successfully!\nProject ID: ${data.project_id}\nDefault HTML cache table created: ${data.html_cache_table}\n Design framework set to: Living Design 3.5`);
        } else {
          throw new Error(data.message || 'Failed to create project');
        }
      } catch (error) {
        console.error('Error creating project:', error);
        addMessageToChat('system error', ` Failed to create project: ${error.message}`);
      }
    }
    
    /**
     * Validate CRUD operations for a project's tables
     */
    async function validateProjectCRUD(projectId) {
      console.log(` Validating CRUD operations for project: ${projectId}`);
      
      try {
        // Get list of tables for this project
        const tablesResponse = await fetch(`${API_BASE}/api/project/tables?project_id=${projectId}`);
        
        if (!tablesResponse.ok) {
          console.warn(' Could not fetch tables for validation');
          return { success: false, error: 'Could not fetch tables' };
        }
        
        const tablesData = await tablesResponse.json();
        if (!tablesData.success || !tablesData.tables || tablesData.tables.length === 0) {
          console.log(' No tables to validate for this project');
          return { success: true, message: 'No tables found' };
        }
        
        const results = {
          project_id: projectId,
          tables_validated: 0,
          tables_passed: 0,
          tables_failed: 0,
          details: []
        };
        
        // Test each table (excluding system tables)
        for (const table of tablesData.tables) {
          const tableName = table.table_name || table;
          
          // Skip system tables
          if (tableName.includes('_html_cache') || tableName.includes('_chat_history')) {
            continue;
          }
          
          results.tables_validated++;
          
          const tableResult = {
            table: tableName,
            operations: {
              query: false,
              insert: false,
              update: false,
              delete: false
            },
            errors: []
          };
          
          // Test QUERY
          try {
            const queryResponse = await fetch(`${API_BASE}/api/table/query`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                table_name: tableName,
                limit: 1
              })
            });
            tableResult.operations.query = queryResponse.ok;
            if (!queryResponse.ok) {
              tableResult.errors.push(`Query failed: ${queryResponse.status}`);
            }
          } catch (err) {
            tableResult.errors.push(`Query error: ${err.message}`);
          }
          
          // Test INSERT (create a test record)
          const testId = `validation_test_${Date.now()}`;
          try {
            const insertResponse = await fetch(`${API_BASE}/api/table/insert`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                table_name: tableName,
                data: { id: testId, validation_test: true }
              })
            });
            tableResult.operations.insert = insertResponse.ok;
            if (!insertResponse.ok) {
              tableResult.errors.push(`Insert failed: ${insertResponse.status}`);
            }
          } catch (err) {
            tableResult.errors.push(`Insert error: ${err.message}`);
          }
          
          // Test UPDATE (if insert succeeded)
          if (tableResult.operations.insert) {
            try {
              const updateResponse = await fetch(`${API_BASE}/api/table/update`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  table_name: tableName,
                  updates: { validation_test: false },
                  where_clause: `id = '${testId}'`
                })
              });
              tableResult.operations.update = updateResponse.ok;
              if (!updateResponse.ok) {
                tableResult.errors.push(`Update failed: ${updateResponse.status}`);
              }
            } catch (err) {
              tableResult.errors.push(`Update error: ${err.message}`);
            }
          }
          
          // Test DELETE (clean up test record)
          if (tableResult.operations.insert) {
            try {
              const deleteResponse = await fetch(`${API_BASE}/api/table/delete`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  table_name: tableName,
                  where_clause: `id = '${testId}'`
                })
              });
              tableResult.operations.delete = deleteResponse.ok;
              if (!deleteResponse.ok) {
                tableResult.errors.push(`Delete failed: ${deleteResponse.status}`);
              }
            } catch (err) {
              tableResult.errors.push(`Delete error: ${err.message}`);
            }
          }
          
          // Check if all operations passed
          const allPassed = tableResult.operations.query && 
                           tableResult.operations.insert && 
                           tableResult.operations.update && 
                           tableResult.operations.delete;
          
          if (allPassed) {
            results.tables_passed++;
            console.log(` ${tableName}: All CRUD operations working`);
          } else {
            results.tables_failed++;
            console.warn(` ${tableName}: Some operations failed`, tableResult.errors);
          }
          
          results.details.push(tableResult);
        }
        
        // Summary
        console.log(`\n CRUD Validation Summary:`);
        console.log(`   Tables validated: ${results.tables_validated}`);
        console.log(`   Passed: ${results.tables_passed}`);
        console.log(`   Failed: ${results.tables_failed}`);
        
        return {
          success: results.tables_failed === 0,
          results: results
        };
        
      } catch (error) {
        console.error(' CRUD validation error:', error);
        return { success: false, error: error.message };
      }
    }
    
    /**
     * Load all projects from API
     */
    async function loadProjects() {
      try {
        const response = await fetch(`${API_BASE}/api/projects`);
        
        if (!response.ok) {
          throw new Error(`Failed to load projects: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.success) {
          allProjects = data.projects || [];
          console.log(` Loaded ${allProjects.length} projects`);
          
          // DO NOT auto-select first project - let user choose
          // Keep currentProjectId as-is (null on initial load, or whatever was set)
          if (currentProjectId) {
            // If a project is already set, update the project name
            const project = allProjects.find(p => p.project_id === currentProjectId);
            if (project) {
              currentProjectName = project.project_name;
            } else {
              // Project ID doesn't exist anymore, clear it
              currentProjectId = null;
              currentProjectName = null;
              localStorage.removeItem('currentProjectId');
            }
          }
          
          return allProjects;
        } else {
          console.warn('Failed to load projects:', data);
          return [];
        }
      } catch (error) {
        console.error('Error loading projects:', error);
        return [];
      }
    }
    
    /**
     * Abort any ongoing project switch operations
     */
    function abortProjectSwitch() {
      if (projectSwitchAbortController) {
        console.log(' Aborting previous project switch operations...');
        projectSwitchAbortController.abort();
        projectSwitchAbortController = null;
      }
      
      // Hide loading indicators immediately
      const loading = document.getElementById('previewLoading');
      if (loading) {
        loading.classList.add('hidden');
      }
      
      // Clear any pending promises
      chatHistoryLoadingPromise = null;
      
      console.log(' Previous project switch aborted and cleaned up');
    }
    
    /**
     * Select a project (switch active project)
     */
    async function selectProject(projectId) {
      if (projectId === currentProjectId) return; // Already selected
      
      // CRITICAL: Abort any ongoing project switch operations FIRST
      abortProjectSwitch();
      
      // Reset lock (we've aborted previous operations, so we can proceed)
      isProjectSwitching = true;
      
      // Create new abort controller for this switch
      projectSwitchAbortController = new AbortController();
      const signal = projectSwitchAbortController.signal;
      console.log(' Switching to project:', projectId);
      
      // CRITICAL: Store the old project ID for cleanup
      const oldProjectId = currentProjectId;
      
      // CRITICAL: Update project ID FIRST before any async operations
      currentProjectId = projectId;
      localStorage.setItem('currentProjectId', projectId);
      
      // Show Walmart-themed loading animation
      const preview = document.getElementById('previewFrame');
      const loading = document.getElementById('previewLoading');
      
      if (loading) {
        loading.classList.remove('hidden');
        loading.innerHTML = `
          <svg width="64" height="64" viewBox="0 0 532 600" style="animation: spinner-spin 1s linear infinite; margin-bottom: 16px;">
            <path fill="#FFC220" d="M375.663,273.363c12.505-2.575,123.146-53.269,133.021-58.97c22.547-13.017,30.271-41.847,17.254-64.393s-41.847-30.271-64.393-17.254c-9.876,5.702-109.099,76.172-117.581,85.715c-9.721,10.937-11.402,26.579-4.211,39.033C346.945,269.949,361.331,276.314,375.663,273.363z"/>
            <path fill="#FFC220" d="M508.685,385.607c-9.876-5.702-120.516-56.396-133.021-58.97c-14.332-2.951-28.719,3.415-35.909,15.87c-7.191,12.455-5.51,28.097,4.211,39.033c8.482,9.542,107.705,80.013,117.581,85.715c22.546,13.017,51.376,5.292,64.393-17.254S531.231,398.624,508.685,385.607z"/>
            <path fill="#FFC220" d="M266.131,385.012c-14.382,0-27.088,9.276-31.698,23.164c-4.023,12.117-15.441,133.282-15.441,144.685c0,26.034,21.105,47.139,47.139,47.139c26.034,0,47.139-21.105,47.139-47.139c0-11.403-11.418-132.568-15.441-144.685C293.219,394.288,280.513,385.012,266.131,385.012z"/>
            <path fill="#FFC220" d="M156.599,326.637c-12.505,2.575-123.146,53.269-133.021,58.97C1.031,398.624-6.694,427.454,6.323,450c13.017,22.546,41.847,30.271,64.393,17.254c9.876-5.702,109.098-76.172,117.58-85.715c9.722-10.937,11.402-26.579,4.211-39.033S170.931,323.686,156.599,326.637z"/>
            <path fill="#FFC220" d="M70.717,132.746C48.171,119.729,19.341,127.454,6.323,150c-13.017,22.546-5.292,51.376,17.254,64.393c9.876,5.702,120.517,56.396,133.021,58.97c14.332,2.951,28.719-3.415,35.91-15.87c7.191-12.455,5.51-28.096-4.211-39.033C179.815,208.918,80.592,138.447,70.717,132.746z"/>
            <path fill="#FFC220" d="M266.131,0c-26.035,0-47.139,21.105-47.139,47.139c0,11.403,11.418,132.568,15.441,144.685c4.611,13.888,17.317,23.164,31.698,23.164s27.088-9.276,31.698-23.164c4.023-12.117,15.441-133.282,15.441-144.685C313.27,21.105,292.165,0,266.131,0z"/>
          </svg>
          <p style="color: var(--text-secondary); font-size: 14px;">Switching projects...</p>
        `;
      }
      if (preview) preview.classList.remove('loaded');
      
      // CRITICAL: Force complete state reset SYNCHRONOUSLY before any async operations
      // This prevents old project data from bleeding into new project
      console.log(' Clearing all state for old project:', oldProjectId);
      
      // Clear HTML and preview immediately
      generatedHTML = '';
      if (preview) preview.srcdoc = '';
      
      // Clear version history
      dbVersions = [];
      currentDBVersionIndex = -1;
      currentVersionNumber = 0;
      versionHistory = [];
      currentVersionIndex = -1;
      
      // Clear chat state
      chatConversationHistory = [];
      chatUIMessages = [];
      loadedChatHistory = [];
      loadedChatHistorySummary = '';
      needsHistorySummaryInjection = false;
      conversationHasFullHTML = false;
      
      // Clear reference images
      referenceImages = [];
      referenceImageData = null;
      referenceImageName = null;
      const refDisplay = document.getElementById('referenceImageDisplay');
      if (refDisplay) refDisplay.style.display = 'none';
      
      // Clear chat UI
      const chatMessages = document.getElementById('chatMessages');
      if (chatMessages) {
        chatMessages.innerHTML = '';
      }
      
      // Clear localStorage for old project (prevent cache contamination)
      if (oldProjectId) {
        localStorage.removeItem(`${oldProjectId}_currentHTML`);
        localStorage.removeItem(`${oldProjectId}_chatHistory`);
      }
      
      console.log(' State cleared, now loading new project:', projectId);
      
      // Ensure HTML cache table exists for this project
      await ensureProjectHtmlCacheTable(projectId);
      
      // Ensure chat history table exists for this project
      await ensureProjectChatHistoryTable(projectId);
      
      // Update UI
      updateProjectSelector();
      
      // Refresh database tables view if on database tab
      if (currentCloudNav === 'database') {
        await loadDatabaseTables();
      }
      
      // CRITICAL: Verify project hasn't changed during async operations
      if (currentProjectId !== projectId || signal.aborted) {
        console.warn(' Project changed or aborted during switch, aborting load for:', projectId);
        isProjectSwitching = false;
        return;
      }
      
      // Load the latest HTML from this project's cache with abort signal
      try {
        await loadLatestProject(signal);
      } catch (error) {
        if (error.name === 'AbortError') {
          console.log(' HTML load aborted for project:', projectId);
          isProjectSwitching = false;
          return;
        }
        throw error;
      }
      
      // CRITICAL: Double-check after HTML load
      if (currentProjectId !== projectId || signal.aborted) {
        console.warn(' Project changed or aborted during HTML load, aborting for:', projectId);
        isProjectSwitching = false;
        return;
      }
      
      // Load versions from database for navigation with abort signal
      try {
        await loadDBVersions(signal);
      } catch (error) {
        if (error.name === 'AbortError') {
          console.log(' DB versions load aborted for project:', projectId);
          isProjectSwitching = false;
          return;
        }
        throw error;
      }
      
      // Load chat history for this project with abort signal
      try {
        chatHistoryLoadingPromise = loadChatHistory(signal);
        await chatHistoryLoadingPromise;
        chatHistoryLoadingPromise = null;
      } catch (error) {
        if (error.name === 'AbortError') {
          console.log(' Chat history load aborted for project:', projectId);
          isProjectSwitching = false;
          return;
        }
        throw error;
      }
      
      // CRITICAL: Final verification before validation
      if (currentProjectId !== projectId || signal.aborted) {
        console.warn(' Project changed or aborted during chat history load, aborting for:', projectId);
        isProjectSwitching = false;
        return;
      }
      
      // Note: CRUD validation disabled - not needed on every project switch
      // Uncomment only for debugging/development
      // console.log(' Running CRUD validation for project tables...');
      // const validationResult = await validateProjectCRUD(projectId);
      // 
      // if (validationResult.success && validationResult.results) {
      //   const { tables_validated, tables_passed, tables_failed } = validationResult.results;
      //   if (tables_validated > 0) {
      //     if (tables_failed > 0) {
      //       console.warn(` CRUD validation completed with failures: ${tables_failed}/${tables_validated} tables failed`);
      //       // Optionally show warning to user
      //       addMessageToChat('system', ` Database validation: ${tables_failed} of ${tables_validated} tables have CRUD issues. Check console for details.`);
      //     } else {
      //       console.log(` CRUD validation passed: All ${tables_validated} tables working correctly`);
      //     }
      //   }
      // } else if (!validationResult.success && validationResult.error) {
      //   console.error(' CRUD validation failed:', validationResult.error);
      // }
      
      // Find project and update current project name
      const project = allProjects.find(p => p.project_id === projectId);
      if (project) {
        currentProjectName = project.project_name;
      }
      
      // Note: updatePublishStatusIndicator() removed - publish links approach changed
      // await updatePublishStatusIndicator();
      
      // Add notification (only if no history was loaded)
      if (project && chatUIMessages.length === 0) {
        addMessageToChat('system', ` Switched to project: ${project.project_name}`);
      }
      
      // Release the lock - project switch complete
      isProjectSwitching = false;
      console.log(' Project switch complete:', projectId);
    }
    
    /**
     * Show custom delete confirmation modal
     * Returns user input or null if cancelled
     */
    function showDeleteConfirmationModal(projectName, projectId) {
      return new Promise((resolve) => {
        // Create modal overlay
        const modalOverlay = document.createElement('div');
        modalOverlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.7);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
          animation: fadeIn 0.2s ease;
        `;
        
        // Create modal content
        const modal = document.createElement('div');
        modal.style.cssText = `
          background: #1e1e1e;
          border: 2px solid #dc3545;
          border-radius: 12px;
          padding: 24px;
          max-width: 500px;
          width: 90%;
          box-shadow: 0 8px 32px rgba(220, 53, 69, 0.3);
          animation: slideIn 0.3s ease;
        `;
        
        modal.innerHTML = `
          <div style="margin-bottom: 20px;">
            <h3 style="color: #ff6b7a; margin: 0 0 16px 0; font-size: 18px; display: flex; align-items: center; gap: 8px;">
              <span style="font-size: 24px;"></span> DELETE PROJECT
            </h3>
            <div style="background: rgba(220, 53, 69, 0.1); border-left: 3px solid #dc3545; padding: 12px; margin-bottom: 16px; border-radius: 4px;">
              <p style="margin: 0; color: #ff6b7a; font-weight: 600;">${projectName}</p>
            </div>
            <div style="color: #ccc; font-size: 14px; line-height: 1.6;">
              <p style="margin: 0 0 12px 0; font-weight: 600;">This will permanently delete:</p>
              <ul style="margin: 0 0 12px 0; padding-left: 20px;">
                <li>All HTML versions and cache</li>
                <li>All database tables (${projectId}_*)</li>
                <li>All published files</li>
                <li>All chat history</li>
              </ul>
              <p style="margin: 0; color: #ff6b7a; font-weight: 600;"> This action CANNOT be undone!</p>
            </div>
          </div>
          
          <div style="margin-bottom: 20px;">
            <label style="display: block; color: #fff; font-size: 13px; margin-bottom: 8px; font-weight: 600;">
              Type "<span style="color: #ff6b7a;">${projectName}</span>" to confirm:
            </label>
            <input type="text" id="deleteConfirmInput" 
              placeholder="Enter project name here"
              style="width: 100%; padding: 10px 12px; background: #2d2d2d; border: 2px solid #555; border-radius: 6px; color: #fff; font-size: 14px; box-sizing: border-box;"
              autocomplete="off"
              spellcheck="false"
            />
            <div id="deleteConfirmError" style="color: #ff6b7a; font-size: 12px; margin-top: 6px; min-height: 18px;"></div>
          </div>
          
          <div style="display: flex; gap: 12px; justify-content: flex-end;">
            <button id="deleteCancelBtn" style="padding: 10px 20px; background: #2d2d2d; border: 1px solid #555; color: #ccc; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
              Cancel
            </button>
            <button id="deleteConfirmBtn" style="padding: 10px 20px; background: #dc3545; border: 1px solid #dc3545; color: #fff; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
              Delete Project
            </button>
          </div>
        `;
        
        modalOverlay.appendChild(modal);
        document.body.appendChild(modalOverlay);
        
        // Get elements
        const input = modal.querySelector('#deleteConfirmInput');
        const errorDiv = modal.querySelector('#deleteConfirmError');
        const confirmBtn = modal.querySelector('#deleteConfirmBtn');
        const cancelBtn = modal.querySelector('#deleteCancelBtn');
        
        // Focus input
        setTimeout(() => input.focus(), 100);
        
        // Real-time validation
        input.addEventListener('input', () => {
          const value = input.value.trim();
          if (value && value !== projectName) {
            errorDiv.textContent = ' Project name does not match';
            input.style.borderColor = '#dc3545';
            confirmBtn.disabled = true;
            confirmBtn.style.opacity = '0.5';
          } else if (value === projectName) {
            errorDiv.textContent = ' Confirmed';
            errorDiv.style.color = '#4caf50';
            input.style.borderColor = '#4caf50';
            confirmBtn.disabled = false;
            confirmBtn.style.opacity = '1';
          } else {
            errorDiv.textContent = '';
            input.style.borderColor = '#555';
            confirmBtn.disabled = true;
            confirmBtn.style.opacity = '0.5';
          }
        });
        
        // Initially disable confirm button
        confirmBtn.disabled = true;
        confirmBtn.style.opacity = '0.5';
        
        // Confirm button click
        confirmBtn.addEventListener('click', () => {
          const value = input.value.trim();
          if (value === projectName) {
            document.body.removeChild(modalOverlay);
            resolve(value);
          }
        });
        
        // Cancel button click
        cancelBtn.addEventListener('click', () => {
          document.body.removeChild(modalOverlay);
          resolve(null);
        });
        
        // Enter key to confirm
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && input.value.trim() === projectName) {
            e.preventDefault();
            confirmBtn.click();
          } else if (e.key === 'Escape') {
            e.preventDefault();
            cancelBtn.click();
          }
        });
        
        // Click outside to cancel
        modalOverlay.addEventListener('click', (e) => {
          if (e.target === modalOverlay) {
            cancelBtn.click();
          }
        });
      });
    }
    
    /**
     * Delete the current project and all its artifacts
     */
    async function deleteCurrentProject() {
      if (!currentProjectId) {
        addMessageToChat('system error', ' No project selected to delete');
        return;
      }
      
      // Prevent deletion during project switch
      if (isProjectSwitching) {
        addMessageToChat('system error', ' Please wait for project switch to complete');
        return;
      }
      
      // Find project details
      const project = allProjects.find(p => p.project_id === currentProjectId);
      if (!project) {
        addMessageToChat('system error', ' Project not found');
        return;
      }
      
      // Create custom confirmation modal
      const projectName = project.project_name;
      const userInput = await showDeleteConfirmationModal(projectName, currentProjectId);
      
      if (userInput !== projectName) {
        if (userInput !== null) {
          addMessageToChat('system', ' Project deletion cancelled - name did not match');
        }
        return;
      }
      
      console.log(' Deleting project:', currentProjectId, projectName);
      addMessageToChat('system', ` Deleting project "${projectName}"... This may take a moment.`);
      
      // Disable delete button during operation
      const deleteBtn = document.getElementById('btnDeleteProject');
      if (deleteBtn) {
        deleteBtn.disabled = true;
        deleteBtn.style.opacity = '0.5';
      }
      
      try {
        // Call API to delete project
        const response = await fetch(`${API_BASE}/api/project/delete`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            project_id: currentProjectId
          })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`API returned ${response.status}: ${errorText.substring(0, 200)}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
          console.log(' Project deleted successfully');
          console.log(`   Deleted ${result.deleted_tables || 0} tables`);
          console.log(`   Deleted ${result.deleted_published ? 'published folder' : 'no published folder'}`);
          
          addMessageToChat('system', ` Project "${projectName}" deleted successfully`);
          if (result.deleted_tables > 0) {
            addMessageToChat('system', `    Removed ${result.deleted_tables} database tables`);
          }
          if (result.deleted_published) {
            addMessageToChat('system', `    Removed published files`);
          }
          
          // Remove from local array
          allProjects = allProjects.filter(p => p.project_id !== currentProjectId);
          
          // Clear state
          currentProjectId = null;
          localStorage.removeItem('currentProjectId');
          generatedHTML = '';
          dbVersions = [];
          chatConversationHistory = [];
          chatUIMessages = [];
          
          // Update UI
          updateProjectSelector();
          
          // Show welcome screen
          const preview = document.getElementById('previewFrame');
          if (preview) {
            showWelcomeScreen();
          }
          
          // Clear chat
          const chatMessages = document.getElementById('chatMessages');
          if (chatMessages) {
            chatMessages.innerHTML = '';
          }
          
          // Re-enable button
          if (deleteBtn) {
            deleteBtn.disabled = false;
            deleteBtn.style.opacity = '1';
          }
          
          // Reload overview data
          await loadOverviewData();
          
        } else {
          throw new Error(result.error || 'Delete failed');
        }
      } catch (error) {
        console.error(' Failed to delete project:', error);
        addMessageToChat('system error', ` Failed to delete project: ${error.message}`);
        
        // Re-enable button
        if (deleteBtn) {
          deleteBtn.disabled = false;
          deleteBtn.style.opacity = '1';
        }
      }
    }
    
    /**
     * Ensure project has HTML cache table
     */
    async function ensureProjectHtmlCacheTable(projectId) {
      if (!projectId) return;
      
      const htmlCacheTableName = `${projectId}_html_cache`;
      
      console.log(' Checking if HTML cache table exists:', htmlCacheTableName);
      
      try {
        // Try to query the table to see if it exists
        const checkResponse = await fetch(`${API_BASE}/api/table/query`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            table_name: htmlCacheTableName,
            limit: 1
          })
        });
        
        const checkData = await checkResponse.json();
        
        // If table doesn't exist, create it
        if (!checkResponse.ok || (checkData.error && checkData.error.includes('does not exist'))) {
          console.log(' HTML cache table not found, creating it...');
          
          const createResponse = await fetch(`${API_BASE}/api/table/create`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              table_name: htmlCacheTableName,
              schema: [
                { name: 'cache_id', type: 'STRING', nullable: false },
                { name: 'page_name', type: 'STRING', nullable: false },
                { name: 'html_content', type: 'STRING', nullable: false },
                { name: 'created_timestamp', type: 'TIMESTAMP', nullable: true },
                { name: 'last_updated', type: 'TIMESTAMP', nullable: true },
                { name: 'version', type: 'STRING', nullable: true },
                { name: 'is_active', type: 'BOOL', nullable: true }
              ]
            })
          });
          
          if (createResponse.ok) {
            const createData = await createResponse.json();
            console.log(' HTML cache table created:', createData);
          } else {
            console.error(' Failed to create HTML cache table');
          }
        } else {
          console.log(' HTML cache table already exists');
        }
      } catch (error) {
        console.error('Error checking/creating HTML cache table:', error);
      }
    }
    
    /**
     * Ensure project has chat history table
     */
    async function ensureProjectChatHistoryTable(projectId) {
      if (!projectId) return;
      
      const chatHistoryTableName = `${projectId}_chat_history`;
      
      console.log(' Checking if chat history table exists:', chatHistoryTableName);
      
      try {
        // Try to query the table to see if it exists
        const checkResponse = await fetch(`${API_BASE}/api/table/query`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            table_name: chatHistoryTableName,
            limit: 1
          })
        });
        
        const checkData = await checkResponse.json();
        
        // If table doesn't exist, create it
        if (!checkResponse.ok || (checkData.error && checkData.error.includes('does not exist'))) {
          console.log(' Chat history table not found, creating it...');
          
          const createResponse = await fetch(`${API_BASE}/api/table/create`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              table_name: chatHistoryTableName,
              schema: [
                { name: 'project_session', type: 'STRING', nullable: false },
                { name: 'conversation_history', type: 'STRING', nullable: true },
                { name: 'ui_messages', type: 'STRING', nullable: true },
                { name: 'timestamp', type: 'TIMESTAMP', nullable: true }
              ]
            })
          });
          
          if (createResponse.ok) {
            const createData = await createResponse.json();
            console.log(' Chat history table created:', createData);
          } else {
            console.error(' Failed to create chat history table');
          }
        } else {
          console.log(' Chat history table already exists');
        }
      } catch (error) {
        console.error('Error checking/creating chat history table:', error);
      }
    }
    
    /**
     * Update project selector dropdown
     */
    function updateProjectSelector() {
      const selector = document.getElementById('projectSelector');
      if (!selector) return;
      
      // Clear existing options
      selector.innerHTML = '<option value="">No Project Selected</option>';
      
      // Add all projects as options
      allProjects.forEach(project => {
        const option = document.createElement('option');
        option.value = project.project_id;
        option.textContent = project.project_name;
        selector.appendChild(option);
      });
      
      // Set current selection
      selector.value = currentProjectId || '';
      
      // Enable/disable delete button based on whether a project is selected
      const deleteBtn = document.getElementById('btnDeleteProject');
      if (deleteBtn) {
        const hasProject = currentProjectId && currentProjectId !== '';
        deleteBtn.disabled = !hasProject;
        deleteBtn.style.opacity = hasProject ? '1' : '0.3';
        deleteBtn.style.cursor = hasProject ? 'pointer' : 'not-allowed';
        deleteBtn.title = hasProject ? 'Delete Current Project' : 'No project selected';
      }
    }
    
    /**
     * Get tables for current project
     */
    async function getProjectTables() {
      if (!currentProjectId) {
        return [];
      }
      
      try {
        const response = await fetch(`${API_BASE}/api/project/tables?project_id=${currentProjectId}`);
        
        if (!response.ok) {
          throw new Error(`Failed to load project tables: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.success) {
          return data.tables || [];
        } else {
          console.warn('Failed to load project tables:', data);
          return [];
        }
      } catch (error) {
        console.error('Error loading project tables:', error);
        return [];
      }
    }
    
    // ===== TABLE CREATION FUNCTIONS =====
    
    let schemaColumns = [];
    
    function openCreateTableModal() {
      if (!currentProjectId) {
        addMessageToChat('system error', ' Please select a project first');
        return;
      }
      
      const modal = document.getElementById('createTableModal');
      modal.classList.add('show');
      
      // Update project info
      const project = allProjects.find(p => p.project_id === currentProjectId);
      const projectInfo = document.getElementById('createTableProjectInfo');
      if (projectInfo && project) {
        projectInfo.textContent = `Project: ${project.project_name} (${currentProjectId})`;
      }
      
      // Reset form
      document.getElementById('createTableForm').reset();
      schemaColumns = [];
      
      // Add default ID column
      addSchemaColumn('id', 'STRING', false);
      
      // Focus on table name input
      setTimeout(() => {
        document.getElementById('newTableName').focus();
      }, 100);
      
      initLucideIcons();
    }
    
    function closeCreateTableModal() {
      const modal = document.getElementById('createTableModal');
      modal.classList.remove('show');
      schemaColumns = [];
    }
    
    function addSchemaColumn(defaultName = '', defaultType = 'STRING', defaultNullable = true) {
      const columnId = `col_${Date.now()}_${Math.random().toString(36).substr(2, 4)}`;
      
      schemaColumns.push({
        id: columnId,
        name: defaultName,
        type: defaultType,
        nullable: defaultNullable
      });
      
      renderSchemaBuilder();
    }
    
    function removeSchemaColumn(columnId) {
      schemaColumns = schemaColumns.filter(col => col.id !== columnId);
      renderSchemaBuilder();
    }
    
    function renderSchemaBuilder() {
      const builder = document.getElementById('schemaBuilder');
      
      builder.innerHTML = schemaColumns.map((col, index) => `
        <div style="display: flex; gap: var(--space-2); align-items: flex-start; padding: var(--space-3); background: var(--surface-gray); border-radius: 8px;">
          <div style="flex: 1;">
            <input 
              type="text" 
              placeholder="Column name" 
              value="${col.name}"
              onchange="updateSchemaColumn('${col.id}', 'name', this.value)"
              style="width: 100%; padding: 8px 12px; border: 1px solid var(--border-gray); border-radius: 6px; font-size: 13px; margin-bottom: 8px;"
              required
            >
          </div>
          <div style="flex: 1;">
            <select 
              onchange="updateSchemaColumn('${col.id}', 'type', this.value)"
              style="width: 100%; padding: 8px 12px; border: 1px solid var(--border-gray); border-radius: 6px; font-size: 13px; margin-bottom: 8px;"
            >
              <option value="STRING" ${col.type === 'STRING' ? 'selected' : ''}>STRING</option>
              <option value="INT64" ${col.type === 'INT64' ? 'selected' : ''}>INT64</option>
              <option value="FLOAT64" ${col.type === 'FLOAT64' ? 'selected' : ''}>FLOAT64</option>
              <option value="BOOL" ${col.type === 'BOOL' ? 'selected' : ''}>BOOL</option>
              <option value="DATE" ${col.type === 'DATE' ? 'selected' : ''}>DATE</option>
              <option value="TIMESTAMP" ${col.type === 'TIMESTAMP' ? 'selected' : ''}>TIMESTAMP</option>
              <option value="ARRAY<STRING>" ${col.type === 'ARRAY<STRING>' ? 'selected' : ''}>ARRAY&lt;STRING&gt;</option>
            </select>
          </div>
          <label style="display: flex; align-items: center; gap: 6px; white-space: nowrap; font-size: 13px;">
            <input 
              type="checkbox" 
              ${col.nullable ? 'checked' : ''}
              onchange="updateSchemaColumn('${col.id}', 'nullable', this.checked)"
              style="width: 16px; height: 16px;"
            >
            Nullable
          </label>
          <button type="button" onclick="removeSchemaColumn('${col.id}')" class="btn-icon" style="margin-top: 0;">
            <i data-lucide="trash-2"></i>
          </button>
        </div>
      `).join('');
      
      initLucideIcons();
      updateTableNamePreview();
    }
    
    function updateSchemaColumn(columnId, field, value) {
      const column = schemaColumns.find(col => col.id === columnId);
      if (column) {
        column[field] = value;
      }
    }
    
    function updateTableNamePreview() {
      const tableNameInput = document.getElementById('newTableName');
      const preview = document.getElementById('fullTableNamePreview');
      
      if (tableNameInput && preview) {
        const tableName = tableNameInput.value.trim();
        const fullName = currentProjectId && tableName 
          ? `digital_connection.${currentProjectId}_${tableName}`
          : 'digital_connection.[table_name]';
        preview.textContent = fullName;
      }
    }
    
    async function createNewTable(event) {
      event.preventDefault();
      
      if (!currentProjectId) {
        addMessageToChat('system error', ' Please select a project first');
        return;
      }
      
      const tableName = document.getElementById('newTableName').value.trim();
      
      if (!tableName) {
        addMessageToChat('system error', ' Table name is required');
        return;
      }
      
      if (schemaColumns.length === 0) {
        addMessageToChat('system error', ' Please add at least one column');
        return;
      }
      
      // Validate all columns have names
      const invalidColumns = schemaColumns.filter(col => !col.name || col.name.trim() === '');
      if (invalidColumns.length > 0) {
        addMessageToChat('system error', ' All columns must have names');
        return;
      }
      
      // Close modal
      closeCreateTableModal();
      
      // Build full table name with project prefix
      const fullTableName = `${currentProjectId}_${tableName}`;
      
      addMessageToChat('system', ` Creating table "${tableName}" in project...`);
      
      try {
        const response = await fetch(`${API_BASE}/api/table/create`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            table_name: fullTableName,
            schema: schemaColumns.map(col => ({
              name: col.name,
              type: col.type,
              nullable: col.nullable
            }))
          })
        });
        
        if (!response.ok) {
          throw new Error(`Failed to create table: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.success) {
          console.log(' Table created:', data);
          
          // Refresh database tables view
          await loadDatabaseTables();
          
          addMessageToChat('system', ` Table "${tableName}" created successfully!\nFull name: ${fullTableName}\nColumns: ${schemaColumns.length}`);
        } else {
          throw new Error(data.message || 'Failed to create table');
        }
      } catch (error) {
        console.error('Error creating table:', error);
        addMessageToChat('system error', ` Failed to create table: ${error.message}`);
      }
    }
    
    function publishProject() {
      // Use the new publish modal feature
      showPublishModal();
    }
    
    function undoLastAction() {
      // Check if we have versions to undo to
      if (!dbVersions || dbVersions.length === 0) {
        addMessageToChat('system', ' No version history available to undo');
        return;
      }
      
      // Check if we're already at the oldest version
      if (currentDBVersionIndex <= 0) {
        addMessageToChat('system', ' Already at the oldest version');
        return;
      }
      
      // Load the previous version
      const previousIndex = currentDBVersionIndex - 1;
      const previousVersion = dbVersions[previousIndex];
      
      console.log(` Undoing to version ${previousVersion.version}`);
      
      // Show confirmation message
      const timestamp = new Date(previousVersion.last_updated).toLocaleString();
      addMessageToChat('system', ` Undoing to version ${previousVersion.version} (${timestamp})`);
      
      // Load the previous version
      loadSelectedVersion(previousIndex);
      
      // Save to localStorage
      localStorage.setItem('currentHTML', generatedHTML);
      
      // Add to version history
      if (versionHistory.length > 0) {
        currentVersionIndex = Math.max(0, currentVersionIndex - 1);
        localStorage.setItem('currentVersionIndex', currentVersionIndex.toString());
      }
      
      addMessageToChat('system', ' Reverted to previous version. The broken edit has been undone.');
      
      // Disable undo button after use (can only undo once per edit)
      document.getElementById('btnUndo').disabled = true;
    }
    
    function stopExecution() {
      try {
        if (currentAbortController) {
          console.log(' Aborting AI streaming...');
          currentAbortController.abort();
          addMessageToChat('system', ' Stopped by user');
          currentAbortController = null;
        } else {
          addMessageToChat('system', ' No active operation to stop');
        }
      } catch (error) {
        console.error('Error stopping execution:', error);
        addMessageToChat('system', ' Stop failed, but operation may have ended');
      }
      
      // Disable button and re-enable input
      document.getElementById('btnStop').disabled = true;
      const input = document.getElementById('chatInput');
      const sendBtn = document.getElementById('chatSendBtn');
      if (input) input.disabled = false;
      if (sendBtn) sendBtn.disabled = false;
    }
    
    // ===== DESIGN FRAMEWORK MANAGEMENT =====
    const DESIGN_FRAMEWORKS = {
      'none': {
        name: 'None',
        description: `No specific design framework. Use modern, clean design patterns without framework constraints.

The AI will use:
- Modern CSS best practices
- Clean, semantic HTML
- Responsive design principles
- Basic accessibility standards
- General-purpose component patterns

This option gives the AI freedom to design without specific framework rules.`
      },
      'living-design': {
        name: 'Living Design',
        description: `Walmart's Living Design System - Use for internal associate-facing tools.

Design Tokens:
- Colors: --primary-blue:#0053E2; --bentonville-blue:#001E60; --spark-yellow:#FFC220; --surface-gray:#F4F4F6; --everyday-blue:#4DBDF5; --sky-blue:#A9DDF7; --gray-text:#6B7280; --border-gray:#D1D5DB; --success-green:#10B981; --error-red:#EF4444
- Font: "Everyday Sans UI","Everyday Sans",system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif
- Spacing: Multiples of 8px (8, 16, 24, 32, 40, 48, etc.)
- Component Border Radius: Card=12px, Button=9999px (pill), Input=8px
- Focus Ring: 3px solid #FFC220 with outline-offset:2px

Component Classes:
- Buttons: .btn, .btn--primary, .btn--secondary, .btn--destructive
- Cards: .card, .card__header, .card__body, .card__footer
- Forms: .form-group, .form-input, .form-label
- Alerts: .alert--success, .alert--info, .alert--warning, .alert--error
- Tables: .table-container, .table
- Loading: .spinner-animation

Accessibility Requirements:
- Semantic HTML required
- Labels for all inputs
- Alt text on images/icons
- WCAG-AA contrast ratios
- Visible focus states (3px #FFC220)
- Sentence case for all copy

Typography Hierarchy (50/50 rule):
- Each tier should be  50% of size above it
- XL headlines should be  5 body size
- Headline tracking = 0 (XL may be -15)

Output: Single self-contained HTML file (inline styles and scripts, no external CDNs)`
      },
      'material-design': {
        name: 'Material Design',
        description: `Google's Material Design System.

Key Characteristics:
- Elevation/shadows for depth
- Bold, vibrant colors
- Floating action buttons
- Card-based layouts
- Ripple effects on interactions
- 8dp grid system
- Roboto font family

Components:
- Elevated cards with shadows
- FAB (Floating Action Button)
- Raised and flat buttons
- Text fields with floating labels
- Snackbars for notifications
- Navigation drawer/App bar

Colors: Use primary, secondary, and surface colors with appropriate elevation shadows`
      },
      'modern-minimal': {
        name: 'Modern Minimal',
        description: `Clean, modern design with utility-first approach.

Key Characteristics:
- Minimalist aesthetic
- Subtle shadows and borders
- Neutral color palette with accent colors
- Generous white space
- Clean typography (Inter, SF Pro, or system fonts)
- Subtle animations and transitions
- Focus on content hierarchy

Components:
- Minimal borders and shadows
- Ghost buttons and text links
- Clean form inputs
- Subtle hover states
- Card components with minimal styling
- Simple navigation patterns`
      },
      'bootstrap': {
        name: 'Bootstrap Style',
        description: `Classic Bootstrap design patterns.

Key Characteristics:
- Familiar Bootstrap component patterns
- 12-column grid system
- Rounded corners (border-radius: 0.25rem)
- Primary/Secondary/Success/Danger color scheme
- Card-based layouts
- Standard Bootstrap spacing (0.25rem, 0.5rem, 1rem, etc.)

Components:
- .btn .btn-primary .btn-secondary etc.
- .card with .card-header, .card-body, .card-footer
- .badge for labels
- .alert for notifications
- .nav .navbar for navigation
- .form-control for inputs
- .table for data tables`
      }
    };
    
    function openDesignFrameworkModal() {
      const modal = document.getElementById('designFrameworkModal');
      modal.classList.add('show');
      initLucideIcons();
    }
    
    function closeDesignFrameworkModal() {
      const modal = document.getElementById('designFrameworkModal');
      modal.classList.remove('show');
    }
    
    function selectFramework(frameworkId) {
      currentDesignFramework = frameworkId;
      const framework = DESIGN_FRAMEWORKS[frameworkId];
      
      // Update label below chat input
      const labelMapping = {
        'none': 'None',
        'living-design': 'Living Design 3.5',
        'material-design': 'Material Design',
        'modern-minimal': 'Modern Minimal',
        'bootstrap': 'Bootstrap Style'
      };
      
      const displayElement = document.getElementById('selectedFrameworkDisplay');
      const labelElement = document.getElementById('selectedFrameworkLabel');

      const minimalDisplayElement = document.getElementById('minimalFrameworkDisplay');
      const minimalLabelElement = document.getElementById('minimalFrameworkLabel');
      
      // Show/hide the framework indicators
      if (frameworkId === 'none') {
        if (displayElement) {
          displayElement.style.display = 'none';
        }
        if (minimalDisplayElement && minimalLabelElement) {
          minimalLabelElement.textContent = 'None';
        }
      } else {
        if (displayElement && labelElement) {
          displayElement.style.display = 'flex';
          labelElement.textContent = labelMapping[frameworkId] || framework.name;
        }
        if (minimalDisplayElement && minimalLabelElement) {
          minimalLabelElement.textContent = labelMapping[frameworkId] || framework.name;
        }
      }
      
      // Update visual selection in modal
      document.querySelectorAll('.framework-option').forEach(option => {
        const radio = option.querySelector('input[type="radio"]');
        if (radio.value === frameworkId) {
          option.style.borderColor = 'var(--primary-blue)';
          option.style.background = 'rgba(0, 83, 226, 0.05)';
        } else {
          option.style.borderColor = 'var(--border-gray)';
          option.style.background = 'white';
        }
      });
      
      console.log(' Design framework changed to:', framework.name);
      
      // Close modal after selection
      closeDesignFrameworkModal();
      
      // If there's existing HTML and framework is not "none", trigger AI to apply the framework
      if (generatedHTML && generatedHTML.trim() !== '' && frameworkId !== 'none') {
        addMessageToChat('system', ` Applying ${labelMapping[frameworkId]} to current page...`);
        
        // Auto-send a message to apply the framework
        const frameworkApplyMessage = `Apply the ${framework.name} design framework to the current page. Update the styles, colors, components, and design patterns to match the framework specifications while keeping all existing functionality intact.`;
        
        // Simulate user sending message
        setTimeout(() => {
          chatConversationHistory = [];  // Reset conversation for clean application
          chatUIMessages = [];
          loadedChatHistory = [];
          loadedChatHistorySummary = '';
          needsHistorySummaryInjection = false;
          conversationHasFullHTML = false; // Reset flag when clearing history
          sendMessage(frameworkApplyMessage);
        }, 500);
      } else if (frameworkId === 'none') {
        addMessageToChat('system', ` Framework set to: None - No framework will be applied`);
      } else {
        addMessageToChat('system', ` Design framework set to: ${labelMapping[frameworkId]}`);
      }
    }
    
    function getDesignFrameworkInstructions() {
      const framework = DESIGN_FRAMEWORKS[currentDesignFramework];
      return `\n\n=== ACTIVE DESIGN FRAMEWORK: ${framework.name} ===\n${framework.description}\n====================================\n`;
    }
    
    // ===== REFERENCE IMAGE MANAGEMENT =====
    function triggerImageUpload() {
      document.getElementById('imageUploadInput').click();
    }
    
    /**
     * Shared function to process image file (used by both file input and drag-drop)
     */
    async function processImageFile(file) {
      // Check if it's an image
      if (!file.type.startsWith('image/')) {
        addMessageToChat('system error', ' Please upload an image file (PNG, JPG, GIF, WebP, SVG)');
        return false;
      }
      
      // Check file size (limit to 5MB)
      if (file.size > 5 * 1024 * 1024) {
        addMessageToChat('system error', ' Image too large. Please upload an image under 5MB.');
        return false;
      }
      
      console.log(' Processing uploaded image:', file.name, (file.size / 1024).toFixed(1) + ' KB', file.type);
      addMessageToChat('system', ` Processing image: ${file.name}...`);
      
      try {
        let base64Data;
        let finalFileName = file.name;
        let isSVGText = false;
        
        // Check if it's SVG - store as text instead of image
        if (file.type === 'image/svg+xml') {
          console.log(' Processing SVG as text reference...');
          addMessageToChat('system', ' Processing SVG file as design reference...');
          
          // Read SVG as text
          const svgText = await fileToText(file);
          base64Data = svgText; // Store SVG text directly, not as base64 image
          isSVGText = true;
          finalFileName = file.name;
        } else {
          // Validate accepted formats for image vision
          const acceptedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
          if (!acceptedTypes.includes(file.type)) {
            addMessageToChat('system error', `This file format is not supported. Please upload an image in PNG, JPG, GIF, WebP, or SVG format.`);
            return false;
          }
          
          // Convert to base64
          base64Data = await fileToBase64(file);
          isSVGText = false;
        }
        
        // Add to images array
        referenceImages.push({
          data: base64Data,
          name: finalFileName,
          isSVGText: isSVGText
        });
        
        // For backward compatibility, also set the single image variables (last uploaded)
        referenceImageData = base64Data;
        referenceImageName = finalFileName;
        window.isReferenceSVGText = isSVGText;
        
        // Update indicator
        updateReferenceImageDisplay();
        
        console.log(' Reference loaded:', finalFileName, isSVGText ? '(as SVG text)' : '(as image)');
        console.log(` Total images: ${referenceImages.length}`);
        addMessageToChat('system', ` Reference uploaded: ${finalFileName}. Total images: ${referenceImages.length}`);
        
        initLucideIcons();
        return true;
      } catch (error) {
        console.error('Error uploading file:', error);
        addMessageToChat('system error', 'Unable to process the uploaded file. Please ensure it\'s a valid image format and try again.');
        return false;
      }
    }
    
    async function handleImageUpload(event) {
      const files = event.target.files;
      if (!files || files.length === 0) return;
      
      console.log(` Processing ${files.length} file(s) from file input...`);
      
      // Process all selected files
      for (let i = 0; i < files.length; i++) {
        await processImageFile(files[i]);
      }
      
      // Clear input so same files can be uploaded again
      event.target.value = '';
    }
    
    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }
    
    function fileToText(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsText(file);
      });
    }
    
    function updateReferenceImageDisplay() {
      const display = document.getElementById('referenceImageDisplay');
      const label = document.getElementById('referenceImageLabel');
      
      if (referenceImages.length === 0) {
        display.style.display = 'none';
        return;
      }
      
      display.style.display = 'flex';
      
      if (referenceImages.length === 1) {
        const img = referenceImages[0];
        label.textContent = img.name + (img.isSVGText ? ' (SVG code)' : '');
      } else {
        label.textContent = `${referenceImages.length} images attached`;
      }
      
      initLucideIcons();
    }
    
    function removeReferenceImage() {
      // Clear all reference images
      referenceImages = [];
      referenceImageData = null;
      referenceImageName = null;
      window.isReferenceSVGText = false;
      
      updateReferenceImageDisplay();
      
      console.log(' All references removed');
      addMessageToChat('system', ' All reference images removed');
    }
    
    // ===== DRAG & DROP IMAGE UPLOAD =====
    function initDragAndDrop() {
      const dropArea = document.getElementById('chatInputArea');
      const dropOverlay = document.getElementById('dragDropOverlay');
      
      if (!dropArea || !dropOverlay) {
        console.warn(' Drag & drop elements not found');
        return;
      }
      
      let dragCounter = 0; // Track nested drag events
      let isDragging = false;
      
      // Prevent default drag behaviors
      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }
      
      // Handle drag enter - show overlay
      function handleDragEnter(e) {
        preventDefaults(e);
        dragCounter++;
        
        // Check if dragged item contains files
        if (e.dataTransfer && e.dataTransfer.types) {
          const hasFiles = Array.from(e.dataTransfer.types).includes('Files');
          if (hasFiles) {
            isDragging = true;
            dropOverlay.classList.add('active');
            console.log(' Drag entered - showing overlay');
          }
        }
      }
      
      // Handle drag over - keep showing overlay
      function handleDragOver(e) {
        preventDefaults(e);
        if (isDragging) {
          dropOverlay.classList.add('drag-hover');
        }
      }
      
      // Handle drag leave - hide overlay when fully left
      function handleDragLeave(e) {
        preventDefaults(e);
        dragCounter--;
        
        // Only hide when leaving the drop area completely
        if (dragCounter === 0) {
          isDragging = false;
          dropOverlay.classList.remove('active', 'drag-hover');
          console.log(' Drag left - hiding overlay');
        }
      }
      
      // Handle drop - process the file(s)
      async function handleDrop(e) {
        preventDefaults(e);
        
        dragCounter = 0;
        isDragging = false;
        dropOverlay.classList.remove('active', 'drag-hover');
        
        const dt = e.dataTransfer;
        const files = dt.files;
        
        console.log(' Drop event - files:', files.length);
        
        if (files.length === 0) {
          console.log(' No files in drop event');
          return;
        }
        
        // Process all dropped files
        console.log(` Processing ${files.length} dropped file(s)...`);
        for (let i = 0; i < files.length; i++) {
          const file = files[i];
          console.log(` File ${i + 1}/${files.length}:`, file.name, file.type, (file.size / 1024).toFixed(1) + ' KB');
          await processImageFile(file);
        }
      }
      
      // Attach event listeners to drop area
      dropArea.addEventListener('dragenter', handleDragEnter, false);
      dropArea.addEventListener('dragover', handleDragOver, false);
      dropArea.addEventListener('dragleave', handleDragLeave, false);
      dropArea.addEventListener('drop', handleDrop, false);
      
      // Also prevent default on document to avoid browser opening the file
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        document.body.addEventListener(eventName, preventDefaults, false);
      });
      
      console.log(' Drag & drop initialized for chat input area');
    }
    
    // ===== CSV UPLOAD FOR SCHEMA INFERENCE =====
    function triggerCSVUpload() {
      document.getElementById('csvUploadInput').click();
    }
    
    async function handleCSVUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      // Check if it's a CSV
      if (!file.name.endsWith('.csv') && file.type !== 'text/csv') {
        addMessageToChat('system error', ' Please upload a CSV file (.csv)');
        event.target.value = '';
        return;
      }
      
      // Check file size (limit to 2MB for CSV)
      if (file.size > 2 * 1024 * 1024) {
        addMessageToChat('system error', ' CSV too large. Please upload a file under 2MB.');
        event.target.value = '';
        return;
      }
      
      console.log(' Processing CSV file:', file.name, (file.size / 1024).toFixed(1) + ' KB');
      addMessageToChat('system', ` Analyzing CSV structure: ${file.name}...`);
      
      try {
        // Read CSV content
        const csvText = await fileToText(file);
        
        // Parse CSV and infer schema
        const schema = parseCSVToSchema(csvText);
        
        if (!schema || schema.columns.length === 0) {
          addMessageToChat('system error', ' Could not parse CSV. Please ensure it has headers and valid data.');
          event.target.value = '';
          return;
        }
        
        console.log(' CSV parsed:', schema.columns.length, 'columns detected');
        addMessageToChat('system', ` Detected ${schema.columns.length} columns. Opening table creator...`);
        
        // Pre-fill the create table modal with inferred schema
        prefillTableSchemaFromCSV(schema, file.name);
        
      } catch (error) {
        console.error('Error processing CSV:', error);
        addMessageToChat('system error', ' Failed to process CSV. Please ensure it\'s a valid CSV file.');
      }
      
      // Clear input so same file can be uploaded again
      event.target.value = '';
    }
    
    function parseCSVToSchema(csvText) {
      const lines = csvText.trim().split('\n');
      if (lines.length < 2) {
        return null; // Need at least headers + 1 data row
      }
      
      // Parse headers (first line)
      const headers = parseCSVLine(lines[0]);
      
      // Sample first 100 rows for type inference
      const sampleSize = Math.min(100, lines.length - 1);
      const sampleRows = [];
      
      for (let i = 1; i <= sampleSize; i++) {
        if (lines[i] && lines[i].trim()) {
          sampleRows.push(parseCSVLine(lines[i]));
        }
      }
      
      // Infer column types
      const columns = headers.map((header, index) => {
        const sampleValues = sampleRows.map(row => row[index]).filter(v => v != null && v !== '');
        const inferredType = inferColumnType(sampleValues);
        
        return {
          name: sanitizeColumnName(header),
          type: inferredType,
          nullable: sampleValues.length < sampleRows.length // Has null/empty values
        };
      });
      
      return {
        columns,
        rowCount: lines.length - 1
      };
    }
    
    function parseCSVLine(line) {
      const result = [];
      let current = '';
      let inQuotes = false;
      
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        const nextChar = line[i + 1];
        
        if (char === '"') {
          if (inQuotes && nextChar === '"') {
            // Escaped quote
            current += '"';
            i++; // Skip next quote
          } else {
            // Toggle quote mode
            inQuotes = !inQuotes;
          }
        } else if (char === ',' && !inQuotes) {
          // End of field
          result.push(current.trim());
          current = '';
        } else {
          current += char;
        }
      }
      
      // Add last field
      result.push(current.trim());
      
      return result;
    }
    
    function sanitizeColumnName(name) {
      // Convert to valid SQL column name
      return name
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9_]/g, '_')
        .replace(/^[0-9]/, '_$&') // Prefix numbers
        .substring(0, 64); // Limit length
    }
    
    function inferColumnType(sampleValues) {
      if (sampleValues.length === 0) {
        return 'STRING';
      }
      
      let allIntegers = true;
      let allFloats = true;
      let allBooleans = true;
      let allDates = true;
      let allTimestamps = true;
      
      for (const value of sampleValues) {
        const strValue = String(value).trim();
        
        // Check INTEGER
        if (!/^-?\d+$/.test(strValue)) {
          allIntegers = false;
        }
        
        // Check FLOAT/NUMERIC
        if (!/^-?\d+\.?\d*$/.test(strValue)) {
          allFloats = false;
        }
        
        // Check BOOLEAN
        if (!['true', 'false', '1', '0', 'yes', 'no', 't', 'f'].includes(strValue.toLowerCase())) {
          allBooleans = false;
        }
        
        // Check DATE (YYYY-MM-DD)
        if (!/^\d{4}-\d{2}-\d{2}$/.test(strValue)) {
          allDates = false;
        }
        
        // Check TIMESTAMP
        if (isNaN(Date.parse(strValue))) {
          allTimestamps = false;
        }
      }
      
      // Return most specific type
      if (allBooleans) return 'BOOLEAN';
      if (allIntegers) return 'INTEGER';
      if (allFloats) return 'FLOAT64';
      if (allDates) return 'DATE';
      if (allTimestamps) return 'TIMESTAMP';
      
      // Default to STRING
      return 'STRING';
    }
    
    function prefillTableSchemaFromCSV(schema, fileName) {
      // Open the create table modal
      openCreateTableModal();
      
      // Generate table name from file name
      const tableName = fileName
        .replace('.csv', '')
        .toLowerCase()
        .replace(/[^a-z0-9_]/g, '_')
        .substring(0, 64);
      
      // Set table name
      const tableNameInput = document.getElementById('newTableName');
      if (tableNameInput) {
        tableNameInput.value = tableName;
        updateTableNamePreview(); // Trigger preview update
      }
      
      // Clear existing schema fields
      const schemaContainer = document.getElementById('schemaBuilder');
      if (schemaContainer) {
        schemaContainer.innerHTML = '';
      }
      
      // Add each column from CSV
      schema.columns.forEach((column, index) => {
        addSchemaColumn(column.name, column.type, !column.nullable);
      });
      
      // Show success message
      addMessageToChat('system', ` Table schema pre-filled with ${schema.columns.length} columns from CSV. Review and create table.`);
      
      console.log(' Table modal pre-filled with CSV schema');
    }
    
    // ===== TABLE CREATION DIALOG =====
    function showTableCreationDialog(tableName, schemaPreview, schemaArray) {
      return new Promise((resolve) => {
        // Create dialog overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0,0,0,0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
        `;
        
        // Create dialog
        const dialog = document.createElement('div');
        dialog.style.cssText = `
          background: white;
          border-radius: 12px;
          padding: 24px;
          max-width: 600px;
          width: 90%;
          box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        `;
        
        dialog.innerHTML = `
          <h2 style="margin: 0 0 16px 0; color: var(--primary-blue);">
            <i data-lucide="database" style="width: 24px; height: 24px; vertical-align: middle; margin-right: 8px;"></i>
            Create Table: ${tableName}
          </h2>
          <p style="margin: 0 0 16px 0; color: var(--text-secondary);">
            The AI wants to create a new table with the following schema:
          </p>
          <pre style="
            background: var(--surface-gray);
            padding: 16px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: monospace;
            font-size: 14px;
            margin: 0 0 24px 0;
          ">${schemaPreview}</pre>
          <div style="display: flex; gap: 12px; justify-content: flex-end;">
            <button id="cancelTableBtn" style="
              padding: 10px 20px;
              border: 1px solid var(--border-gray);
              background: white;
              color: var(--text-primary);
              border-radius: 9999px;
              font-size: 14px;
              font-weight: 500;
              cursor: pointer;
            ">Cancel</button>
            <button id="approveTableBtn" style="
              padding: 10px 20px;
              border: none;
              background: var(--primary-blue);
              color: white;
              border-radius: 9999px;
              font-size: 14px;
              font-weight: 500;
              cursor: pointer;
            ">Create Table</button>
          </div>
        `;
        
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        // Initialize Lucide icons in dialog
        if (window.lucide) {
          lucide.createIcons();
        }
        
        // Handle approve
        document.getElementById('approveTableBtn').onclick = () => {
          console.log(' Table creation approved by user:', tableName);
          
          // Immediately remove overlay to prevent any visual lag
          if (overlay && overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
          } else {
            console.warn('Overlay already removed or has no parent');
          }
          
          // Add message to chat
          try {
            addMessageToChat('system', ` Table '${tableName}' approved - creating now...`);
          } catch (err) {
            console.error('Error adding message to chat:', err);
          }
          
          // Resolve promise to let AI continue
          resolve(true);
        };
        
        // Handle cancel
        document.getElementById('cancelTableBtn').onclick = () => {
          console.log(' Table creation cancelled by user:', tableName);
          
          // Immediately remove overlay
          if (overlay && overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
          } else {
            console.warn('Overlay already removed or has no parent');
          }
          
          // Add message to chat
          try {
            addMessageToChat('system', ` Table creation cancelled by user`);
          } catch (err) {
            console.error('Error adding message to chat:', err);
          }
          
          // Resolve promise with false
          resolve(false);
        };
      });
    }
    
    // ===== SCHEMA CHANGE CONFIRMATION DIALOG =====
    function showSchemaChangeConfirmation(proposal, reason) {
      return new Promise((resolve) => {
        // Create dialog overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0,0,0,0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
        `;
        
        // Create dialog
        const dialog = document.createElement('div');
        dialog.style.cssText = `
          background: white;
          border-radius: 12px;
          padding: 24px;
          max-width: 600px;
          width: 90%;
          box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        `;
        
        // Build warning section if there's a warning
        const warningHTML = proposal.warning ? `
          <div style="
            background: #FFF4E5;
            border-left: 4px solid #FF9800;
            padding: 12px 16px;
            margin: 16px 0;
            border-radius: 4px;
          ">
            <p style="margin: 0; color: #E65100; font-size: 14px;">
              ${proposal.warning}
            </p>
          </div>
        ` : '';
        
        dialog.innerHTML = `
          <h2 style="margin: 0 0 16px 0; color: var(--primary-blue);">
            <i data-lucide="alert-circle" style="width: 24px; height: 24px; vertical-align: middle; margin-right: 8px;"></i>
            Confirm Schema Change
          </h2>
          <p style="margin: 0 0 12px 0; color: var(--text-secondary);">
            The AI wants to modify the database schema:
          </p>
          <div style="
            background: var(--surface-gray);
            padding: 16px;
            border-radius: 8px;
            margin: 0 0 16px 0;
          ">
            <p style="margin: 0 0 8px 0; font-weight: 600; color: var(--text-primary);">
              Table: <code style="background: white; padding: 2px 8px; border-radius: 4px;">${proposal.table_name}</code>
            </p>
            <p style="margin: 0 0 8px 0; color: var(--text-primary);">
              <strong>Operation:</strong> Add Column
            </p>
            <p style="margin: 0 0 8px 0; color: var(--text-primary);">
              <strong>Column Name:</strong> <code style="background: white; padding: 2px 8px; border-radius: 4px;">${proposal.column_name}</code>
            </p>
            <p style="margin: 0 0 8px 0; color: var(--text-primary);">
              <strong>Type:</strong> <code style="background: white; padding: 2px 8px; border-radius: 4px;">${proposal.column_type}</code>
            </p>
            ${proposal.default_value !== undefined && proposal.default_value !== null ? `
            <p style="margin: 0 0 8px 0; color: var(--text-primary);">
              <strong>Default Value:</strong> <code style="background: white; padding: 2px 8px; border-radius: 4px;">${proposal.default_value}</code>
            </p>
            ` : ''}
            <p style="margin: 0; color: var(--text-primary);">
              <strong>Reason:</strong> ${reason || 'No reason provided'}
            </p>
          </div>
          ${warningHTML}
          <p style="margin: 0 0 24px 0; color: var(--text-secondary); font-size: 14px;">
             This will modify the table structure. Existing data will not be affected, but the new column will be added to all rows.
          </p>
          <div style="display: flex; gap: 12px; justify-content: flex-end;">
            <button id="cancelSchemaBtn" style="
              padding: 10px 20px;
              border: 1px solid var(--border-gray);
              background: white;
              color: var(--text-primary);
              border-radius: 9999px;
              font-size: 14px;
              font-weight: 500;
              cursor: pointer;
            ">Cancel</button>
            <button id="approveSchemaBtn" style="
              padding: 10px 20px;
              border: none;
              background: var(--primary-blue);
              color: white;
              border-radius: 9999px;
              font-size: 14px;
              font-weight: 500;
              cursor: pointer;
            ">Approve Change</button>
          </div>
        `;
        
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        // Initialize Lucide icons in dialog
        if (window.lucide) {
          lucide.createIcons();
        }
        
        // Handle approve
        document.getElementById('approveSchemaBtn').onclick = () => {
          console.log(' Schema change approved by user:', proposal.column_name);
          
          // Remove overlay
          if (overlay && overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
          }
          
          // Add message to chat
          try {
            addMessageToChat('system', ` Schema change approved - adding column '${proposal.column_name}' to '${proposal.table_name}'...`);
          } catch (err) {
            console.error('Error adding message to chat:', err);
          }
          
          // Resolve promise to let AI continue
          resolve(true);
        };
        
        // Handle cancel
        document.getElementById('cancelSchemaBtn').onclick = () => {
          console.log(' Schema change cancelled by user:', proposal.column_name);
          
          // Remove overlay
          if (overlay && overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
          }
          
          // Add message to chat
          try {
            addMessageToChat('system', ` Schema change cancelled by user`);
          } catch (err) {
            console.error('Error adding message to chat:', err);
          }
          
          // Resolve promise with false
          resolve(false);
        };
      });
    }
    
    // ===== MODE MANAGEMENT =====
    function switchMode(mode) {
      currentMode = mode;
      
      // Update mode tabs
      document.querySelectorAll('.mode-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.mode === mode);
      });
      
      const modeNames = {
        'agent': 'Agent Mode',
        'plan': 'Plan Mode',
        'chat': 'Chat Mode'
      };
      
      const modeDescriptions = {
        'agent': 'Current HTML automatically included with every message for iterative building',
        'plan': 'AI creates a plan before executing (multi-step workflows)',
        'chat': 'Simple conversational mode (AI decides when to use tools)'
      };
      
      console.log(' Mode switched to:', modeNames[mode]);
      addMessageToChat('system', ` Switched to ${modeNames[mode]}\n${modeDescriptions[mode]}`);
    }
    
    // ===== MINIMAL MODE MANAGEMENT =====
    let isMinimalMode = false;
    let minimalModeUpdateInProgress = false;
    let minimalNudgeTimeout = null;
    let minimalNudgeIsMinimized = false;
    
    function toggleMinimalMode() {
      if (isMinimalMode) {
        exitMinimalMode();
      } else {
        enterMinimalMode();
      }
    }
    
    function startNudgeSpinner() {
      const spinner = document.getElementById('minimalNudgeSpinner');
      if (spinner) {
        spinner.classList.add('spinning');
      }
    }
    
    function stopNudgeSpinner() {
      const spinner = document.getElementById('minimalNudgeSpinner');
      if (spinner) {
        spinner.classList.remove('spinning');
      }
    }
    
    function minimizeMinimalNudge() {
      const nudge = document.getElementById('minimalUpdateNudge');
      const restoreBtn = document.getElementById('minimalNudgeRestoreBtn');
      
      nudge.classList.remove('active');
      nudge.classList.add('minimized');
      restoreBtn.classList.add('active');
      
      minimalNudgeIsMinimized = true;
      
      // Re-initialize icons
      if (window.lucide) {
        lucide.createIcons();
      }
    }
    
    function restoreMinimalNudge() {
      const nudge = document.getElementById('minimalUpdateNudge');
      const restoreBtn = document.getElementById('minimalNudgeRestoreBtn');
      
      nudge.classList.remove('minimized');
      nudge.classList.add('active');
      restoreBtn.classList.remove('active');
      
      minimalNudgeIsMinimized = false;
      
      // Re-initialize icons
      if (window.lucide) {
        lucide.createIcons();
      }
    }
    
    function showMinimalUpdateNudge(updates) {
      const nudge = document.getElementById('minimalUpdateNudge');
      const updateList = document.getElementById('minimalUpdateList');
      const completeIndicator = document.getElementById('minimalUpdateComplete');
      const restoreBtn = document.getElementById('minimalNudgeRestoreBtn');
      
      // Clear previous updates
      updateList.innerHTML = '';
      completeIndicator.style.display = 'none';
      
      // Add update items
      updates.forEach(update => {
        const li = document.createElement('li');
        li.className = 'minimal-update-item';
        li.textContent = update;
        updateList.appendChild(li);
      });
      
      // Show nudge (only if not manually minimized)
      if (!minimalNudgeIsMinimized) {
        nudge.classList.add('active');
        restoreBtn.classList.remove('active');
      } else {
        restoreBtn.classList.add('active');
      }
      
      // Start spinner animation
      startNudgeSpinner();
      
      // Re-initialize icons
      if (window.lucide) {
        lucide.createIcons();
      }
    }
    
    // Stream individual update to minimal nudge (called during AI processing)
    function addMinimalUpdateItem(message) {
      if (!isMinimalMode) return;
      
      const nudge = document.getElementById('minimalUpdateNudge');
      const updateList = document.getElementById('minimalUpdateList');
      const completeIndicator = document.getElementById('minimalUpdateComplete');
      const restoreBtn = document.getElementById('minimalNudgeRestoreBtn');
      
      // Hide completion indicator if showing
      completeIndicator.style.display = 'none';
      
      // Show nudge if not already visible (and not manually minimized)
      if (!nudge.classList.contains('active') && !minimalNudgeIsMinimized) {
        nudge.classList.add('active');
        restoreBtn.classList.remove('active');
        startNudgeSpinner();
      }
      
      // Add new update item with animation
      const li = document.createElement('li');
      li.className = 'minimal-update-item';
      li.textContent = message;
      li.style.opacity = '0';
      li.style.transform = 'translateY(-10px)';
      li.style.transition = 'all 0.3s ease';
      
      updateList.appendChild(li);
      
      // Auto-scroll to bottom
      requestAnimationFrame(() => {
        updateList.scrollTop = updateList.scrollHeight;
      });
      
      // Trigger animation
      requestAnimationFrame(() => {
        li.style.opacity = '1';
        li.style.transform = 'translateY(0)';
      });
      
      // Re-initialize icons
      if (window.lucide) {
        lucide.createIcons();
      }
    }
    
    function hideMinimalUpdateNudge() {
      const nudge = document.getElementById('minimalUpdateNudge');
      const completeIndicator = document.getElementById('minimalUpdateComplete');
      
      // Stop spinner animation
      stopNudgeSpinner();
      
      // Show completion
      completeIndicator.style.display = 'flex';
      
      // Re-initialize icons
      if (window.lucide) {
        lucide.createIcons();
      }
      
      // Hide after delay (only if not manually minimized)
      if (minimalNudgeTimeout) {
        clearTimeout(minimalNudgeTimeout);
      }
      
      minimalNudgeTimeout = setTimeout(() => {
        if (!minimalNudgeIsMinimized) {
          nudge.classList.remove('active');
        }
      }, 3000);
    }
    
    function updateMinimalPreviewOnce() {
      const mainPreviewFrame = document.getElementById('previewFrame');
      const minimalFrame = document.getElementById('minimalPreviewFrame');
      
      if (mainPreviewFrame && mainPreviewFrame.contentDocument && minimalFrame) {
        try {
          const currentHTML = mainPreviewFrame.contentDocument.documentElement.outerHTML;
          minimalFrame.srcdoc = currentHTML;
          console.log(' Updated minimal preview');
        } catch (err) {
          console.error('Error updating minimal preview:', err);
        }
      }
    }
    
    function initMinimalNudgeDragging() {
      const nudge = document.getElementById('minimalUpdateNudge');
      const header = document.getElementById('minimalNudgeHeader');
      
      let isDragging = false;
      let currentX;
      let currentY;
      let initialX;
      let initialY;
      let xOffset = 0;
      let yOffset = 0;
      
      header.addEventListener('mousedown', dragStart);
      document.addEventListener('mousemove', drag);
      document.addEventListener('mouseup', dragEnd);
      
      function dragStart(e) {
        // Don't drag if clicking on buttons
        if (e.target.closest('.minimal-nudge-control-btn')) {
          return;
        }
        
        initialX = e.clientX - xOffset;
        initialY = e.clientY - yOffset;
        
        if (e.target === header || e.target.closest('#minimalNudgeHeader')) {
          isDragging = true;
          nudge.classList.add('dragging');
        }
      }
      
      function drag(e) {
        if (isDragging) {
          e.preventDefault();
          
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;
          
          xOffset = currentX;
          yOffset = currentY;
          
          setTranslate(currentX, currentY, nudge);
        }
      }
      
      function dragEnd(e) {
        initialX = currentX;
        initialY = currentY;
        
        isDragging = false;
        nudge.classList.remove('dragging');
      }
      
      function setTranslate(xPos, yPos, el) {
        el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
      }
    }
    
    function setupWindowBlurListener() {
      window.addEventListener('blur', () => {
        if (isMinimalMode) {
          const nudge = document.getElementById('minimalUpdateNudge');
          const chatBar = document.getElementById('minimalChatBar');
          
          // CRITICAL: Always ensure chat bar stays visible, regardless of blur
          if (chatBar) {
            chatBar.style.display = 'flex';
            chatBar.style.opacity = '1';
            chatBar.style.visibility = 'visible';
          }
          
          // Only minimize the nudge, NEVER hide the chat bar
          if (nudge && nudge.classList.contains('active') && !minimalNudgeIsMinimized) {
            // Auto-minimize on window blur
            minimizeMinimalNudge();
          }
        }
      });
    }
    
    function enterMinimalMode() {
      isMinimalMode = true;
      const overlay = document.getElementById('minimalModeOverlay');
      const minimalFrame = document.getElementById('minimalPreviewFrame');
      const mainPreviewFrame = document.getElementById('previewFrame');
      
      // Copy current preview to minimal mode frame
      if (mainPreviewFrame && mainPreviewFrame.contentDocument) {
        const currentHTML = mainPreviewFrame.contentDocument.documentElement.outerHTML;
        minimalFrame.srcdoc = currentHTML;
      }

      // Sync minimal mode design framework label with current selection
      const minimalLabelElement = document.getElementById('minimalFrameworkLabel');
      if (minimalLabelElement) {
        const labelMapping = {
          'none': 'None',
          'living-design': 'Living Design 3.5',
          'material-design': 'Material Design',
          'modern-minimal': 'Modern Minimal',
          'bootstrap': 'Bootstrap Style'
        };
        const frameworkId = currentDesignFramework || 'living-design';
        minimalLabelElement.textContent = labelMapping[frameworkId] || 'Living Design 3.5';
      }
      
      // Show overlay with fade-in
      overlay.classList.add('active');
      
      // Initialize lucide icons IMMEDIATELY after overlay is shown
      if (window.lucide) {
        lucide.createIcons();
        console.log(' Lucide icons initialized in minimal mode (immediate)');
      }
      
      // Initialize dragging functionality for chat bar
      initMinimalChatBarDragging();
      
      // Initialize dragging functionality for nudge
      initMinimalNudgeDragging();
      
      // Update framework display visibility
      updateFrameworkDisplayVisibility();
      
      // Sync element selector button state with selected element
      const minimalBtn = document.getElementById('minimalElementSelectorBtn');
      if (minimalBtn) {
        if (selectedElementContext) {
          minimalBtn.classList.add('element-selected');
        } else {
          minimalBtn.classList.remove('element-selected');
        }
      }
      
      // Re-initialize lucide icons after a brief delay to catch any late-rendering elements
      setTimeout(() => {
        if (window.lucide) {
          lucide.createIcons();
          console.log(' Lucide icons re-initialized in minimal mode (delayed)');
        }
      }, 200);
      
      // Force another icon initialization after a bit more time (sometimes needed)
      setTimeout(() => {
        if (window.lucide) {
          lucide.createIcons();
        }
      }, 300);
      
      console.log(' Entered minimal mode');
    }
    
    function exitMinimalMode() {
      isMinimalMode = false;
      const overlay = document.getElementById('minimalModeOverlay');
      const statusIndicator = document.getElementById('minimalStatusIndicator');
      const chatBar = document.getElementById('minimalChatBar');
      const nudge = document.getElementById('minimalUpdateNudge');
      const restoreBtn = document.getElementById('minimalNudgeRestoreBtn');
      
      // Hide overlay
      overlay.classList.remove('active');
      
      // Reset UI states
      statusIndicator.classList.remove('active');
      chatBar.classList.remove('processing');
      nudge.classList.remove('active');
      nudge.classList.remove('minimized');
      restoreBtn.classList.remove('active');
      
      // Clear input
      document.getElementById('minimalChatInput').value = '';
      
      // Clear nudge timeout
      if (minimalNudgeTimeout) {
        clearTimeout(minimalNudgeTimeout);
        minimalNudgeTimeout = null;
      }
      
      // Reset minimized state
      minimalNudgeIsMinimized = false;
      
      // Reset nudge position
      nudge.style.transform = '';
      
      // Stop spinner
      stopNudgeSpinner();
      
      minimalModeUpdateInProgress = false;
      
      console.log(' Exited minimal mode');
    }
    
    function extractFeatureSummary(responseText) {
      // Try to extract meaningful features from the AI response
      const features = [];
      
      if (!responseText) return features;
      
      // Look for common patterns indicating features being built
      const lines = responseText.split('\n');
      
      for (const line of lines) {
        const trimmed = line.trim();
        
        // Skip empty lines and very short lines
        if (!trimmed || trimmed.length < 10) continue;
        
        // Look for bullet points or numbered lists
        if (/^[-*]\s+/.test(trimmed) || /^\d+\.\s+/.test(trimmed)) {
          const feature = trimmed.replace(/^[-*]\s+/, '').replace(/^\d+\.\s+/, '').trim();
          if (feature.length > 5 && feature.length < 80) {
            features.push(feature);
          }
        }
        
        // Look for action verbs indicating what's being built
        const actionPatterns = [
          /^(Added|Created|Built|Implemented|Updated|Modified|Fixed|Improved)\s+(.+)/i,
          /^(Adding|Creating|Building|Implementing|Updating|Modifying|Fixing|Improving)\s+(.+)/i
        ];
        
        for (const pattern of actionPatterns) {
          const match = trimmed.match(pattern);
          if (match && match[2] && match[2].length < 80) {
            features.push(match[2].trim().replace(/[:.!]$/, ''));
          }
        }
      }
      
      // Limit to top 5 features
      return features.slice(0, 5);
    }
    
    async function sendMinimalMessage() {
      const input = document.getElementById('minimalChatInput');
      const message = input.value.trim();
      
      if (!message || minimalModeUpdateInProgress) return;
      
      // Append selected element context if available (same as normal mode)
      const elementContext = getSelectedElementContextForAI();
      const messageWithContext = elementContext ? message + elementContext : message;
      
      // Clear selected element after using it
      if (selectedElementContext) {
        const minimalBtn = document.getElementById('minimalElementSelectorBtn');
        if (minimalBtn) {
          minimalBtn.classList.remove('element-selected');
        }
        selectedElementContext = null;
      }
      
      minimalModeUpdateInProgress = true;
      
      const sendBtn = document.getElementById('minimalSendBtn');
      const statusIndicator = document.getElementById('minimalStatusIndicator');
      const chatBar = document.getElementById('minimalChatBar');
      
      // Clear previous updates and show nudge
      const nudge = document.getElementById('minimalUpdateNudge');
      const updateList = document.getElementById('minimalUpdateList');
      const completeIndicator = document.getElementById('minimalUpdateComplete');
      updateList.innerHTML = '';
      completeIndicator.style.display = 'none';
      nudge.classList.add('active');
      
      // Disable input and show processing state
      input.disabled = true;
      sendBtn.disabled = true;
      chatBar.classList.add('processing');
      statusIndicator.classList.add('active');
      
      // Clear input immediately
      input.value = '';
      
      // Show user's request in the nudge (including element context if present)
      if (elementContext) {
        // Extract element tag from context for display
        const elementMatch = elementContext.match(/Element: <(\w+)>/);
        const elementTag = elementMatch ? elementMatch[1] : 'element';
        showMinimalUpdateNudge([
          ` Selected: <${elementTag}>`,
          message
        ]);
      } else {
        showMinimalUpdateNudge([message]);
      }
      
      // Also add to main chat (hidden) so conversation history is preserved
      // Use messageWithContext so element context is included
      const mainInput = document.getElementById('chatInput');
      mainInput.value = messageWithContext;
      
      try {
        // Update nudge - AI is thinking
        showMinimalUpdateNudge(['AI is analyzing your request...']);
        
        // Capture the chat history length before sending
        const chatHistoryLengthBefore = chatConversationHistory.length;
        
        // Send message through the main sendMessage function
        await sendMessage();
        
        // Extract the AI response from chat history
        let aiResponse = '';
        if (chatConversationHistory.length > chatHistoryLengthBefore) {
          const lastMessage = chatConversationHistory[chatConversationHistory.length - 1];
          if (lastMessage.role === 'assistant') {
            // Extract text from content blocks
            for (const block of lastMessage.content) {
              if (block.type === 'text') {
                aiResponse += block.text + '\n';
              }
            }
          }
        }
        
        // Extract features from the response
        const features = extractFeatureSummary(aiResponse);
        
        // Update nudge with features being built
        if (features.length > 0) {
          showMinimalUpdateNudge([
            'Building features:',
            ...features
          ]);
        } else {
          showMinimalUpdateNudge([
            'AI response received',
            'Updating your app...'
          ]);
        }
        
        // Wait for preview to fully update
        await new Promise(resolve => setTimeout(resolve, 1500));
        
        // Update the minimal frame ONCE
        updateMinimalPreviewOnce();
        
        // Show completion with feature summary
        const completionUpdates = features.length > 0 
          ? ['Features added:', ...features.slice(0, 3)]
          : ['App updated successfully'];
        
        showMinimalUpdateNudge(completionUpdates);
        
        // Hide nudge after showing completion
        hideMinimalUpdateNudge();
        
      } catch (err) {
        console.error('Error in minimal mode:', err);
        showMinimalUpdateNudge(['Error: ' + err.message]);
        setTimeout(() => {
          document.getElementById('minimalUpdateNudge').classList.remove('active');
        }, 3000);
      } finally {
        // Re-enable input and hide processing state
        setTimeout(() => {
          input.disabled = false;
          sendBtn.disabled = false;
          chatBar.classList.remove('processing');
          statusIndicator.classList.remove('active');
          minimalModeUpdateInProgress = false;
          input.focus();
        }, 500);
      }
    }
    
    // ===== MINIMAL CHAT BAR DRAGGING & RESIZING =====
    let chatBarDragState = {
      isDragging: false,
      isResizing: false,
      startX: 0,
      startY: 0,
      startLeft: 0,
      startBottom: 0,
      startWidth: 0,
      listenersAttached: false
    };
    
    // Clean up old listeners and reinitialize
    function cleanupChatBarListeners() {
      if (chatBarDragState.mouseMoveHandler) {
        document.removeEventListener('mousemove', chatBarDragState.mouseMoveHandler);
      }
      if (chatBarDragState.mouseUpHandler) {
        document.removeEventListener('mouseup', chatBarDragState.mouseUpHandler);
      }
      if (chatBarDragState.keydownHandler) {
        document.removeEventListener('keydown', chatBarDragState.keydownHandler);
      }
      chatBarDragState.listenersAttached = false;
    }
    
    function initMinimalChatBarDragging() {
      const chatBar = document.getElementById('minimalChatBar');
      const handle = document.getElementById('minimalChatBarHandle');
      const resizeHandle = document.getElementById('minimalChatBarResizeHandle');
      
      if (!chatBar || !handle || !resizeHandle) return;
      
      // Clean up any existing listeners first
      cleanupChatBarListeners();
      
      // Convert current position to absolute positioning if using transform
      function normalizePosition() {
        const rect = chatBar.getBoundingClientRect();
        const overlay = document.getElementById('minimalModeOverlay');
        const overlayRect = overlay.getBoundingClientRect();
        
        // Calculate absolute position from current rect
        const currentLeft = rect.left - overlayRect.left;
        const currentBottom = overlayRect.height - (rect.bottom - overlayRect.top);
        
        // Clear transform and set absolute position
        chatBar.style.transform = 'none';
        chatBar.style.left = currentLeft + 'px';
        chatBar.style.bottom = currentBottom + 'px';
      }
      
      // Handle drag start
      function handleDragStart(e) {
        normalizePosition();
        
        chatBarDragState.isDragging = true;
        chatBarDragState.startX = e.clientX;
        chatBarDragState.startY = e.clientY;
        chatBarDragState.startLeft = parseInt(chatBar.style.left) || 0;
        chatBarDragState.startBottom = parseInt(chatBar.style.bottom) || 0;
        
        chatBar.classList.add('dragging');
        e.preventDefault();
        e.stopPropagation();
      }
      
      // Handle resize start
      function handleResizeStart(e) {
        chatBarDragState.isResizing = true;
        chatBarDragState.startX = e.clientX;
        chatBarDragState.startWidth = chatBar.offsetWidth;
        
        e.preventDefault();
        e.stopPropagation();
      }
      
      // Mouse move handler
      chatBarDragState.mouseMoveHandler = function(e) {
        if (chatBarDragState.isDragging) {
          const deltaX = e.clientX - chatBarDragState.startX;
          const deltaY = e.clientY - chatBarDragState.startY;
          
          const overlay = document.getElementById('minimalModeOverlay');
          const overlayRect = overlay.getBoundingClientRect();
          
          // Calculate new position (note: deltaY is subtracted from bottom because Y increases downward)
          let newLeft = chatBarDragState.startLeft + deltaX;
          let newBottom = chatBarDragState.startBottom - deltaY;
          
          // Constrain to overlay bounds with margin
          const margin = 20;
          const minLeft = margin;
          const maxLeft = overlayRect.width - chatBar.offsetWidth - margin;
          const minBottom = margin;
          const maxBottom = overlayRect.height - chatBar.offsetHeight - margin;
          
          newLeft = Math.max(minLeft, Math.min(maxLeft, newLeft));
          newBottom = Math.max(minBottom, Math.min(maxBottom, newBottom));
          
          // Apply position
          chatBar.style.left = newLeft + 'px';
          chatBar.style.bottom = newBottom + 'px';
          
          e.preventDefault();
        } else if (chatBarDragState.isResizing) {
          const deltaX = e.clientX - chatBarDragState.startX;
          const newWidth = chatBarDragState.startWidth + deltaX;
          
          // Constrain width
          const minWidth = 400;
          const maxWidth = window.innerWidth * 0.95;
          const constrainedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
          
          chatBar.style.width = constrainedWidth + 'px';
          chatBar.style.maxWidth = 'none';
          
          e.preventDefault();
        }
      };
      
      // Mouse up handler
      chatBarDragState.mouseUpHandler = function() {
        if (chatBarDragState.isDragging) {
          chatBarDragState.isDragging = false;
          chatBar.classList.remove('dragging');
          
          // Validate final position
          const rect = chatBar.getBoundingClientRect();
          const overlay = document.getElementById('minimalModeOverlay');
          const overlayRect = overlay.getBoundingClientRect();
          
          // Safety check: if completely off-screen, reset
          if (rect.right < 0 || rect.left > overlayRect.width || 
              rect.bottom < 0 || rect.top > overlayRect.height) {
            console.warn('Chat bar went off-screen, resetting position');
            resetMinimalChatBarPosition();
          }
        }
        if (chatBarDragState.isResizing) {
          chatBarDragState.isResizing = false;
        }
      };
      
      // Keyboard handler
      chatBarDragState.keydownHandler = function(e) {
        if (e.key === 'Escape' && isMinimalMode) {
          const chatBar = document.getElementById('minimalChatBar');
          if (chatBar) {
            resetMinimalChatBarPosition();
          }
        }
      };
      
      // Attach event listeners
      handle.addEventListener('mousedown', handleDragStart);
      resizeHandle.addEventListener('mousedown', handleResizeStart);
      document.addEventListener('mousemove', chatBarDragState.mouseMoveHandler);
      document.addEventListener('mouseup', chatBarDragState.mouseUpHandler);
      document.addEventListener('keydown', chatBarDragState.keydownHandler);
      
      chatBarDragState.listenersAttached = true;
    }
    
    // ===== RESET MINIMAL CHAT BAR POSITION =====
    function resetMinimalChatBarPosition() {
      const chatBar = document.getElementById('minimalChatBar');
      if (!chatBar) {
        console.error('Chat bar not found');
        return;
      }
      
      // Clear any inline positioning styles
      chatBar.style.left = '';
      chatBar.style.bottom = '';
      chatBar.style.transform = '';
      chatBar.style.width = '';
      chatBar.style.maxWidth = '';
      
      // Clear any visibility overrides (let CSS handle it)
      chatBar.style.display = '';
      chatBar.style.opacity = '';
      chatBar.style.visibility = '';
      
      // Add subtle animation feedback
      chatBar.style.transition = 'box-shadow 0.3s ease';
      const originalBoxShadow = chatBar.style.boxShadow;
      chatBar.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 3px rgba(0, 83, 226, 0.6)';
      
      setTimeout(() => {
        chatBar.style.boxShadow = originalBoxShadow || '';
        chatBar.style.transition = '';
      }, 400);
      
      console.log('Chat bar position reset to default');
    }
    
    // ===== FRAMEWORK DISPLAY VISIBILITY TOGGLE =====
    function updateFrameworkDisplayVisibility() {
      const statusIndicator = document.getElementById('minimalStatusIndicator');
      const frameworkDisplay = document.getElementById('minimalFrameworkDisplay');
      
      if (!statusIndicator || !frameworkDisplay) return;
      
      // Hide framework display when status indicator is active (thinking)
      if (statusIndicator.classList.contains('active')) {
        frameworkDisplay.style.display = 'none';
      } else {
        frameworkDisplay.style.display = 'flex';
      }
    }
    
    // Watch for status indicator changes
    if (window.MutationObserver) {
      const statusIndicator = document.getElementById('minimalStatusIndicator');
      if (statusIndicator) {
        const observer = new MutationObserver(() => {
          updateFrameworkDisplayVisibility();
        });
        observer.observe(statusIndicator, { attributes: true, attributeFilter: ['class'] });
      }
    }
    
    // ===== INITIALIZATION =====
    document.addEventListener('DOMContentLoaded', async () => {
      console.log(' ========================================');
      console.log(' APP BUILDER INTERFACE LOADED');
      console.log(' VERSION: Minimal Element Selector Icon Fix v5.3 (Dec 12, 2025)');
      console.log(' ========================================');
      
      // Initialize Lucide icons on page load
      if (window.lucide) {
        lucide.createIcons();
        console.log(' Lucide icons initialized on page load');
      }
      
      // Setup window blur listener for minimal mode
      setupWindowBlurListener();
      
      // Initialize drag and drop for image upload
      initDragAndDrop();
      
      // Auto-resize chat textarea
      const chatInput = document.getElementById('chatInput');
      chatInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = Math.min(this.scrollHeight, 120) + 'px';
      });
      
      // Enter to send
      chatInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });
      
      // Global keyboard shortcuts for version navigation and minimal mode
      document.addEventListener('keydown', function(e) {
        // Escape key = Exit minimal mode or element selector
        if (e.key === 'Escape') {
          // First check if minimal element selector is active
          if (minimalElementSelectorActive) {
            e.preventDefault();
            toggleMinimalElementSelector();
            return;
          }
          // Then check normal element selector
          if (elementSelectorActive) {
            e.preventDefault();
            toggleElementSelector();
            return;
          }
          // Finally check if in minimal mode
          if (isMinimalMode) {
            e.preventDefault();
            exitMinimalMode();
            return;
          }
        }
        
        // Don't process other shortcuts in minimal mode
        if (isMinimalMode) return;
        
        // Ctrl/Cmd + Z = Previous version (undo)
        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          gotoPreviousVersion();
        }
        // Ctrl/Cmd + Shift + Z = Next version (redo)
        else if ((e.ctrlKey || e.metaKey) && e.key === 'z' && e.shiftKey) {
          e.preventDefault();
          gotoNextVersion();
        }
      });
      
      // Minimal mode chat input handlers
      const minimalChatInput = document.getElementById('minimalChatInput');
      
      // Auto-resize minimal chat textarea
      minimalChatInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = Math.min(this.scrollHeight, 120) + 'px';
      });
      
      // Enter to send in minimal mode
      minimalChatInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMinimalMessage();
        }
      });
      
      // Initialize
      initLucideIcons();
      
      // Load version history from localStorage
      loadVersionHistory();
      
      // DO NOT restore project on page load - always start with welcome screen
      // User must manually select a project from the dropdown
      // This ensures clean state and prevents showing old cached HTML
      currentProjectId = null;
      localStorage.removeItem('currentProjectId'); // Clear any saved project
      console.log(' Starting fresh - No project selected, showing welcome screen');
      
      // Check API health first before loading any data
      console.log(' Checking API connection...');
      try {
        const healthResponse = await fetch(`${API_BASE}/api/health`);
        const healthData = await healthResponse.json();
        
        if (healthData.success) {
          console.log(' API connected successfully');
          
          // Load projects first
          console.log(' Loading projects...');
          await loadProjects();
          
          // Update project selector with loaded projects
          updateProjectSelector();
          
          // Load initial data sequentially after API is confirmed working
          console.log(' Loading overview data...');
          await loadOverviewData();
          
          // Database tables will load only when user clicks on Database tab (via switchCloudNav)
          
          // Load versions FIRST (single query gets all data we need)
          // This replaces multiple separate queries for: table existence check, latest HTML, max version
          if (currentProjectId) {
            console.log(' Loading version history from database...');
            await loadDBVersions();
          }
          
          // Load latest project into preview (uses dbVersions data if available)
          console.log(' Loading latest HTML cache...');
          await loadLatestProject();
          
          // Note: updatePublishStatusIndicator() removed - publish links approach changed
          
          if (currentProjectId) {
            
            // Load chat history for this project (track loading promise for race condition prevention)
            console.log(' Loading chat history...');
            chatHistoryLoadingPromise = loadChatHistory();
            await chatHistoryLoadingPromise;
            chatHistoryLoadingPromise = null;
            
            // Note: CRUD validation disabled - not needed on every page load
            // Uncomment only for debugging/development
            // console.log(' Validating CRUD operations...');
            // const validationResult = await validateProjectCRUD(currentProjectId);
            // 
            // if (validationResult.success && validationResult.results) {
            //   const { tables_validated, tables_passed, tables_failed } = validationResult.results;
            //   if (tables_validated > 0) {
            //     if (tables_failed > 0) {
            //       console.warn(` CRUD validation: ${tables_failed}/${tables_validated} tables have issues`);
            //     } else {
            //       console.log(` CRUD validation: All ${tables_validated} tables working correctly`);
            //     }
            //   }
            // }
          }
          
          console.log(' All initialization complete');
        } else {
          throw new Error('API health check failed');
        }
      } catch (err) {
        console.error(' API connection error:', err);
        console.error(' Failed to connect to:', API_BASE);
        addMessageToChat('system error', 'The service is temporarily unavailable. Please check your connection and try again in a moment.');
        // Still show welcome screen even if API fails
        showWelcomeScreen();
      }
    });
  </script>

  <script>
    // ========================================
    // APP BUILDER ENHANCEMENTS V2.0
    // Zero Infinite Loops | Auto-Fix | Stop Button
    // ========================================
    
    console.log(' Loading App Builder Enhancements v2.0...');
    
    // ===== GLOBAL STATE =====
    window.appBuilderEnhancements = {
      version: '2.0.0',
      stopRequested: false,
      streamAbortController: null,
      errorHistory: [],
      progressTracker: { lastHTMLSnapshot: null, noProgressCount: 0, lastProgress: Date.now() },
      circuitBreaker: { failures: 0, threshold: 5, cooldownPeriod: 60000, lastFailure: null, state: 'CLOSED' },
      watchdogTimer: null,
      loopMetrics: {
        totalIterations: 0, duplicateErrors: 0, noProgressStops: 0,
        circuitBreakerTrips: 0, watchdogTimeouts: 0, successfulCompletions: 0,
        autoFixAttempts: 0, autoFixSuccesses: 0
      }
    };
    
    // ===== STOP GENERATION =====
    window.stopGeneration = function(reason) {
      console.log(' STOPPING:', reason);
      const state = window.appBuilderEnhancements;
      state.stopRequested = true;
      if (state.streamAbortController) state.streamAbortController.abort();
      if (typeof continueLoop !== 'undefined') window.continueLoop = false;
      if (typeof isStreaming !== 'undefined') window.isStreaming = false;
      if (state.watchdogTimer) { clearTimeout(state.watchdogTimer); state.watchdogTimer = null; }
      const stopBtn = document.getElementById('stopGenerationBtn');
      if (stopBtn) stopBtn.style.display = 'none';
      const input = document.getElementById('chatInput');
      const sendBtn = document.getElementById('chatSendBtn');
      if (input) input.disabled = false;
      if (sendBtn) sendBtn.disabled = false;
      if (typeof removeProgressIndicator === 'function') removeProgressIndicator();
      addMessageToChat('system', ' Stopped. Ready for new requests.');
      if (input) input.focus();
    };
    
    // ESC key handler
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && window.isStreaming) stopGeneration('ESC key');
    });
    
    // ===== ERROR DEDUPLICATION =====
    window.isDuplicateError = function(error) {
      const state = window.appBuilderEnhancements;
      const errorString = typeof error === 'string' ? error : (error.message || '');
      const recentErrors = state.errorHistory.slice(-3);
      const duplicates = recentErrors.filter(e => {
        const eString = typeof e === 'string' ? e : (e.message || '');
        return eString === errorString || (eString && errorString && eString.substring(0, 100) === errorString.substring(0, 100));
      });
      if (duplicates.length >= 2) {
        console.error(' DUPLICATE ERROR - Breaking loop');
        state.loopMetrics.duplicateErrors++;
        return true;
      }
      state.errorHistory.push(error);
      if (state.errorHistory.length > 10) state.errorHistory.shift();
      return false;
    };
    
    // ===== PROGRESS TRACKING =====
    window.trackProgress = function(currentHTML) {
      const state = window.appBuilderEnhancements;
      const tracker = state.progressTracker;
      if (tracker.lastHTMLSnapshot === currentHTML) {
        tracker.noProgressCount++;
        if (tracker.noProgressCount >= 3) {
          console.error(' NO PROGRESS DETECTED');
          state.loopMetrics.noProgressStops++;
          addMessageToChat('system', ' Having difficulty. Showing current state. Try breaking request into steps.');
          return false;
        }
      } else {
        tracker.noProgressCount = 0;
        tracker.lastProgress = Date.now();
      }
      tracker.lastHTMLSnapshot = currentHTML;
      return true;
    };
    
    // ===== CIRCUIT BREAKER =====
    window.recordFailure = function() {
      const breaker = window.appBuilderEnhancements.circuitBreaker;
      breaker.failures++;
      breaker.lastFailure = Date.now();
      if (breaker.failures >= breaker.threshold) {
        breaker.state = 'OPEN';
        console.error(' CIRCUIT BREAKER OPENED');
        window.appBuilderEnhancements.loopMetrics.circuitBreakerTrips++;
        addMessageToChat('system', ' System cooling down. Rephrase request or break into smaller steps. Resetting in 1 minute.');
        setTimeout(() => window.resetCircuitBreaker(), breaker.cooldownPeriod);
      }
    };
    
    window.canProceed = function() {
      const breaker = window.appBuilderEnhancements.circuitBreaker;
      if (breaker.state === 'OPEN') {
        const elapsed = Date.now() - breaker.lastFailure;
        if (elapsed > breaker.cooldownPeriod) {
          window.resetCircuitBreaker();
          return true;
        }
        return false;
      }
      return true;
    };
    
    window.resetCircuitBreaker = function() {
      const breaker = window.appBuilderEnhancements.circuitBreaker;
      breaker.failures = 0;
      breaker.state = 'CLOSED';
      console.log(' Circuit breaker reset');
      addMessageToChat('system', ' System reset. Ready for requests.');
    };
    
    // ===== WATCHDOG TIMER =====
    window.startWatchdog = function(timeoutMs) {
      timeoutMs = timeoutMs || 120000;
      window.stopWatchdog();
      const state = window.appBuilderEnhancements;
      state.watchdogTimer = setTimeout(() => {
        console.error(' WATCHDOG TIMEOUT');
        state.loopMetrics.watchdogTimeouts++;
        stopGeneration('Task timeout after ' + (timeoutMs/1000) + 's');
        addMessageToChat('system', ' Task taking too long (' + (timeoutMs/1000) + 's). Showing partial progress. Break into smaller pieces.');
      }, timeoutMs);
      console.log(' Watchdog started (' + (timeoutMs/1000) + 's)');
    };
    
    window.stopWatchdog = function() {
      const state = window.appBuilderEnhancements;
      if (state.watchdogTimer) {
        clearTimeout(state.watchdogTimer);
        state.watchdogTimer = null;
      }
    };
    
    // ===== METRICS =====
    window.logEnhancementMetrics = function() {
      const m = window.appBuilderEnhancements.loopMetrics;
      console.log(' ENHANCEMENT METRICS:');
      console.table({
        'Total Iterations': m.totalIterations,
        'Duplicate Errors Caught': m.duplicateErrors,
        'No-Progress Stops': m.noProgressStops,
        'Circuit Breaker Trips': m.circuitBreakerTrips,
        'Watchdog Timeouts': m.watchdogTimeouts,
        'Successful Completions': m.successfulCompletions,
        'Auto-Fix Attempts': m.autoFixAttempts,
        'Auto-Fix Successes': m.autoFixSuccesses,
        'Success Rate': m.totalIterations > 0 ? ((m.successfulCompletions / m.totalIterations) * 100).toFixed(2) + '%' : 'N/A'
      });
    };
    
    // ===== CODE ANALYSIS =====
    window.analyzeExistingCode = function(code) {
      console.log(' Analyzing code...');
      const structure = {
        hasHTML: /<html[^>]*>/i.test(code),
        hasHead: /<head[^>]*>/i.test(code),
        hasBody: /<body[^>]*>/i.test(code),
        totalLines: code.split('\n').length,
        sizeKB: (code.length / 1024).toFixed(2)
      };
      const components = [];
      const idMatches = code.matchAll(/id=["']([^"']+)["']/gi);
      for (const match of idMatches) components.push({ type: 'id', name: match[1] });
      return { structure, components };
    };
    
    console.log(' Enhancements loaded. Type window.logEnhancementMetrics() for stats');
    
  </script>
</body>
</html>